diff -x'.*' -x'*.o' -urNBp busybox.orig/include/applets.src.h busybox/include/applets.src.h
--- busybox.orig/include/applets.src.h	2010-07-25 22:48:26.000000000 +0400
+++ busybox/include/applets.src.h	2011-02-05 13:41:12.000000000 +0300
@@ -112,6 +112,8 @@ IF_DELUSER(APPLET(deluser, _BB_DIR_BIN, 
 IF_DEVFSD(APPLET(devfsd, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_DEVMEM(APPLET(devmem, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_DF(APPLET(df, _BB_DIR_BIN, _BB_SUID_DROP))
+IF_DHCP6C(APPLET(dhcp6c, _BB_DIR_SBIN, _BB_SUID_DROP))
+IF_DHCP6RELAY(APPLET(dhcp6relay, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
 IF_DHCPRELAY(APPLET(dhcprelay, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
 IF_DIFF(APPLET(diff, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_DIRNAME(APPLET_NOFORK(dirname, dirname, _BB_DIR_USR_BIN, _BB_SUID_DROP, dirname))
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/auth6.c busybox/networking/udhcp/auth6.c
--- busybox.orig/networking/udhcp/auth6.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/auth6.c	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (C) 2000, 2001  Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
+ * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
+ * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+
+#include <netinet/in.h>
+
+#include <syslog.h>
+#include <string.h>
+#include <errno.h>
+
+#include "libbb.h"
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "auth6.h"
+
+#define HMACMD5_KEYLENGTH 64
+
+typedef struct {
+	md5_ctx_t md5ctx;
+	unsigned char key[HMACMD5_KEYLENGTH];
+} hmacmd5_t;
+
+static void hmacmd5_init(hmacmd5_t *, const unsigned char *,
+    unsigned int);
+static ALWAYS_INLINE void hmacmd5_invalidate(hmacmd5_t *);
+static ALWAYS_INLINE void hmacmd5_update(hmacmd5_t *, const unsigned char *,
+    unsigned int);
+static void hmacmd5_sign(hmacmd5_t *, unsigned char *);
+static int hmacmd5_verify(hmacmd5_t *, unsigned char *);
+
+
+int dhcp6_validate_key(struct keyinfo *key)
+{
+	time_t now;
+
+	if (key->expire == 0)	/* never expire */
+		return (0);
+
+	if (time(&now) == -1)
+		return (-1);	/* treat it as expiration (XXX) */
+
+	if (now > key->expire)
+		return (-1);
+
+	return (0);
+}
+
+int dhcp6_calc_mac(char *buf, size_t len, int proto __attribute__((unused)),
+		int alg, size_t off, struct keyinfo *key)
+{
+	hmacmd5_t ctx;
+	unsigned char digest[MD5_DIGESTLENGTH];
+
+	/* right now, we don't care about the protocol */
+
+	if (alg != DHCP6_AUTHALG_HMACMD5)
+		return (-1);
+
+	if (off + MD5_DIGESTLENGTH > len) {
+		/*
+		 * this should be assured by the caller, but check it here
+		 * for safety.
+		 */
+		return (-1);
+	}
+
+	hmacmd5_init(&ctx, key->secret, key->secretlen);
+	hmacmd5_update(&ctx, (unsigned char *)buf, len);
+	hmacmd5_sign(&ctx, digest);
+
+	memcpy(buf + off, digest, MD5_DIGESTLENGTH);
+
+	return (0);
+}
+
+int dhcp6_verify_mac(char *buf, ssize_t len, int proto __attribute__((unused)),
+		 int alg, size_t off, struct keyinfo *key)
+{
+	hmacmd5_t ctx;
+	unsigned char digest[MD5_DIGESTLENGTH];
+	int result;
+
+	/* right now, we don't care about the protocol */
+
+	if (alg != DHCP6_AUTHALG_HMACMD5)
+		return (-1);
+
+	if (off + MD5_DIGESTLENGTH > len)
+		return (-1);
+
+	/*
+	 * Copy the MAC value and clear the field.
+	 * XXX: should we make a local working copy?
+	 */
+	memcpy(digest, buf + off, sizeof(digest));
+	memset(buf + off, 0, sizeof(digest));
+
+	hmacmd5_init(&ctx, key->secret, key->secretlen);
+	hmacmd5_update(&ctx, (unsigned char *)buf, len);
+	result = hmacmd5_verify(&ctx, digest);
+
+	/* copy back the digest value (XXX) */
+	memcpy(buf + off, digest, sizeof(digest));
+
+	return (result);
+}
+
+/*
+ * This code implements the HMAC-MD5 keyed hash algorithm
+ * described in RFC 2104.
+ */
+
+#define PADLEN 64
+#define IPAD 0x36
+#define OPAD 0x5C
+
+/*
+ * Start HMAC-MD5 process.  Initialize an md5 context and digest the key.
+ */
+static void hmacmd5_init(hmacmd5_t *ctx,
+				 const unsigned char *key, unsigned int len)
+{
+	unsigned char ipad[PADLEN];
+	int i;
+
+	memset(ctx->key, 0, sizeof(ctx->key));
+	if (len > sizeof(ctx->key)) {
+		md5_ctx_t md5ctx;
+		md5_begin(&md5ctx);
+		md5_hash(&md5ctx, key, len);
+		md5_end(&md5ctx, ctx->key);
+	} else
+		memcpy(ctx->key, key, len);
+
+	md5_begin(&ctx->md5ctx);
+	memset(ipad, IPAD, sizeof(ipad));
+	for (i = 0; i < PADLEN; i++)
+		ipad[i] ^= ctx->key[i];
+	md5_hash(&ctx->md5ctx, ipad, sizeof(ipad));
+}
+
+static ALWAYS_INLINE void hmacmd5_invalidate(hmacmd5_t *ctx)
+{
+	memset(ctx, 0, sizeof(ctx));
+}
+
+/*
+ * Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ */
+static ALWAYS_INLINE void hmacmd5_update(hmacmd5_t *ctx,
+				 const unsigned char *buf, unsigned int len)
+{
+	md5_hash(&ctx->md5ctx, buf, len);
+}
+
+/*
+ * Compute signature - finalize MD5 operation and reapply MD5.
+ */
+static void hmacmd5_sign(hmacmd5_t *ctx, unsigned char *digest)
+{
+	unsigned char opad[PADLEN];
+	int i;
+
+	md5_end(&ctx->md5ctx, digest);
+
+	memset(opad, OPAD, sizeof(opad));
+	for (i = 0; i < PADLEN; i++)
+		opad[i] ^= ctx->key[i];
+
+	md5_begin(&ctx->md5ctx);
+	md5_hash(&ctx->md5ctx, opad, sizeof(opad));
+	md5_hash(&ctx->md5ctx, digest, MD5_DIGESTLENGTH);
+	md5_end(&ctx->md5ctx, digest);
+	hmacmd5_invalidate(ctx);
+}
+
+/*
+ * Verify signature - finalize MD5 operation and reapply MD5, then
+ * compare to the supplied digest.
+ */
+static int hmacmd5_verify(hmacmd5_t *ctx, unsigned char *digest) {
+	unsigned char newdigest[MD5_DIGESTLENGTH];
+
+	hmacmd5_sign(ctx, newdigest);
+	return (memcmp(digest, newdigest, MD5_DIGESTLENGTH));
+}
+
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/auth6.h busybox/networking/udhcp/auth6.h
--- busybox.orig/networking/udhcp/auth6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/auth6.h	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#define MD5_DIGESTLENGTH 16
+
+/* secret key information for delayed authentication */
+struct keyinfo {
+	struct keyinfo *next;
+
+	char *name;		/* key name */
+
+	char *realm;		/* DHCP realm */
+	size_t realmlen;	/* length of realm */
+	uint32_t keyid;		/* key ID */
+	unsigned char *secret;	/* binary key */
+	size_t secretlen;	/* length of the key */
+	time_t expire;		/* expiration time (0 means forever) */
+};
+
+int dhcp6_validate_key(struct keyinfo *);
+int dhcp6_calc_mac(char *, size_t, int, int, size_t,
+    struct keyinfo *);
+int dhcp6_verify_mac(char *, ssize_t, int, int, size_t,
+    struct keyinfo *);
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/base64.c busybox/networking/udhcp/base64.c
--- busybox.orig/networking/udhcp/base64.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/base64.c	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (C) 1998-2001, 2003  Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
+ * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
+ * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <string.h>
+
+#include "libbb.h"
+#include "base64.h"
+
+/*
+ * State of a base64 decoding process in progress.
+ */
+typedef struct {
+	int length;		/* Desired length of binary data or -1 */
+	int digits;		/* Number of buffered base64 digits */
+	bool seen_end;	        /* True if "=" end marker seen */
+	int val[4];
+
+	char *dst;		/* Head of the available space for resulting
+				 * binary data */
+	char *dstend;		/* End of the buffer */
+} base64_decode_ctx_t;
+
+static int
+mem_tobuffer(base64_decode_ctx_t *ctx, void *base, unsigned int length)
+{
+	if (ctx->dst + length >= ctx->dstend)
+		return (-1);
+	memcpy(ctx->dst, base, length);
+	ctx->dst += length;
+	return (0);
+}
+
+static inline void
+base64_decode_init(base64_decode_ctx_t *ctx, int length,
+    char *result, size_t resultlen)
+{
+	ctx->digits = 0;
+	ctx->seen_end = FALSE;
+	ctx->length = length;
+	ctx->dst = result;
+	ctx->dstend = result + resultlen;
+}
+
+static inline int
+base64_decode_char(base64_decode_ctx_t *ctx, int c)
+{
+	char *s;
+
+	if (ctx->seen_end == TRUE)
+		return (-1);
+	if ((s = strchr(bb_uuenc_tbl_base64, c)) == NULL)
+		return (-1);
+	ctx->val[ctx->digits++] = s - bb_uuenc_tbl_base64;
+	if (ctx->digits == 4) {
+		int n;
+		unsigned char buf[3];
+		if (ctx->val[0] == 64 || ctx->val[1] == 64)
+			return (-1);
+		if (ctx->val[2] == 64 && ctx->val[3] != 64)
+			return (-1);
+		/*
+		 * Check that bits that should be zero are.
+		 */
+		if (ctx->val[2] == 64 && (ctx->val[1] & 0xf) != 0)
+			return (-1);
+		/*
+		 * We don't need to test for ctx->val[2] != 64 as
+		 * the bottom two bits of 64 are zero.
+		 */
+		if (ctx->val[3] == 64 && (ctx->val[2] & 0x3) != 0)
+			return (-1);
+		n = (ctx->val[2] == 64) ? 1 :
+			(ctx->val[3] == 64) ? 2 : 3;
+		if (n != 3) {
+			ctx->seen_end = TRUE;
+			if (ctx->val[2] == 64)
+				ctx->val[2] = 0;
+			if (ctx->val[3] == 64)
+				ctx->val[3] = 0;
+		}
+		buf[0] = (ctx->val[0]<<2)|(ctx->val[1]>>4);
+		buf[1] = (ctx->val[1]<<4)|(ctx->val[2]>>2);
+		buf[2] = (ctx->val[2]<<6)|(ctx->val[3]);
+		if (mem_tobuffer(ctx, buf, n))
+			return (-1);
+		if (ctx->length >= 0) {
+			if (n > ctx->length)
+				return (-1);
+			else
+				ctx->length -= n;
+		}
+		ctx->digits = 0;
+	}
+	return (0);
+}
+
+static inline int
+base64_decode_finish(base64_decode_ctx_t *ctx)
+{
+	if (ctx->length > 0)
+		return (-1);
+	if (ctx->digits != 0)
+		return (-1);
+	return (0);
+}
+
+int
+base64_decodestring(const char *cstr, char *result, size_t resultlen)
+{
+	base64_decode_ctx_t ctx;
+
+	base64_decode_init(&ctx, -1, result, resultlen);
+	for (;;) {
+		int c = *cstr++;
+		if (c == '\0')
+			break;
+		if (c == ' ' || c == '\t' || c == '\n' || c== '\r')
+			continue;
+		if (base64_decode_char(&ctx, c))
+			return (-1);
+	}
+	if (base64_decode_finish(&ctx))
+		return (-1);
+	return (ctx.dst - result);
+}
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/base64.h busybox/networking/udhcp/base64.h
--- busybox.orig/networking/udhcp/base64.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/base64.h	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+int base64_decodestring(const char *, char *, size_t);
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/common6.c busybox/networking/udhcp/common6.c
--- busybox.orig/networking/udhcp/common6.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/common6.c	2011-02-08 16:06:44.000000000 +0300
@@ -0,0 +1,2583 @@
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <sys/queue.h>
+#include <sys/stat.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#ifdef __FreeBSD__
+#include <net/if_var.h>
+#endif
+
+#include <ctype.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <err.h>
+#include <netdb.h>
+#include <ifaddrs.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+
+/* dhcp6c.c */
+extern struct dhcp6_timer *client6_timo(void *);
+extern void destruct_iadata(struct dhcp6_eventdata *evd);
+/* if6.c */
+extern ssize_t gethwid(char *, int, const char *, uint16_t *);
+
+#define MAXDNAME 255
+
+static ALWAYS_INLINE int dhcp6_count_list(struct dhcp6_list *);
+#if /*ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+static ssize_t dnsencode(const char *, char *, size_t);
+#endif
+static char *dnsdecode(u_char **, u_char *, char *, size_t);
+static int copyout_option(char *, char *, struct dhcp6_listval *);
+static int copyin_option(int, struct dhcp6opt *, struct dhcp6opt *,
+    struct dhcp6_list *);
+static int copy_option(uint16_t, uint16_t, void *, struct dhcp6opt **,
+    struct dhcp6opt *, int *);
+static int sa6_plen2mask(struct sockaddr_in6 *, int);
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static char *sprint_uint64(char *, int, uint64_t);
+static char *sprint_auth(struct dhcp6_optinfo *);
+#endif
+
+
+int dhcp6_copy_list(struct dhcp6_list *dst, struct dhcp6_list *src)
+{
+	struct dhcp6_listval *ent;
+
+	for (ent = TAILQ_FIRST(src); ent; ent = TAILQ_NEXT(ent, link)) {
+		if (dhcp6_add_listval(dst, ent->type,
+		    &ent->uv, &ent->sublist) == NULL)
+			goto fail;
+	}
+
+	return (0);
+
+fail:
+	dhcp6_clear_list(dst);
+	return (-1);
+}
+
+void dhcp6_move_list(struct dhcp6_list *dst, struct dhcp6_list *src)
+{
+	struct dhcp6_listval *v;
+
+	while ((v = TAILQ_FIRST(src)) != NULL) {
+		TAILQ_REMOVE(src, v, link);
+		TAILQ_INSERT_TAIL(dst, v, link);
+	}
+}
+
+void dhcp6_clear_list(struct dhcp6_list *head)
+{
+	struct dhcp6_listval *v;
+
+	while ((v = TAILQ_FIRST(head)) != NULL) {
+		TAILQ_REMOVE(head, v, link);
+		dhcp6_clear_listval(v);
+	}
+}
+
+static ALWAYS_INLINE int dhcp6_count_list(struct dhcp6_list *head)
+{
+	struct dhcp6_listval *v;
+	int i;
+
+	for (i = 0, v = TAILQ_FIRST(head); v; v = TAILQ_NEXT(v, link))
+		i++;
+
+	return (i);
+}
+
+void dhcp6_clear_listval(struct dhcp6_listval *lv)
+{
+	dhcp6_clear_list(&lv->sublist);
+	switch (lv->type) {
+	case DHCP6_LISTVAL_VBUF:
+		dhcp6_vbuf_free(&lv->val_vbuf);
+		break;
+	default:		/* nothing to do */
+		break;
+	}
+	free(lv);
+}
+
+/*
+ * Note: this function only searches for the first entry that matches
+ * VAL.  It also does not care about sublists.
+ */
+struct dhcp6_listval *dhcp6_find_listval(struct dhcp6_list *head,
+		dhcp6_listval_type_t type, void *val, int option)
+{
+	struct dhcp6_listval *lv;
+
+	for (lv = TAILQ_FIRST(head); lv; lv = TAILQ_NEXT(lv, link)) {
+		if (lv->type != type)
+			continue;
+
+		switch (type) {
+		case DHCP6_LISTVAL_NUM:
+			if (lv->val_num == *(int *)val)
+				return (lv);
+			break;
+		case DHCP6_LISTVAL_STCODE:
+			if (lv->val_num16 == *(uint16_t *)val)
+				return (lv);
+			break;
+		case DHCP6_LISTVAL_ADDR6:
+			if (IN6_ARE_ADDR_EQUAL(&lv->val_addr6,
+			    (struct in6_addr *)val)) {
+				return (lv);
+			}
+			break;
+		case DHCP6_LISTVAL_PREFIX6:
+			if ((option & MATCHLIST_PREFIXLEN) &&
+			    lv->val_prefix6.plen ==
+			    ((struct dhcp6_prefix *)val)->plen) {
+				return (lv);
+			} else if (IN6_ARE_ADDR_EQUAL(&lv->val_prefix6.addr,
+			    &((struct dhcp6_prefix *)val)->addr) &&
+			    lv->val_prefix6.plen ==
+			    ((struct dhcp6_prefix *)val)->plen) {
+				return (lv);
+			}
+			break;
+		case DHCP6_LISTVAL_STATEFULADDR6:
+			if (IN6_ARE_ADDR_EQUAL(&lv->val_statefuladdr6.addr,
+			    &((struct dhcp6_prefix *)val)->addr)) {
+				return (lv);
+			}
+			break;
+		case DHCP6_LISTVAL_IAPD:
+		case DHCP6_LISTVAL_IANA:
+			if (lv->val_ia.iaid ==
+			    ((struct dhcp6_ia *)val)->iaid) {
+				return (lv);
+			}
+			break;
+		case DHCP6_LISTVAL_VBUF:
+			if (dhcp6_vbuf_cmp(&lv->val_vbuf,
+			    (struct dhcp6_vbuf *)val) == 0) {
+				return (lv);
+			}
+			break;
+		}
+	}
+
+	return (NULL);
+}
+
+struct dhcp6_listval *dhcp6_add_listval(struct dhcp6_list *head,
+		dhcp6_listval_type_t type, void *val, struct dhcp6_list *sublist)
+{
+	struct dhcp6_listval *lv = NULL;
+
+	lv = xzalloc(sizeof(*lv));
+	lv->type = type;
+	TAILQ_INIT(&lv->sublist);
+
+	switch (type) {
+	case DHCP6_LISTVAL_NUM:
+		lv->val_num = *(int *)val;
+		break;
+	case DHCP6_LISTVAL_STCODE:
+		lv->val_num16 = *(uint16_t *)val;
+		break;
+	case DHCP6_LISTVAL_ADDR6:
+		lv->val_addr6 = *(struct in6_addr *)val;
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		lv->val_prefix6 = *(struct dhcp6_prefix *)val;
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		lv->val_statefuladdr6 = *(struct dhcp6_statefuladdr *)val;
+		break;
+	case DHCP6_LISTVAL_IAPD:
+	case DHCP6_LISTVAL_IANA:
+		lv->val_ia = *(struct dhcp6_ia *)val;
+		break;
+	case DHCP6_LISTVAL_VBUF:
+		if (dhcp6_vbuf_copy(&lv->val_vbuf, (struct dhcp6_vbuf *)val))
+			goto fail;
+		break;
+	default:
+		bb_error_msg("unexpected list value type (%d)", type);
+		goto fail;
+	}
+
+	if (sublist && dhcp6_copy_list(&lv->sublist, sublist))
+		goto fail;
+
+	TAILQ_INSERT_TAIL(head, lv, link);
+
+	return (lv);
+
+  fail:
+	if (lv)
+		free(lv);
+
+	return (NULL);
+}
+
+int dhcp6_vbuf_copy(struct dhcp6_vbuf *dst, struct dhcp6_vbuf *src)
+{
+	dst->dv_buf = malloc_or_warn(src->dv_len);
+	if (dst->dv_buf == NULL)
+		return (-1);
+
+	dst->dv_len = src->dv_len;
+	memcpy(dst->dv_buf, src->dv_buf, dst->dv_len);
+
+	return (0);
+}
+
+void dhcp6_vbuf_free(struct dhcp6_vbuf *vbuf)
+{
+	free(vbuf->dv_buf);
+
+	vbuf->dv_len = 0;
+	vbuf->dv_buf = NULL;
+}
+
+int dhcp6_vbuf_cmp(struct dhcp6_vbuf *vb1, struct dhcp6_vbuf *vb2)
+{
+	if (vb1->dv_len != vb2->dv_len)
+		return (vb1->dv_len - vb2->dv_len);
+
+	return (memcmp(vb1->dv_buf, vb2->dv_buf, vb1->dv_len));
+}
+
+static int dhcp6_get_addr(int optlen, void *cp, dhcp6_listval_type_t type,
+			  struct dhcp6_list *list)
+{
+	void *val;
+
+	if (optlen % sizeof(struct in6_addr) || optlen == 0) {
+		bb_info_msg(
+		    "malformed DHCP option: type %d, len %d", type, optlen);
+		return -1;
+	}
+	for (val = cp; val < cp + optlen; val += sizeof(struct in6_addr)) {
+		struct in6_addr valaddr;
+
+		memcpy(&valaddr, val, sizeof(valaddr));
+		if (dhcp6_find_listval(list,
+		    DHCP6_LISTVAL_ADDR6, &valaddr, 0)) {
+			char *a = in6addr2str(&valaddr, 0);
+			bb_info_msg("duplicated %s address (%s)",
+			    dhcp6optstr(type), a);
+			free(a);
+			continue;
+		}
+
+		if (dhcp6_add_listval(list, DHCP6_LISTVAL_ADDR6,
+		    &valaddr, NULL) == NULL) {
+			bb_error_msg("failed to copy %s address", dhcp6optstr(type));
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#if /*ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+static int dhcp6_set_addr(dhcp6_listval_type_t type, struct dhcp6_list *list,
+	       struct dhcp6opt **p, struct dhcp6opt *optep, int *len)
+{
+	struct in6_addr *in6;
+	char *tmpbuf;
+	struct dhcp6_listval *d;
+	int optlen;
+
+	if (TAILQ_EMPTY(list))
+		return 0;
+
+	optlen = dhcp6_count_list(list) * sizeof(struct in6_addr);
+	tmpbuf = xmalloc(optlen);
+	in6 = (struct in6_addr *)tmpbuf;
+	for (d = TAILQ_FIRST(list); d; d = TAILQ_NEXT(d, link), in6++)
+		memcpy(in6, &d->val_addr6, sizeof(*in6));
+	if (copy_option(type, optlen, tmpbuf, p, optep, len) != 0) {
+		free(tmpbuf);
+		return -1;
+	}
+
+	free(tmpbuf);
+	return 0;
+}
+#endif
+
+static int dhcp6_get_domain(int optlen, void *cp, dhcp6_listval_type_t type,
+			    struct dhcp6_list *list)
+{
+	void *val;
+
+	val = cp;
+	while (val < cp + optlen) {
+		struct dhcp6_vbuf vb;
+		char name[MAXDNAME + 1];
+
+		if (dnsdecode((u_char **)(void *)&val,
+		    (u_char *)(cp + optlen), name, sizeof(name)) == NULL) {
+			bb_info_msg("failed to decode a %s domain name",
+			    dhcp6optstr(type));
+			bb_info_msg("malformed DHCP option: type %d, len %d",
+			     type, optlen);
+			return -1;
+		}
+
+		vb.dv_len = strlen(name) + 1;
+		vb.dv_buf = name;
+
+		if (dhcp6_add_listval(list,
+		    DHCP6_LISTVAL_VBUF, &vb, NULL) == NULL) {
+			bb_error_msg("failed to "
+			    "copy a %s domain name", dhcp6optstr(type));
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#if /*ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+static int dhcp6_set_domain(dhcp6_listval_type_t type, struct dhcp6_list *list,
+			 struct dhcp6opt **p, struct dhcp6opt *optep, int *len)
+{
+	int optlen = 0;
+	struct dhcp6_listval *d;
+	char *tmpbuf;
+	char name[MAXDNAME], *cp, *ep;
+
+	if (TAILQ_EMPTY(list))
+		return 0;
+
+	for (d = TAILQ_FIRST(list); d; d = TAILQ_NEXT(d, link))
+		optlen += (d->val_vbuf.dv_len + 1);
+
+	if (optlen == 0) {
+		return 0;
+	}
+
+	tmpbuf = NULL;
+	if ((tmpbuf = malloc_or_warn(optlen)) == NULL) {
+		return -1;
+	}
+	cp = tmpbuf;
+	ep = cp + optlen;
+	for (d = TAILQ_FIRST(list); d; d = TAILQ_NEXT(d, link)) {
+		int nlen;
+
+		nlen = dnsencode((const char *)d->val_vbuf.dv_buf,
+		    name, sizeof(name));
+		if (nlen < 0) {
+			bb_error_msg("failed to encode a %s domain name",
+			    dhcp6optstr(type));
+			free(tmpbuf);
+			return -1;
+		}
+		if (ep - cp < nlen) {
+			bb_error_msg("buffer length for %s domain name is too short",
+			    dhcp6optstr(type));
+			free(tmpbuf);
+			return -1;
+		}
+		memcpy(cp, name, nlen);
+		cp += nlen;
+	}
+	if (copy_option(type, cp - tmpbuf, tmpbuf, p, optep, len) != 0) {
+		free(tmpbuf);
+		return -1;
+	}
+	free(tmpbuf);
+
+	return 0;
+}
+#endif
+
+struct dhcp6_event *dhcp6_create_event(struct dhcp6_if *ifp, int state)
+{
+	struct dhcp6_event *ev;
+
+	ev = xzalloc(sizeof(*ev));
+	ev->ifp = ifp;
+	ev->state = state;
+	TAILQ_INIT(&ev->data_list);
+
+	TAILQ_INSERT_TAIL(&ifp->event_list, ev, link);
+
+	ev->timer = dhcp6_timer_add(client6_timo, ev);
+
+	return (ev);
+}
+
+void dhcp6_remove_event(struct dhcp6_event *ev)
+{
+	struct dhcp6_serverinfo *sp, *sp_next;
+
+	log1("removing an event on %s, state=%s",
+	    ev->ifp->ifname, dhcp6_event_statestr(ev));
+
+	if (ev->timer)
+		dhcp6_timer_remove(&ev->timer);
+
+	dhcp6_remove_evdata(ev);
+	duidfree(&ev->serverid);
+	TAILQ_REMOVE(&ev->ifp->event_list, ev, link);
+
+	sp = ev->servers;
+	while (sp) {
+		sp_next = sp->next;
+
+		log1("removing server (ID: %s)", duidstr(&sp->optinfo.serverID));
+		dhcp6_clear_options(&sp->optinfo);
+		if (sp->authparam != NULL)
+			free(sp->authparam);
+		free(sp);
+		sp = sp_next;
+	}
+
+	if (ev->authparam != NULL)
+		free(ev->authparam);
+
+	free(ev);
+}
+
+void dhcp6_remove_evdata(struct dhcp6_event *ev)
+{
+	struct dhcp6_eventdata *evd;
+
+	while ((evd = TAILQ_FIRST(&ev->data_list)) != NULL) {
+		TAILQ_REMOVE(&ev->data_list, evd, link);
+		destruct_iadata(evd);
+	}
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+struct authparam *new_authparam(int proto, int alg, int rdm)
+{
+	struct authparam *authparam;
+
+	authparam = xzalloc(sizeof(*authparam));
+
+	authparam->authproto = proto;
+	authparam->authalgorithm = alg;
+	authparam->authrdm = rdm;
+	authparam->key = NULL;
+	authparam->flags |= AUTHPARAM_FLAGS_NOPREVRD;
+	authparam->prevrd = 0;
+
+	return (authparam);
+}
+
+struct authparam *copy_authparam(struct authparam *authparam)
+{
+	struct authparam *dst;
+
+	if ((dst = malloc_or_warn(sizeof(*dst))) == NULL)
+		return (NULL);
+
+	memcpy(dst, authparam, sizeof(*dst));
+
+	return (dst);
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+/*
+ * Home-brew function of a 64-bit version of ntohl.
+ * XXX: is there any standard for this?
+ */
+#if (BYTE_ORDER == LITTLE_ENDIAN)
+static ALWAYS_INLINE uint64_t ntohq(uint64_t x)
+{
+	return (uint64_t)ntohl((uint32_t)(x >> 32)) |
+	    (int64_t)ntohl((uint32_t)(x & 0xffffffff)) << 32;
+}
+#else	/* (BYTE_ORDER == LITTLE_ENDIAN) */
+#define ntohq(x) (x)
+#endif
+
+int dhcp6_auth_replaycheck(int method, uint64_t prev, uint64_t current)
+{
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	char bufprev[] = "ffff ffff ffff ffff";
+	char bufcurrent[] = "ffff ffff ffff ffff";
+#endif
+
+	if (method != DHCP6_AUTHRDM_MONOCOUNTER) {
+		bb_error_msg("unsupported replay detection "
+		    "method (%d)", method);
+		return (-1);
+	}
+
+	log1("previous: %s, current: %s",
+	    sprint_uint64(bufprev, sizeof(bufprev), prev),
+	    sprint_uint64(bufcurrent, sizeof(bufcurrent), current));
+
+	prev = ntohq(prev);
+	current = ntohq(current);
+
+	/*
+	 * we call the singular point guilty, since we cannot guess
+	 * whether the serial number is increasing or not.
+	 */
+        if (prev == (current ^ 0x8000000000000000ULL)) {
+		bb_info_msg("detected a singular point");
+		return (1);
+	}
+
+	return (((int64_t)(current - prev) > 0) ? 0 : 1);
+}
+
+int getifaddr(struct in6_addr *addr, char *ifnam,
+	      const struct in6_addr *prefix, int plen,
+	      int strong /* if strong host model is required or not */)
+{
+	struct ifaddrs *ifap, *ifa;
+	struct sockaddr_in6 sin6;
+	int error = -1;
+
+	if (getifaddrs(&ifap) != 0) {
+		bb_error_msg("getifaddrs failed: %s", strerror(errno));
+		return (-1);
+	}
+
+	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+		int s1, s2;
+
+		if (strong && strcmp(ifnam, ifa->ifa_name) != 0)
+			continue;
+
+		/* in any case, ignore interfaces in different scope zones. */
+		if ((s1 = in6_addrscopebyif(prefix, ifnam)) < 0 ||
+		    (s2 = in6_addrscopebyif(prefix, ifa->ifa_name)) < 0 ||
+		     s1 != s2)
+			continue;
+
+		if (ifa->ifa_addr->sa_family != AF_INET6)
+			continue;
+#ifdef HAVE_SA_LEN
+		if (ifa->ifa_addr->sa_len > sizeof(sin6))
+			continue;
+#endif
+
+		memcpy(&sin6, ifa->ifa_addr, sysdep_sa_len(ifa->ifa_addr));
+#ifdef __KAME__
+		if (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr)) {
+			sin6.sin6_addr.s6_addr[2] = 0;
+			sin6.sin6_addr.s6_addr[3] = 0;
+		}
+#endif
+		if (plen % 8 == 0) {
+			if (memcmp(&sin6.sin6_addr, prefix, plen / 8) != 0)
+				continue;
+		} else {
+			struct in6_addr a, m;
+			int i;
+
+			memcpy(&a, &sin6.sin6_addr, sizeof(sin6.sin6_addr));
+			memset(&m, 0, sizeof(m));
+			memset(&m, 0xff, plen / 8);
+			m.s6_addr[plen / 8] = (0xff00 >> (plen % 8)) & 0xff;
+			for (i = 0; i < sizeof(a); i++)
+				a.s6_addr[i] &= m.s6_addr[i];
+
+			if (memcmp(&a, prefix, plen / 8) != 0 ||
+			    a.s6_addr[plen / 8] !=
+			    (prefix->s6_addr[plen / 8] & m.s6_addr[plen / 8]))
+				continue;
+		}
+		memcpy(addr, &sin6.sin6_addr, sizeof(sin6.sin6_addr));
+#ifdef __KAME__
+		if (IN6_IS_ADDR_LINKLOCAL(addr))
+			addr->s6_addr[2] = addr->s6_addr[3] = 0; 
+#endif
+		error = 0;
+		break;
+	}
+
+	freeifaddrs(ifap);
+	return (error);
+}
+
+int getifidfromaddr(struct in6_addr *addr, unsigned int *ifidp)
+{
+	struct ifaddrs *ifap, *ifa;
+	struct sockaddr_in6 *sa6;
+	unsigned int ifid;
+	int retval = -1;
+
+	if (getifaddrs(&ifap) != 0) {
+		bb_error_msg("getifaddrs failed: %s", strerror(errno));
+		return (-1);
+	}
+
+	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+		if (ifa->ifa_addr->sa_family != AF_INET6)
+			continue;
+
+		sa6 = (struct sockaddr_in6 *)ifa->ifa_addr;
+		if (IN6_ARE_ADDR_EQUAL(addr, &sa6->sin6_addr))
+			break;
+	}
+
+	if (ifa != NULL) {
+		if ((ifid = if_nametoindex(ifa->ifa_name)) == 0) {
+			bb_error_msg("if_nametoindex failed for %s", ifa->ifa_name);
+			goto end;
+		}
+		retval = 0;
+		*ifidp = ifid;
+	}
+
+  end:
+	freeifaddrs(ifap);
+	return (retval);
+}
+
+int in6_addrscopebyif(const struct in6_addr *addr, const char *ifnam)
+{
+	unsigned ifindex;
+
+	if ((ifindex = if_nametoindex(ifnam)) == 0)
+		return (-1);
+
+	if (IN6_IS_ADDR_LINKLOCAL(addr) || IN6_IS_ADDR_MC_LINKLOCAL(addr))
+		return (ifindex);
+
+	if (IN6_IS_ADDR_SITELOCAL(addr) || IN6_IS_ADDR_MC_SITELOCAL(addr))
+		return (1);	/* XXX */
+
+	if (IN6_IS_ADDR_MC_ORGLOCAL(addr))
+		return (1);	/* XXX */
+
+	return (1);		/* treat it as global */
+}
+
+int prefix6_mask(struct in6_addr *in6, int plen)
+{
+	struct sockaddr_in6 mask6;
+	int i;
+
+	if (sa6_plen2mask(&mask6, plen))
+		return (-1);
+
+	for (i = 0; i < 16; i++)
+		in6->s6_addr[i] &= mask6.sin6_addr.s6_addr[i];
+
+	return (0);
+}
+
+static int sa6_plen2mask(struct sockaddr_in6 *sa6, int plen)
+{
+	u_char *cp;
+
+	if (plen < 0 || plen > 128)
+		return (-1);
+
+	memset(sa6, 0, sizeof(*sa6));
+	sa6->sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+	sa6->sin6_len = sizeof(*sa6);
+#endif
+
+	for (cp = (u_char *)&sa6->sin6_addr; plen > 7; plen -= 8)
+		*cp++ = 0xff;
+	*cp = 0xff << (8 - plen);
+
+	return (0);
+}
+
+char *in6addr2str(struct in6_addr *in6, int scopeid)
+{
+	struct sockaddr_in6 sa6;
+
+	memset(&sa6, 0, sizeof(sa6));
+	sa6.sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+	sa6.sin6_len = sizeof(sa6);
+#endif
+	sa6.sin6_addr = *in6;
+	sa6.sin6_scope_id = scopeid;
+
+	return (xmalloc_sockaddr2dotted_noport((struct sockaddr *)&sa6));
+}
+
+/* return IPv6 address scope type. caller assumes that smaller is narrower. */
+int in6_scope(struct in6_addr *addr)
+{
+	if (addr->s6_addr[0] == 0xfe) {
+		int scope = addr->s6_addr[1] & 0xc0;
+
+		switch (scope) {
+		case 0x80:
+			return (2); /* link-local */
+			break;
+		case 0xc0:
+			return (5); /* site-local */
+			break;
+		default:
+			return (14); /* global: just in case */
+			break;
+		}
+	}
+
+	/* multicast scope. just return the scope field */
+	if (addr->s6_addr[0] == 0xff)
+		return (addr->s6_addr[1] & 0x0f);
+
+	if (memcmp(&in6addr_loopback, addr, sizeof(addr) - 1) == 0) {
+		if (addr->s6_addr[15] == 1) /* loopback */
+			return (1);
+		if (addr->s6_addr[15] == 0) /* unspecified */
+			return (0); /* XXX: good value? */
+	}
+
+	return (14);		/* global */
+}
+
+int get_duid(const char *idfile, struct duid *duid, int duid_type)
+{
+	FILE *fp = NULL;
+	uint16_t len = 0, hwtype = 1;
+	int hwlen = 0;
+	char tmpbuf[128];	/* HWID should be no more than 128 bytes */
+
+	if ((fp = fopen(idfile, "r")) == NULL && errno != ENOENT)
+		bb_info_msg("failed to open DUID file: %s", idfile);
+
+	memset(duid, 0, sizeof(*duid));
+	if (fp) {
+		/* decode length */
+		if (fread(&len, sizeof(len), 1, fp) != 1) {
+			bb_error_msg("DUID file corrupted");
+			goto fail;
+		}
+		duid->duid_len = len;
+	} else {
+		if ((hwlen = gethwid(tmpbuf, sizeof(tmpbuf), NULL, &hwtype)) < 0) {
+			bb_info_msg("failed to get a hardware address");
+			goto fail;
+		}
+		len = hwlen + sizeof(union dhcp6opt_duid_type);
+	}
+
+	duid->duid_id = (char *)xmalloc(len);
+
+	/* copy (and fill) the ID */
+	if (fp) {
+		if (fread(duid->duid_id, len, 1, fp) != 1) {
+			bb_error_msg("DUID file corrupted");
+			goto fail;
+		}
+
+		log1("extracted an existing DUID from %s: %s",
+		    idfile, duidstr(duid));
+	} else {
+		/* we only support the types 1,3 DUID */
+		switch (duid_type) {
+			case 1: {
+				uint64_t t64;
+				struct dhcp6opt_duid_type1 *dp;
+
+				duid->duid_len = hwlen + sizeof(struct dhcp6opt_duid_type1);
+				dp = (struct dhcp6opt_duid_type1 *)duid->duid_id;
+				dp->dh6_duid1_type = htons(1); /* type 1 */
+				dp->dh6_duid1_hwtype = htons(hwtype);
+				/* time is Jan 1, 2000 (UTC), modulo 2^32 */
+				t64 = (uint64_t)(time(NULL) - 946684800);
+				dp->dh6_duid1_time = htonl((u_long)(t64 & 0xffffffff));
+				memcpy((void *)(dp + 1), tmpbuf, hwlen);
+				break;
+				}
+			case 3: {
+				struct dhcp6opt_duid_type3 *dp;
+
+				duid->duid_len = hwlen + sizeof(struct dhcp6opt_duid_type3);
+				dp = (struct dhcp6opt_duid_type3 *)duid->duid_id;
+				dp->dh6_duid3_type = htons(3); /* type 3 */
+				dp->dh6_duid3_hwtype = htons(hwtype);
+				memcpy((void *)(dp + 1), tmpbuf, hwlen);
+				break;
+				}
+		}
+
+		log1("generated a new DUID: %s",
+		    duidstr(duid));
+	}
+
+	/* save the (new) ID to the file for next time */
+	if (!fp) {
+		if ((fp = fopen(idfile, "w+")) == NULL) {
+			bb_error_msg("failed to write DUID file");
+			goto fail;
+		}
+		len = duid->duid_len;
+		if ((fwrite(&len, sizeof(len), 1, fp)) != 1) {
+			bb_error_msg("failed to write DUID file");
+			goto fail;
+		}
+		if ((fwrite(duid->duid_id, len, 1, fp)) != 1) {
+			bb_error_msg("failed to write DUID file");
+			goto fail;
+		}
+
+		log1("saved generated DUID to %s", idfile);
+	}
+
+	if (fp)
+		fclose(fp);
+	return (0);
+
+  fail:
+	if (fp)
+		fclose(fp);
+	duidfree(duid);
+	return (-1);
+}
+
+void dhcp6_init_options(struct dhcp6_optinfo *optinfo)
+{
+	memset(optinfo, 0, sizeof(*optinfo));
+
+	optinfo->pref = DH6OPT_PREF_UNDEF;
+	optinfo->elapsed_time = DH6OPT_ELAPSED_TIME_UNDEF;
+	optinfo->refreshtime = DH6OPT_REFRESHTIME_UNDEF;
+
+	TAILQ_INIT(&optinfo->iapd_list);
+	TAILQ_INIT(&optinfo->iana_list);
+	TAILQ_INIT(&optinfo->reqopt_list);
+	TAILQ_INIT(&optinfo->stcode_list);
+	TAILQ_INIT(&optinfo->sip_list);
+	TAILQ_INIT(&optinfo->sipname_list);
+	TAILQ_INIT(&optinfo->dns_list);
+	TAILQ_INIT(&optinfo->dnsname_list);
+	TAILQ_INIT(&optinfo->ntp_list);
+	TAILQ_INIT(&optinfo->prefix_list);
+	TAILQ_INIT(&optinfo->nis_list);
+	TAILQ_INIT(&optinfo->nisname_list);
+	TAILQ_INIT(&optinfo->nisp_list);
+	TAILQ_INIT(&optinfo->nispname_list);
+	TAILQ_INIT(&optinfo->bcmcs_list);
+	TAILQ_INIT(&optinfo->bcmcsname_list);
+
+	optinfo->authproto = DHCP6_AUTHPROTO_UNDEF;
+	optinfo->authalgorithm = DHCP6_AUTHALG_UNDEF;
+	optinfo->authrdm = DHCP6_AUTHRDM_UNDEF;
+}
+
+void dhcp6_clear_options(struct dhcp6_optinfo *optinfo)
+{
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		if (optinfo->delayedauth_realmval != NULL) {
+			free(optinfo->delayedauth_realmval);
+		}
+		break;
+	}
+
+	duidfree(&optinfo->clientID);
+	duidfree(&optinfo->serverID);
+
+	dhcp6_clear_list(&optinfo->iapd_list);
+	dhcp6_clear_list(&optinfo->iana_list);
+	dhcp6_clear_list(&optinfo->reqopt_list);
+	dhcp6_clear_list(&optinfo->stcode_list);
+	dhcp6_clear_list(&optinfo->sip_list);
+	dhcp6_clear_list(&optinfo->sipname_list);
+	dhcp6_clear_list(&optinfo->dns_list);
+	dhcp6_clear_list(&optinfo->dnsname_list);
+	dhcp6_clear_list(&optinfo->ntp_list);
+	dhcp6_clear_list(&optinfo->prefix_list);
+	dhcp6_clear_list(&optinfo->nis_list);
+	dhcp6_clear_list(&optinfo->nisname_list);
+	dhcp6_clear_list(&optinfo->nisp_list);
+	dhcp6_clear_list(&optinfo->nispname_list);
+	dhcp6_clear_list(&optinfo->bcmcs_list);
+	dhcp6_clear_list(&optinfo->bcmcsname_list);
+
+	if (optinfo->relaymsg_msg != NULL)
+		free(optinfo->relaymsg_msg);
+
+	if (optinfo->ifidopt_id != NULL)
+		free(optinfo->ifidopt_id);
+
+	dhcp6_init_options(optinfo);
+}
+
+int dhcp6_copy_options(struct dhcp6_optinfo *dst, struct dhcp6_optinfo *src)
+{
+	if (duidcpy(&dst->clientID, &src->clientID))
+		goto fail;
+	if (duidcpy(&dst->serverID, &src->serverID))
+		goto fail;
+	dst->rapidcommit = src->rapidcommit;
+
+	if (dhcp6_copy_list(&dst->iapd_list, &src->iapd_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->iana_list, &src->iana_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->reqopt_list, &src->reqopt_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->stcode_list, &src->stcode_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->sip_list, &src->sip_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->sipname_list, &src->sipname_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->dns_list, &src->dns_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->dnsname_list, &src->dnsname_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->ntp_list, &src->ntp_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->prefix_list, &src->prefix_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->nis_list, &src->nis_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->nisname_list, &src->nisname_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->nisp_list, &src->nisp_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->nispname_list, &src->nispname_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->bcmcs_list, &src->bcmcs_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->bcmcsname_list, &src->bcmcsname_list))
+		goto fail;
+	dst->elapsed_time = src->elapsed_time;
+	dst->refreshtime = src->refreshtime;
+	dst->pref = src->pref;
+
+	if (src->relaymsg_msg != NULL) {
+		dst->relaymsg_msg = xmalloc(src->relaymsg_len);
+		dst->relaymsg_len = src->relaymsg_len;
+		memcpy(dst->relaymsg_msg, src->relaymsg_msg,
+		    src->relaymsg_len);
+	}
+
+	if (src->ifidopt_id != NULL) {
+		dst->ifidopt_id = xmalloc(src->ifidopt_len);
+		dst->ifidopt_len = src->ifidopt_len;
+		memcpy(dst->ifidopt_id, src->ifidopt_id, src->ifidopt_len);
+	}
+
+	dst->authflags = src->authflags;
+	dst->authproto = src->authproto;
+	dst->authalgorithm = src->authalgorithm;
+	dst->authrdm = src->authrdm;
+	dst->authrd = src->authrd;
+
+	switch (src->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		dst->delayedauth_keyid = src->delayedauth_keyid;
+		dst->delayedauth_offset = src->delayedauth_offset;
+		dst->delayedauth_realmlen = src->delayedauth_realmlen;
+		if (src->delayedauth_realmval != NULL) {
+			if ((dst->delayedauth_realmval =
+			    malloc_or_warn(src->delayedauth_realmlen)) == NULL) {
+				goto fail;
+			}
+			memcpy(dst->delayedauth_realmval,
+			    src->delayedauth_realmval,
+			    src->delayedauth_realmlen);
+		}
+		break;
+#ifdef notyet
+	case DHCP6_AUTHPROTO_RECONFIG:
+		dst->reconfigauth_type = src->reconfigauth_type;
+		dst->reconfigauth_offset = src->reconfigauth_offset;
+		memcpy(dst->reconfigauth_val, src->reconfigauth_val,
+		    sizeof(dst->reconfigauth_val));
+		break;
+#endif
+	}
+
+	return (0);
+
+  fail:
+	/* cleanup temporary resources */
+	dhcp6_clear_options(dst);
+	return (-1);
+}
+
+int dhcp6_get_options(struct dhcp6opt *p, struct dhcp6opt *ep,
+			struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6opt *np, opth;
+	int i, opt, optlen, reqopts, num;
+	uint16_t num16;
+	char *bp, *cp, *val;
+	uint16_t val16;
+	uint32_t val32;
+	struct dhcp6opt_ia optia;
+	struct dhcp6_ia ia;
+	struct dhcp6_list sublist;
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
+	int authinfolen;
+#endif
+
+	bp = (char *)p;
+	for (; p + 1 <= ep; p = np) {
+		struct duid duid0;
+
+		/*
+		 * get the option header.  XXX: since there is no guarantee
+		 * about the header alignment, we need to make a local copy.
+		 */
+		memcpy(&opth, p, sizeof(opth));
+		optlen = ntohs(opth.dh6opt_len);
+		opt = ntohs(opth.dh6opt_type);
+
+		cp = (char *)(p + 1);
+		np = (struct dhcp6opt *)(cp + optlen);
+
+		log2("get DHCP option %s, len %d", dhcp6optstr(opt), optlen);
+
+		/* option length field overrun */
+		if (np > ep)
+			goto malformed;
+
+		switch (opt) {
+		case DH6OPT_CLIENTID:
+			if (optlen == 0)
+				goto malformed;
+			duid0.duid_len = optlen;
+			duid0.duid_id = cp;
+			log1("  DUID: %s", duidstr(&duid0));
+			if (duidcpy(&optinfo->clientID, &duid0))
+				goto fail;
+			break;
+		case DH6OPT_SERVERID:
+			if (optlen == 0)
+				goto malformed;
+			duid0.duid_len = optlen;
+			duid0.duid_id = cp;
+			log2("  DUID: %s", duidstr(&duid0));
+			if (duidcpy(&optinfo->serverID, &duid0))
+				goto fail;
+			break;
+		case DH6OPT_STATUS_CODE:
+			if (optlen < sizeof(uint16_t))
+				goto malformed;
+			memcpy(&val16, cp, sizeof(val16));
+			num16 = ntohs(val16);
+			log2("  status code: %s",
+			    dhcp6_stcodestr(num16));
+
+			/* need to check duplication? */
+
+			if (dhcp6_add_listval(&optinfo->stcode_list,
+			    DHCP6_LISTVAL_STCODE, &num16, NULL) == NULL) {
+				bb_error_msg("failed to copy status code");
+				goto fail;
+			}
+
+			break;
+		case DH6OPT_ORO:
+			if ((optlen % 2) != 0 || optlen == 0)
+				goto malformed;
+			reqopts = optlen / 2;
+			for (i = 0, val = cp; i < reqopts;
+			     i++, val += sizeof(uint16_t)) {
+				uint16_t opttype;
+
+				memcpy(&opttype, val, sizeof(uint16_t));
+				num = (int)ntohs(opttype);
+
+				log2("  requested option: %s",
+					dhcp6optstr(num));
+
+				if (dhcp6_find_listval(&optinfo->reqopt_list,
+				    DHCP6_LISTVAL_NUM, &num, 0)) {
+					bb_info_msg("duplicated "
+					    "option type (%s)",
+					    dhcp6optstr(opttype));
+					goto nextoption;
+				}
+
+				if (dhcp6_add_listval(&optinfo->reqopt_list,
+				    DHCP6_LISTVAL_NUM, &num, NULL) == NULL) {
+					bb_error_msg("failed to copy requested option");
+					goto fail;
+				}
+			  nextoption:
+				;
+			}
+			break;
+		case DH6OPT_PREFERENCE:
+			if (optlen != 1)
+				goto malformed;
+			log2("  preference: %d", (int)*(u_char *)cp);
+			if (optinfo->pref != DH6OPT_PREF_UNDEF) {
+				bb_info_msg("duplicated preference option");
+			} else
+				optinfo->pref = (int)*(u_char *)cp;
+			break;
+		case DH6OPT_ELAPSED_TIME:
+			if (optlen != 2)
+				goto malformed;
+			memcpy(&val16, cp, sizeof(val16));
+			val16 = ntohs(val16);
+			log2("  elapsed time: %u", (uint32_t)val16);
+			if (optinfo->elapsed_time !=
+			    DH6OPT_ELAPSED_TIME_UNDEF) {
+				bb_info_msg("duplicated elapsed time option");
+			} else
+				optinfo->elapsed_time = val16;
+			break;
+		case DH6OPT_RELAY_MSG:
+			optinfo->relaymsg_msg = xmalloc(optlen);
+			memcpy(optinfo->relaymsg_msg, cp, optlen);
+			optinfo->relaymsg_len = optlen;
+			break;
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
+		case DH6OPT_AUTH:
+			if (optlen < sizeof(struct dhcp6opt_auth) - 4)
+				goto malformed;
+
+			/*
+			 * Any DHCP message that includes more than one
+			 * authentication option MUST be discarded.
+			 * [RFC3315 Section 21.4.2]
+			 */
+			if (optinfo->authproto != DHCP6_AUTHPROTO_UNDEF) {
+				bb_info_msg("found more than one "
+				    "authentication option");
+				goto fail;
+			}
+
+			optinfo->authproto = *cp++;
+			optinfo->authalgorithm = *cp++;
+			optinfo->authrdm = *cp++;
+			memcpy(&optinfo->authrd, cp, sizeof(optinfo->authrd));
+			cp += sizeof(optinfo->authrd);
+
+			log2("  %s", sprint_auth(optinfo));
+
+			authinfolen =
+			    optlen - (sizeof(struct dhcp6opt_auth) - 4);
+			switch (optinfo->authproto) {
+			case DHCP6_AUTHPROTO_DELAYED:
+				if (authinfolen == 0) {
+					optinfo->authflags |=
+					    DHCP6OPT_AUTHFLAG_NOINFO;
+					break;
+				}
+				/* XXX: should we reject an empty realm? */
+				if (authinfolen <
+				    sizeof(optinfo->delayedauth_keyid) + 16) {
+					goto malformed;
+				}
+
+				optinfo->delayedauth_realmlen = authinfolen -
+				    (sizeof(optinfo->delayedauth_keyid) + 16);
+				optinfo->delayedauth_realmval =
+				    malloc_or_warn(optinfo->delayedauth_realmlen);
+				if (optinfo->delayedauth_realmval == NULL)
+					goto fail;
+				memcpy(optinfo->delayedauth_realmval, cp,
+				    optinfo->delayedauth_realmlen);
+				cp += optinfo->delayedauth_realmlen;
+
+				memcpy(&optinfo->delayedauth_keyid, cp,
+				    sizeof(optinfo->delayedauth_keyid));
+				optinfo->delayedauth_keyid =
+				    ntohl(optinfo->delayedauth_keyid);
+				cp += sizeof(optinfo->delayedauth_keyid);
+
+				optinfo->delayedauth_offset = cp - bp;
+				cp += 16;
+
+				log2("  auth key ID: %x, "
+				    "offset=%d, realmlen=%d",
+				    optinfo->delayedauth_keyid,
+				    optinfo->delayedauth_offset,
+				    optinfo->delayedauth_realmlen);
+				break;
+#ifdef notyet
+			case DHCP6_AUTHPROTO_RECONFIG:
+				break;
+#endif
+			default:
+				bb_info_msg("unsupported authentication protocol: %d",
+				    *cp);
+				goto fail;
+			}
+			break;
+#endif /* ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY */
+		case DH6OPT_RAPID_COMMIT:
+			if (optlen != 0)
+				goto malformed;
+			optinfo->rapidcommit = 1;
+			break;
+		case DH6OPT_INTERFACE_ID:
+			optinfo->ifidopt_id = xmalloc(optlen);
+			memcpy(optinfo->ifidopt_id, cp, optlen);
+			optinfo->ifidopt_len = optlen;
+			break;
+		case DH6OPT_SIP_SERVER_D:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->sipname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_DNSNAME:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->dnsname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NIS_DOMAIN_NAME:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->nisname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NISP_DOMAIN_NAME:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->nispname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_BCMCS_SERVER_D:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->bcmcsname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_SIP_SERVER_A:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->sip_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_DNS:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->dns_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NIS_SERVERS:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->nis_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NISP_SERVERS:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->nisp_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_BCMCS_SERVER_A:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->bcmcs_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NTP:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->ntp_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_IA_PD:
+			if (optlen + sizeof(struct dhcp6opt) <
+			    sizeof(optia))
+				goto malformed;
+			memcpy(&optia, p, sizeof(optia));
+			ia.iaid = ntohl(optia.dh6_ia_iaid);
+			ia.t1 = ntohl(optia.dh6_ia_t1);
+			ia.t2 = ntohl(optia.dh6_ia_t2);
+
+			log2("  IA_PD: ID=%u, T1=%u, T2=%u",
+			    ia.iaid, ia.t1, ia.t2);
+
+			/* duplication check */
+			if (dhcp6_find_listval(&optinfo->iapd_list,
+			    DHCP6_LISTVAL_IAPD, &ia, 0)) {
+				bb_info_msg("duplicated IA_PD %u", ia.iaid);
+				break; /* ignore this IA_PD */
+			}
+
+			/* take care of sub-options */
+			TAILQ_INIT(&sublist);
+			if (copyin_option(opt,
+			    (struct dhcp6opt *)((char *)p + sizeof(optia)),
+			    (struct dhcp6opt *)(cp + optlen), &sublist)) {
+				goto fail;
+			}
+
+			/* link this option set */
+			if (dhcp6_add_listval(&optinfo->iapd_list,
+			    DHCP6_LISTVAL_IAPD, &ia, &sublist) == NULL) {
+				dhcp6_clear_list(&sublist);
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+
+			break;
+		case DH6OPT_REFRESHTIME:
+			if (optlen != 4)
+				goto malformed;
+			memcpy(&val32, cp, sizeof(val32));
+			val32 = ntohl(val32);
+			log2("   information refresh time: %u", val32);
+			if (val32 < DHCP6_IRT_MINIMUM) {
+				/*
+				 * A client MUST use the refresh time
+				 * IRT_MINIMUM if it receives the option with a
+				 * value less than IRT_MINIMUM.
+				 * [draft-ietf-dhc-lifetime-02.txt,
+				 *  Section 3.2]
+				 */
+				bb_info_msg(
+				    "refresh time is too small (%d), adjusted",
+				    val32);
+				val32 = DHCP6_IRT_MINIMUM;
+			}
+			if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
+				bb_info_msg("duplicated refresh time option");
+			} else
+				optinfo->refreshtime = (int64_t)val32;
+			break;
+		case DH6OPT_IA_NA:
+			if (optlen + sizeof(struct dhcp6opt) <
+			    sizeof(optia))
+				goto malformed;
+			memcpy(&optia, p, sizeof(optia));
+			ia.iaid = ntohl(optia.dh6_ia_iaid);
+			ia.t1 = ntohl(optia.dh6_ia_t1);
+			ia.t2 = ntohl(optia.dh6_ia_t2);
+
+			log2("  IA_NA: ID=%u, T1=%u, T2=%u",
+			    ia.iaid, ia.t1, ia.t2);
+
+			/* duplication check */
+			if (dhcp6_find_listval(&optinfo->iana_list,
+			    DHCP6_LISTVAL_IANA, &ia, 0)) {
+				bb_info_msg("duplicated IA_NA %u", ia.iaid);
+				break; /* ignore this IA_NA */
+			}
+
+			/* take care of sub-options */
+			TAILQ_INIT(&sublist);
+			if (copyin_option(opt,
+			    (struct dhcp6opt *)((char *)p + sizeof(optia)),
+			    (struct dhcp6opt *)(cp + optlen), &sublist)) {
+				goto fail;
+			}
+
+			/* link this option set */
+			if (dhcp6_add_listval(&optinfo->iana_list,
+			    DHCP6_LISTVAL_IANA, &ia, &sublist) == NULL) {
+				dhcp6_clear_list(&sublist);
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+
+			break;
+		default:
+			/* no option specific behavior */
+			bb_info_msg("unexpected DHCP6 option %s, len %d",
+			    dhcp6optstr(opt), optlen);
+			break;
+		}
+	}
+
+	return (0);
+
+  malformed:
+	bb_error_msg("malformed DHCP option: type %d, len %d", opt, optlen);
+  fail:
+	dhcp6_clear_options(optinfo);
+	return (-1);
+}
+
+static char *dnsdecode(u_char **sp, u_char *ep, char *buf, size_t bufsiz)
+{
+	int i, l, len;
+	u_char *cp;
+	char tmpbuf[MAXDNAME + 1];
+
+	cp = *sp;
+	*buf = '\0';
+	i = 0;			/* XXX: appease gcc */
+
+	if (cp >= ep)
+		return (NULL);
+	len = 0;
+	while (cp < ep) {
+		i = *cp;
+		if (i == 0 || cp != *sp) {
+			len++;
+			if (len >= bufsiz)
+				return (NULL);	/* result overrun */
+			strcat(buf, ".");
+		}
+		if (i == 0)
+			break;
+		cp++;
+
+		if (i > 0x3f)
+			return (NULL); /* invalid label */
+
+		if (i > ep - cp)
+			return (NULL); /* source overrun */
+		while (i-- > 0 && cp < ep) {
+			if (!isprint_asciionly(*cp)) /* we don't accept non-printables */
+				return (NULL);
+			l = snprintf(tmpbuf, sizeof(tmpbuf), "%c" , *cp);
+			if (l >= sizeof(tmpbuf) || l < 0)
+				return (NULL);
+			len += l;
+			if (len >= bufsiz)
+				return (NULL); /* result overrun */
+			strcat(buf, tmpbuf);
+			cp++;
+		}
+	}
+	if (i != 0)
+		return (NULL);	/* not terminated */
+	cp++;
+	*sp = cp;
+	return (buf);
+}
+
+static int copyin_option(int type, struct dhcp6opt *p, struct dhcp6opt *ep,
+			 struct dhcp6_list *list)
+{
+	int opt, optlen;
+	char *cp;
+	struct dhcp6opt *np, opth;
+	struct dhcp6opt_stcode opt_stcode;
+	struct dhcp6opt_ia_pd_prefix opt_iapd_prefix;
+	struct dhcp6_prefix iapd_prefix;
+	struct dhcp6opt_ia_addr opt_ia_addr;
+	struct dhcp6_prefix ia_addr;
+	struct dhcp6_list sublist;
+
+	TAILQ_INIT(&sublist);
+
+	for (; p + 1 <= ep; p = np) {
+		memcpy(&opth, p, sizeof(opth));
+		optlen = ntohs(opth.dh6opt_len);
+		opt = ntohs(opth.dh6opt_type);
+
+		cp = (char *)(p + 1);
+		np = (struct dhcp6opt *)(cp + optlen);
+
+		log2("get DHCP option %s, len %d", dhcp6optstr(opt), optlen);
+
+		if (np > ep)
+			goto malformed;
+
+		switch (opt) {
+		case DH6OPT_IA_PD_PREFIX:
+			/* check option context */
+			if (type != DH6OPT_IA_PD) {
+				bb_info_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto fail;
+			}
+			/* check option length */
+			if (optlen + sizeof(opth) < sizeof(opt_iapd_prefix))
+				goto malformed;
+
+			/* copy and convert option values */
+			memcpy(&opt_iapd_prefix, p, sizeof(opt_iapd_prefix));
+			if (opt_iapd_prefix.dh6_iapd_prefix_prefix_len > 128) {
+				bb_info_msg("invalid prefix length (%d)",
+				    opt_iapd_prefix.dh6_iapd_prefix_prefix_len);
+				goto malformed;
+			}
+			iapd_prefix.pltime = ntohl(opt_iapd_prefix.dh6_iapd_prefix_preferred_time);
+			iapd_prefix.vltime = ntohl(opt_iapd_prefix.dh6_iapd_prefix_valid_time);
+			iapd_prefix.plen =  opt_iapd_prefix.dh6_iapd_prefix_prefix_len;
+			memcpy(&iapd_prefix.addr,
+			    &opt_iapd_prefix.dh6_iapd_prefix_prefix_addr,
+			    sizeof(iapd_prefix.addr));
+			/* clear padding bits in the prefix address */
+			prefix6_mask(&iapd_prefix.addr, iapd_prefix.plen);
+
+			log2("  IA_PD prefix: %s/%d pltime=%u vltime=%u",
+			    in6addr2str(&iapd_prefix.addr, 0),
+			    iapd_prefix.plen,
+			    iapd_prefix.pltime, iapd_prefix.vltime);
+
+			if (dhcp6_find_listval(list, DHCP6_LISTVAL_PREFIX6,
+			    &iapd_prefix, 0)) {
+				char *a = in6addr2str(&iapd_prefix.addr, 0);
+				bb_info_msg("duplicated IA_PD prefix %s/%d",
+				    a, iapd_prefix.plen );
+				free(p);
+				goto nextoption;
+			}
+
+			/* take care of sub-options */
+			TAILQ_INIT(&sublist);
+			if (copyin_option(opt,
+			    (struct dhcp6opt *)((char *)p +
+			    sizeof(opt_iapd_prefix)), np, &sublist)) {
+				goto fail;
+			}
+
+			if (dhcp6_add_listval(list, DHCP6_LISTVAL_PREFIX6,
+			    &iapd_prefix, &sublist) == NULL) {
+				dhcp6_clear_list(&sublist);
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+			break;
+		case DH6OPT_IAADDR:
+			/* check option context */
+			if (type != DH6OPT_IA_NA) {
+				bb_info_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto fail;
+			}
+			/* check option length */
+			if (optlen + sizeof(opth) < sizeof(opt_ia_addr))
+				goto malformed;
+
+			/* copy and convert option values */
+			memcpy(&opt_ia_addr, p, sizeof(opt_ia_addr));
+			ia_addr.pltime = ntohl(opt_ia_addr.dh6_ia_addr_preferred_time);
+			ia_addr.vltime = ntohl(opt_ia_addr.dh6_ia_addr_valid_time);
+			memcpy(&ia_addr.addr, &opt_ia_addr.dh6_ia_addr_addr,
+			    sizeof(ia_addr.addr));
+
+			log2("  IA_NA address: %s pltime=%u vltime=%u",
+			    in6addr2str(&ia_addr.addr, 0),
+			    ia_addr.pltime, ia_addr.vltime);
+
+			if (dhcp6_find_listval(list,
+			    DHCP6_LISTVAL_STATEFULADDR6, &ia_addr, 0)) {
+				char * a = in6addr2str(&ia_addr.addr, 0);
+				bb_info_msg("duplicated IA_NA address %s", a);
+				free(a);
+				goto nextoption;
+			}
+
+			/* take care of sub-options */
+			TAILQ_INIT(&sublist);
+			if (copyin_option(opt,
+			    (struct dhcp6opt *)((char *)p +
+			    sizeof(opt_ia_addr)), np, &sublist)) {
+				goto fail;
+			}
+
+			if (dhcp6_add_listval(list, DHCP6_LISTVAL_STATEFULADDR6,
+			    &ia_addr, &sublist) == NULL) {
+				dhcp6_clear_list(&sublist);
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+			break;
+		case DH6OPT_STATUS_CODE:
+			/* check option context */
+			if (type != DH6OPT_IA_PD &&
+			    type != DH6OPT_IA_PD_PREFIX &&
+			    type != DH6OPT_IA_NA &&
+			    type != DH6OPT_IAADDR) {
+				bb_info_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto nextoption; /* or discard the message? */
+			}
+			/* check option length */
+			if (optlen + sizeof(opth) < sizeof(opt_stcode))
+				goto malformed;
+
+			/* copy and convert option values */
+			memcpy(&opt_stcode, p, sizeof(opt_stcode));
+			opt_stcode.dh6_stcode_code =
+			    ntohs(opt_stcode.dh6_stcode_code);
+
+			log2("  status code: %s",
+			    dhcp6_stcodestr(opt_stcode.dh6_stcode_code));
+
+			/* duplication check */
+			if (dhcp6_find_listval(list, DHCP6_LISTVAL_STCODE,
+			    &opt_stcode.dh6_stcode_code, 0)) {
+				bb_info_msg("duplicated status code (%d)",
+				    opt_stcode.dh6_stcode_code);
+				goto nextoption;
+			}
+
+			/* copy-in the code value */
+			if (dhcp6_add_listval(list, DHCP6_LISTVAL_STCODE,
+			    &opt_stcode.dh6_stcode_code, NULL) == NULL)
+				goto fail;
+
+			break;
+		}
+	  nextoption:
+		;
+	}
+
+	return (0);
+
+  malformed:
+	bb_info_msg("malformed DHCP option: type %d, len %d", opt, optlen);
+
+  fail:
+	dhcp6_clear_list(&sublist);
+	return (-1);
+}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static char *sprint_uint64(char *buf, int buflen, uint64_t i64)
+{
+	uint16_t rd0, rd1, rd2, rd3;
+	uint16_t *ptr = (uint16_t *)(void *)&i64;
+
+	rd0 = ntohs(*ptr++);
+	rd1 = ntohs(*ptr++);
+	rd2 = ntohs(*ptr++);
+	rd3 = ntohs(*ptr);
+
+	snprintf(buf, buflen, "%04x %04x %04x %04x", rd0, rd1, rd2, rd3);
+
+	return (buf);
+}
+
+static char *sprint_auth(struct dhcp6_optinfo *optinfo)
+{
+	static char ret[1024];	/* XXX: thread unsafe */
+	const char *proto, *alg, *rdm;
+	char proto0[16], alg0[16], rdm0[16];
+	char rd[] = "ffff ffff ffff ffff";
+
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		proto = "delayed";
+		break;
+#ifdef notyet
+	case DHCP6_AUTHPROTO_RECONFIG:
+		proto = "reconfig";
+		break;
+#endif
+	default:
+		snprintf(proto0, sizeof(proto0), "unknown(%d)",
+		    optinfo->authproto & 0xff);
+		proto = proto0;
+		break;
+	}
+
+	switch (optinfo->authalgorithm) {
+	case DHCP6_AUTHALG_HMACMD5:
+		alg = "HMAC-MD5";
+		break;
+	default:
+		snprintf(alg0, sizeof(alg0), "unknown(%d)",
+		    optinfo->authalgorithm & 0xff);
+		alg = alg0;
+		break;
+	}
+
+	switch (optinfo->authrdm) {
+	case DHCP6_AUTHRDM_MONOCOUNTER:
+		rdm = "mono counter";
+		break;
+	default:
+		snprintf(rdm0, sizeof(rdm0), "unknown(%d)", optinfo->authrdm);
+		rdm = rdm0;
+	}
+
+	snprintf(ret, sizeof(ret), "proto: %s, alg: %s, RDM: %s, RD: %s",
+	    proto, alg, rdm,
+	    sprint_uint64(rd, sizeof(rd), optinfo->authrd));
+
+	return (ret);
+}
+#endif
+
+static int copy_option(uint16_t type, uint16_t len, void *val,
+		struct dhcp6opt **optp, struct dhcp6opt *ep, int *totallenp)
+{
+	struct dhcp6opt *opt = *optp, opth;
+
+	if ((void *)ep - (void *)optp < len + sizeof(struct dhcp6opt)) {
+		log1("option buffer short for %s", dhcp6optstr(type));
+		return (-1);
+	}
+	opth.dh6opt_type = htons(type);
+	opth.dh6opt_len = htons(len);
+	memcpy(opt, &opth, sizeof(opth));
+	if (len != 0)
+		memcpy(opt + 1, val, len);
+
+	*optp = (struct dhcp6opt *)((char *)(opt + 1) + len);
+ 	*totallenp += sizeof(struct dhcp6opt) + len;
+	log2("set %s (len %d)", dhcp6optstr(type), len);
+
+	return (0);
+}
+
+int dhcp6_set_options(int type, struct dhcp6opt *optbp, struct dhcp6opt *optep,
+		struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6opt *p = optbp;
+	struct dhcp6_listval *stcode, *op;
+	int len = 0, opt_len;
+	char *tmpbuf = NULL;
+
+	if (optinfo->clientID.duid_len) {
+		if (copy_option(DH6OPT_CLIENTID, optinfo->clientID.duid_len,
+		    optinfo->clientID.duid_id, &p, optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->serverID.duid_len) {
+		if (copy_option(DH6OPT_SERVERID, optinfo->serverID.duid_len,
+		    optinfo->serverID.duid_id, &p, optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	for (op = TAILQ_FIRST(&optinfo->iana_list); op;
+	    op = TAILQ_NEXT(op, link)) {
+		int opt_len1;
+
+		tmpbuf = NULL;
+		if ((opt_len1 = copyout_option(NULL, NULL, op)) < 0) {
+			bb_info_msg("failed to count option length");
+			goto fail;
+		}
+		if ((void *)optep - (void *)p < opt_len1) {
+			bb_info_msg("short buffer");
+			goto fail;
+		}
+		tmpbuf = xmalloc(opt_len1);
+		if (copyout_option(tmpbuf, tmpbuf + opt_len1, op) < 0) {
+			bb_error_msg("failed to construct an %s option", "IA_NA");
+			goto fail;
+		}
+		memcpy(p, tmpbuf, opt_len1);
+		free(tmpbuf);
+		tmpbuf = NULL;
+		p = (struct dhcp6opt *)((char *)p + opt_len1);
+		len += opt_len1;
+	}
+
+	if (optinfo->rapidcommit) {
+		if (copy_option(DH6OPT_RAPID_COMMIT, 0, NULL, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->pref != DH6OPT_PREF_UNDEF) {
+		uint8_t p8 = (uint8_t)optinfo->pref;
+
+		if (copy_option(DH6OPT_PREFERENCE, sizeof(p8), &p8, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->elapsed_time != DH6OPT_ELAPSED_TIME_UNDEF) {
+		uint16_t p16 = (uint16_t)optinfo->elapsed_time;
+
+		p16 = htons(p16);
+		if (copy_option(DH6OPT_ELAPSED_TIME, sizeof(p16), &p16, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	for (stcode = TAILQ_FIRST(&optinfo->stcode_list); stcode;
+	     stcode = TAILQ_NEXT(stcode, link)) {
+		uint16_t code;
+
+		code = htons(stcode->val_num16);
+		if (copy_option(DH6OPT_STATUS_CODE, sizeof(code), &code, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (!TAILQ_EMPTY(&optinfo->reqopt_list)) {
+		struct dhcp6_listval *opt;
+		uint16_t *valp;
+		int buflen;
+
+		buflen = dhcp6_count_list(&optinfo->reqopt_list) *
+			sizeof(uint16_t);
+		tmpbuf = xmalloc(buflen);
+		opt_len = 0;
+		valp = (uint16_t *)tmpbuf;
+		for (opt = TAILQ_FIRST(&optinfo->reqopt_list); opt;
+		     opt = TAILQ_NEXT(opt, link)) {
+			/*
+			 * Information request option can only be specified
+			 * in information-request messages.
+			 * [draft-ietf-dhc-lifetime-02.txt, Section 3.2]
+			 */
+			if (opt->val_num == DH6OPT_REFRESHTIME &&
+			    type != DH6_INFORM_REQ) {
+				log1("refresh time option is not requested "
+				    "for %s", dhcp6msgstr(type));
+			}
+
+			*valp = htons((uint16_t)opt->val_num);
+			valp++;
+			opt_len += sizeof(uint16_t);
+		}
+		if (opt_len > 0 &&
+		    copy_option(DH6OPT_ORO, opt_len, tmpbuf, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+		free(tmpbuf);
+		tmpbuf = NULL;
+	}
+
+#if /*ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+	if (dhcp6_set_domain(DH6OPT_SIP_SERVER_D, &optinfo->sipname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_SIP_SERVER_A, &optinfo->sip_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_DNS, &optinfo->dns_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(DH6OPT_DNSNAME, &optinfo->dnsname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_NIS_SERVERS, &optinfo->nis_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_NISP_SERVERS, &optinfo->nisp_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(DH6OPT_NIS_DOMAIN_NAME, &optinfo->nisname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(DH6OPT_NISP_DOMAIN_NAME, &optinfo->nispname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_NTP, &optinfo->ntp_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(DH6OPT_BCMCS_SERVER_D, &optinfo->bcmcsname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_BCMCS_SERVER_A, &optinfo->bcmcs_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+#endif /* DHCP6S || ENABLE_DHCP6RELAY */
+
+	for (op = TAILQ_FIRST(&optinfo->iapd_list); op;
+	    op = TAILQ_NEXT(op, link)) {
+		int opt_len1;
+
+		tmpbuf = NULL;
+		if ((opt_len1 = copyout_option(NULL, NULL, op)) < 0) {
+			bb_info_msg("failed to count option length");
+			goto fail;
+		}
+		if ((void *)optep - (void *)p < opt_len1) {
+			bb_info_msg("short buffer");
+			goto fail;
+		}
+		tmpbuf = xmalloc(opt_len1);
+		if (copyout_option(tmpbuf, tmpbuf + opt_len1, op) < 0) {
+			bb_error_msg("failed to construct an %s option", "IA_PD");
+			goto fail;
+		}
+		memcpy(p, tmpbuf, opt_len1);
+		free(tmpbuf);
+		tmpbuf = NULL;
+		p = (struct dhcp6opt *)((char *)p + opt_len1);
+		len += opt_len1;
+	}
+
+	if (optinfo->relaymsg_len) {
+		if (copy_option(DH6OPT_RELAY_MSG, optinfo->relaymsg_len,
+		    optinfo->relaymsg_msg, &p, optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->ifidopt_id) {
+		if (copy_option(DH6OPT_INTERFACE_ID, optinfo->ifidopt_len,
+		    optinfo->ifidopt_id, &p, optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
+		uint32_t p32 = (uint32_t)optinfo->refreshtime;
+
+		p32 = htonl(p32);
+		if (copy_option(DH6OPT_REFRESHTIME, sizeof(p32), &p32, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
+	if (optinfo->authproto != DHCP6_AUTHPROTO_UNDEF) {
+		struct dhcp6opt_auth *auth;
+		int authlen;
+		char *authinfo;
+
+		authlen = sizeof(*auth);
+		if (!(optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+			switch (optinfo->authproto) {
+			case DHCP6_AUTHPROTO_DELAYED:
+				/* Realm + key ID + HMAC-MD5 */
+				authlen += optinfo->delayedauth_realmlen +
+				    sizeof(optinfo->delayedauth_keyid) + 16;
+				break;
+#ifdef notyet
+			case DHCP6_AUTHPROTO_RECONFIG:
+				/* type + key-or-HAMC */
+				authlen += 17;
+				break;
+#endif
+			default:
+				bb_error_msg("unsupported authentication protocol: %d",
+					    optinfo->authproto);
+				goto fail;
+			}
+		}
+
+		auth = xzalloc(authlen);
+		/* copy_option will take care of type and len later */
+		auth->dh6_auth_proto = (uint8_t)optinfo->authproto;
+		auth->dh6_auth_alg = (uint8_t)optinfo->authalgorithm;
+		auth->dh6_auth_rdm = (uint8_t)optinfo->authrdm;
+		memcpy(auth->dh6_auth_rdinfo, &optinfo->authrd,
+		    sizeof(auth->dh6_auth_rdinfo));
+
+		if (!(optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+			uint32_t p32;
+
+			switch (optinfo->authproto) {
+			case DHCP6_AUTHPROTO_DELAYED:
+				authinfo = (char *)(auth + 1);
+
+				/* copy realm */
+				memcpy(authinfo, optinfo->delayedauth_realmval,
+				    optinfo->delayedauth_realmlen);
+				authinfo += optinfo->delayedauth_realmlen;
+
+				/* copy key ID (need memcpy for alignment) */
+				p32 = htonl(optinfo->delayedauth_keyid);
+				memcpy(authinfo, &p32, sizeof(p32));
+
+				/*
+				 * Set the offset so that the caller can
+				 * calculate the HMAC.
+				 */
+				optinfo->delayedauth_offset =
+				    ((char *)p - (char *)optbp) + authlen - 16;
+
+				log1("key ID %x, offset %d",
+				    optinfo->delayedauth_keyid,
+				    optinfo->delayedauth_offset); 
+				break;
+#ifdef notyet
+			case DHCP6_AUTHPROTO_RECONFIG:
+#endif
+			default:
+				bb_error_msg("unsupported authentication protocol: %d",
+					    optinfo->authproto);
+				free(auth);
+				goto fail;
+			}
+		}
+
+		if (copy_option(DH6OPT_AUTH, authlen - 4,
+		    &auth->dh6_auth_proto, &p, optep, &len) != 0) {
+			goto fail;
+		}
+		free(auth);
+	}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY */
+
+	return (len);
+
+  fail:
+	if (tmpbuf)
+		free(tmpbuf);
+	return (-1);
+}
+
+#if /*ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+static ssize_t dnsencode(const char *name, char *buf, size_t buflen)
+{
+	char *cp, *ep;
+	const char *p, *q;
+	int i;
+	int namelen = strlen(name);
+
+	cp = buf;
+	ep = cp + buflen;
+
+	/* if not certain about my name, return an empty buffer */
+	if (namelen == 0)
+		return (0);
+
+	p = name;
+	while (cp < ep && p < name + namelen) {
+		i = 0;
+		for (q = p; q < name + namelen && *q && *q != '.'; q++)
+			i++;
+		/* result does not fit into buf */
+		if (cp + i + 1 >= ep)
+			goto fail;
+		/*
+		 * DNS label length restriction, RFC1035 page 8.
+		 * "i == 0" case is included here to avoid returning
+		 * 0-length label on "foo..bar".
+		 */
+		if (i <= 0 || i >= 64)
+			goto fail;
+		*cp++ = i;
+		if (!isalpha(p[0]) || !isalnum(p[i - 1]))
+			goto fail;
+		while (i > 0) {
+			if (!isalnum(*p) && *p != '-')
+				goto fail;
+			if (isupper(*p))
+				*cp++ = tolower(*p++);
+			else
+				*cp++ = *p++;
+			i--;
+		}
+		p = q;
+		if (p < name + namelen && *p == '.')
+			p++;
+	}
+	/* termination */
+	if (cp + 1 >= ep)
+		goto fail;
+	*cp++ = '\0';
+	return (cp - buf);
+
+ fail:
+	return (-1);
+}
+#endif
+
+/*
+ * Construct a DHCPv6 option along with sub-options in the wire format.
+ * If the packet buffer is NULL, just calculate the length of the option
+ * (and sub-options) so that the caller can allocate a buffer to store the
+ * option(s).
+ * This function basically assumes that the caller prepares enough buffer to
+ * store all the options.  However, it also takes the buffer end and checks
+ * the possibility of overrun for safety.
+ */
+static int copyout_option(char *p, char *ep, struct dhcp6_listval *optval)
+{
+	union {
+		struct dhcp6opt_stcode stcodeopt;
+		struct dhcp6opt_ia ia;
+		struct dhcp6opt_ia_pd_prefix pd_prefix;
+		struct dhcp6opt_ia_addr ia_addr;
+	} u;
+	struct dhcp6opt *opt = (struct dhcp6opt *)(void *)&u;
+	char *subp;
+	struct dhcp6_listval *subov;
+	int opt_len, headlen, sublen, opttype;
+
+	/* check invariant for safety */
+	if (p && ep <= p)
+		return (-1);
+
+	memset(&u, 0, sizeof(u));
+
+	/* first, detect the length of the option head */
+	switch (optval->type) {
+	case DHCP6_LISTVAL_IAPD:
+		headlen = sizeof(u.ia);
+		opttype = DH6OPT_IA_PD;
+		break;
+	case DHCP6_LISTVAL_IANA:
+		headlen = sizeof(u.ia);
+		opttype = DH6OPT_IA_NA;
+		break;
+	case DHCP6_LISTVAL_ADDR6:
+		headlen = sizeof(u.pd_prefix);
+		opttype = DH6OPT_IA_PD_PREFIX;
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		headlen = sizeof(u.pd_prefix);
+		opttype = DH6OPT_IA_PD_PREFIX;
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		headlen = sizeof(u.ia_addr);
+		opttype = DH6OPT_IAADDR;
+		break;
+	case DHCP6_LISTVAL_STCODE:
+		headlen = sizeof(u.stcodeopt);
+		opttype = DH6OPT_STATUS_CODE;
+		break;
+	default:
+		/*
+		 * we encounter an unknown option.  this should be an internal
+		 * error.
+		 */
+		bb_error_msg("unknown option: code %d", optval->type);
+		return (-1);
+	}
+
+	/* then, calculate the length of and/or fill in the sub-options */
+	subp = NULL;
+	sublen = 0;
+	if (p)
+		subp = p + headlen;
+	for (subov = TAILQ_FIRST(&optval->sublist); subov;
+	    subov = TAILQ_NEXT(subov, link)) {
+		int s;
+
+		if ((s = copyout_option(subp, ep, subov)) < 0)
+			return (-1);
+		if (p)
+			subp += s;
+		sublen += s;
+	}
+
+	/* finally, deal with the head part again */
+	opt_len = headlen + sublen;
+	if (!p)
+		return(opt_len);
+
+	log2("set %s", dhcp6optstr(opttype));
+	if (ep - p < headlen) /* check it just in case */
+		return (-1);
+
+	/* fill in the common part */
+	opt->dh6opt_type = htons(opttype);
+	opt->dh6opt_len = htons(opt_len - sizeof(struct dhcp6opt));
+
+	/* fill in type specific fields */
+	switch (optval->type) {
+	case DHCP6_LISTVAL_IAPD:
+	case DHCP6_LISTVAL_IANA:
+		u.ia.dh6_ia_iaid = htonl(optval->val_ia.iaid);
+		u.ia.dh6_ia_t1 = htonl(optval->val_ia.t1);
+		u.ia.dh6_ia_t2 = htonl(optval->val_ia.t2);
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		u.pd_prefix.dh6_iapd_prefix_preferred_time =
+		    htonl(optval->val_prefix6.pltime);
+		u.pd_prefix.dh6_iapd_prefix_valid_time =
+		    htonl(optval->val_prefix6.vltime);
+		u.pd_prefix.dh6_iapd_prefix_prefix_len =
+		    optval->val_prefix6.plen;
+		/* XXX: prefix_addr is badly aligned, so we need memcpy */
+		memcpy(&u.pd_prefix.dh6_iapd_prefix_prefix_addr,
+		    &optval->val_prefix6.addr, sizeof(struct in6_addr));
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		u.ia_addr.dh6_ia_addr_preferred_time =
+		    htonl(optval->val_statefuladdr6.pltime);
+		u.ia_addr.dh6_ia_addr_valid_time =
+		    htonl(optval->val_statefuladdr6.vltime);
+		u.ia_addr.dh6_ia_addr_addr = optval->val_statefuladdr6.addr;
+		break;
+	case DHCP6_LISTVAL_STCODE:
+		u.stcodeopt.dh6_stcode_code = htons(optval->val_num16);
+		break;
+	default:
+		/*
+		 * XXX: this case should be rejected at the beginning of this
+		 * function.
+		 */
+		return (-1);
+	}
+
+	/* copyout the data (p must be non NULL at this point) */
+	memcpy(p, opt, headlen);
+	return (opt_len);
+}
+
+void dhcp6_set_timeoparam(struct dhcp6_event *ev)
+{
+	ev->retrans = 0;
+	ev->init_retrans = 0;
+	ev->max_retrans_cnt = 0;
+	ev->max_retrans_dur = 0;
+	ev->max_retrans_time = 0;
+
+	switch (ev->state) {
+	case DHCP6S_SOLICIT:
+		ev->init_retrans = SOL_TIMEOUT;
+		ev->max_retrans_time = SOL_MAX_RT;
+		break;
+	case DHCP6S_INFOREQ:
+		ev->init_retrans = INF_TIMEOUT;
+		ev->max_retrans_time = INF_MAX_RT;
+		break;
+	case DHCP6S_REQUEST:
+		ev->init_retrans = REQ_TIMEOUT;
+		ev->max_retrans_time = REQ_MAX_RT;
+		ev->max_retrans_cnt = REQ_MAX_RC;
+		break;
+	case DHCP6S_RENEW:
+		ev->init_retrans = REN_TIMEOUT;
+		ev->max_retrans_time = REN_MAX_RT;
+		break;
+	case DHCP6S_REBIND:
+		ev->init_retrans = REB_TIMEOUT;
+		ev->max_retrans_time = REB_MAX_RT;
+		break;
+	case DHCP6S_RELEASE:
+		ev->init_retrans = REL_TIMEOUT;
+		ev->max_retrans_cnt = REL_MAX_RC;
+		break;
+	default:
+		bb_error_msg_and_die("unexpected event state %d on %s",
+		    ev->state, ev->ifp->ifname);
+	}
+}
+
+void dhcp6_reset_timer(struct dhcp6_event *ev)
+{
+	double n, r;
+
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		/*
+		 * The first Solicit message from the client on the interface
+		 * MUST be delayed by a random amount of time between
+		 * 0 and SOL_MAX_DELAY.
+		 * [RFC3315 17.1.2]
+		 * XXX: a random delay is also necessary before the first
+		 * information-request message.  Fortunately, the parameters
+		 * and the algorithm for these two cases are the same.
+		 * [RFC3315 18.1.5]
+		 */
+		ev->retrans = (random() % (SOL_MAX_DELAY));
+		break;
+	default:
+		if (ev->state == DHCP6S_SOLICIT && ev->timeouts == 0) {
+			/*
+			 * The first RT MUST be selected to be strictly
+			 * greater than IRT by choosing RAND to be strictly
+			 * greater than 0.
+			 * [RFC3315 17.1.2]
+			 */
+			r = (double)((random() % 1000) + 1) / 10000;
+			n = ev->init_retrans + r * ev->init_retrans;
+		} else {
+			r = (double)((random() % 2000) - 1000) / 10000;
+
+			if (ev->timeouts == 0) {
+				n = ev->init_retrans + r * ev->init_retrans;
+			} else
+				n = 2 * ev->retrans + r * ev->retrans;
+		}
+		if (ev->max_retrans_time && n > ev->max_retrans_time)
+			n = ev->max_retrans_time + r * ev->max_retrans_time;
+		ev->retrans = (long)n;
+		break;
+	}
+
+	dhcp6_timer_set(ev->retrans, ev->timer);
+
+	log1("reset a timer on %s, state=%s, timeo=%d, retrans=%ld",
+		ev->ifp->ifname, dhcp6_event_statestr(ev), ev->timeouts, ev->retrans);
+}
+
+int duidcpy(struct duid *dd, struct duid *ds)
+{
+	dd->duid_len = ds->duid_len;
+	if ((dd->duid_id = malloc_or_warn(dd->duid_len)) == NULL) {
+		return (-1);
+	}
+	memcpy(dd->duid_id, ds->duid_id, dd->duid_len);
+
+	return (0);
+}
+
+int ALWAYS_INLINE duidcmp(struct duid *d1, struct duid *d2)
+{
+	if (d1->duid_len == d2->duid_len)
+		return (memcmp(d1->duid_id, d2->duid_id, d1->duid_len));
+	else
+		return (-1);
+}
+
+void duidfree(struct duid *d)
+{
+	if (d->duid_id)
+		free(d->duid_id);
+	d->duid_id = NULL;
+	d->duid_len = 0;
+}
+
+/*
+ * Provide an NTP-format timestamp as a replay detection counter
+ * as mentioned in RFC3315.
+ */
+#define JAN_1970        2208988800UL        /* 1970 - 1900 in seconds */
+int get_rdvalue(int rdm, void *rdvalue, size_t rdsize)
+{
+	struct timeval tv;
+	uint32_t pack[2];
+
+	if (rdm != DHCP6_AUTHRDM_MONOCOUNTER ||
+	    rdsize != sizeof(uint64_t)) {
+		bb_info_msg("unsupported RDM (%d) size (%d", rdm, (int )rdsize);
+		return (-1);
+	}
+
+	gettimeofday(&tv, NULL);
+
+	pack[0] = htonl((uint32_t)tv.tv_sec + JAN_1970);
+	pack[1] = htonl((uint32_t)tv.tv_usec);
+
+	memcpy(rdvalue, pack, sizeof(uint64_t));
+
+	return (0);
+}
+
+const char *dhcp6optstr(int type)
+{
+	static char genstr[sizeof("opt_65535") + 1]; /* XXX thread unsafe */
+
+	if (type > 65535)
+		return ("INVALID option");
+
+	switch (type) {
+	case DH6OPT_CLIENTID:
+		return ("client ID");
+	case DH6OPT_SERVERID:
+		return ("server ID");
+	case DH6OPT_IA_NA:
+		return ("identity association");
+	case DH6OPT_IA_TA:
+		return ("IA for temporary");
+	case DH6OPT_IAADDR:
+		return ("IA address");
+	case DH6OPT_ORO:
+		return ("option request");
+	case DH6OPT_PREFERENCE:
+		return ("preference");
+	case DH6OPT_ELAPSED_TIME:
+		return ("elapsed time");
+	case DH6OPT_RELAY_MSG:
+		return ("relay message");
+	case DH6OPT_AUTH:
+		return ("authentication");
+	case DH6OPT_UNICAST:
+		return ("server unicast");
+	case DH6OPT_STATUS_CODE:
+		return ("status code");
+	case DH6OPT_RAPID_COMMIT:
+		return ("rapid commit");
+	case DH6OPT_USER_CLASS:
+		return ("user class");
+	case DH6OPT_VENDOR_CLASS:
+		return ("vendor class");
+	case DH6OPT_VENDOR_OPTS:
+		return ("vendor specific info");
+	case DH6OPT_INTERFACE_ID:
+		return ("interface ID");
+	case DH6OPT_RECONF_MSG:
+		return ("reconfigure message");
+	case DH6OPT_SIP_SERVER_D:
+		return ("SIP domain name");
+	case DH6OPT_SIP_SERVER_A:
+		return ("SIP server address");
+	case DH6OPT_DNS:
+		return ("DNS");
+	case DH6OPT_DNSNAME:
+		return ("domain search list");
+	case DH6OPT_NTP:
+		return ("NTP server");
+	case DH6OPT_IA_PD:
+		return ("IA_PD");
+	case DH6OPT_IA_PD_PREFIX:
+		return ("IA_PD prefix");
+	case DH6OPT_REFRESHTIME:
+		return ("information refresh time");
+	case DH6OPT_NIS_SERVERS:
+		return ("NIS servers");
+	case DH6OPT_NISP_SERVERS:
+		return ("NIS+ servers");
+	case DH6OPT_NIS_DOMAIN_NAME:
+		return ("NIS domain name");
+	case DH6OPT_NISP_DOMAIN_NAME:
+		return ("NIS+ domain name");
+	case DH6OPT_BCMCS_SERVER_D:
+		return ("BCMCS domain name");
+	case DH6OPT_BCMCS_SERVER_A:
+		return ("BCMCS server address");
+	case DH6OPT_REMOTE_ID:
+		return ("remote ID");
+	case DH6OPT_SUBSCRIBER_ID:
+		return ("subscriber ID");
+	case DH6OPT_CLIENT_FQDN:
+		return ("client FQDN");
+	default:
+		snprintf(genstr, sizeof(genstr), "opt_%d", type);
+		return (genstr);
+	}
+}
+
+const char *dhcp6msgstr(int type)
+{
+	static char genstr[sizeof("msg255") + 1]; /* XXX thread unsafe */
+
+	if (type > 255)
+		return ("INVALID msg");
+
+	switch (type) {
+	case DH6_SOLICIT:
+		return ("solicit");
+	case DH6_ADVERTISE:
+		return ("advertise");
+	case DH6_REQUEST:
+		return ("request");
+	case DH6_CONFIRM:
+		return ("confirm");
+	case DH6_RENEW:
+		return ("renew");
+	case DH6_REBIND:
+		return ("rebind");
+	case DH6_REPLY:
+		return ("reply");
+	case DH6_RELEASE:
+		return ("release");
+	case DH6_DECLINE:
+		return ("decline");
+	case DH6_RECONFIGURE:
+		return ("reconfigure");
+	case DH6_INFORM_REQ:
+		return ("information request");
+	case DH6_RELAY_FORW:
+		return ("relay-forward");
+	case DH6_RELAY_REPLY:
+		return ("relay-reply");
+	default:
+		snprintf(genstr, sizeof(genstr), "msg%d", type);
+		return (genstr);
+	}
+}
+
+const char *dhcp6_stcodestr(uint16_t code)
+{
+	static char genstr[sizeof("code255") + 1]; /* XXX thread unsafe */
+
+	if (code > 255)
+		return ("INVALID code");
+
+	switch (code) {
+	case DH6OPT_STCODE_SUCCESS:
+		return ("success");
+	case DH6OPT_STCODE_UNSPECFAIL:
+		return ("unspec failure");
+	case DH6OPT_STCODE_NOADDRSAVAIL:
+		return ("no addresses");
+	case DH6OPT_STCODE_NOBINDING:
+		return ("no binding");
+	case DH6OPT_STCODE_NOTONLINK:
+		return ("not on-link");
+	case DH6OPT_STCODE_USEMULTICAST:
+		return ("use multicast");
+	case DH6OPT_STCODE_NOPREFIXAVAIL:
+		return ("no prefixes");
+	default:
+		snprintf(genstr, sizeof(genstr), "code%d", code);
+		return (genstr);
+	}
+}
+
+char *duidstr(struct duid *duid)
+{
+	int i, n, rest;
+	char *cp;
+#define duidbuf		(&bb_common_bufsiz1[COMMON_BUFSIZE / 2])
+//	static char duidbuf[sizeof("xx:") * 128 + sizeof("...")];
+
+	cp = duidbuf;
+	rest = COMMON_BUFSIZE / 2;
+	for (i = 0; i < duid->duid_len && i <= 128; i++) {
+		n = snprintf(cp, rest, "%s%02x", i == 0 ? "" : ":",
+		    duid->duid_id[i] & 0xff);
+		if (n < 0)
+			return NULL;
+		cp += n;
+		rest -= n;
+	}
+	if (i < duid->duid_len)
+		snprintf(cp, rest, "%s", "...");
+
+	return (duidbuf);
+}
+#undef duidbuf
+
+const char *dhcp6_event_statestr(struct dhcp6_event *ev)
+{
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		return ("INIT");
+	case DHCP6S_SOLICIT:
+		return ("SOLICIT");
+	case DHCP6S_INFOREQ:
+		return ("INFOREQ");
+	case DHCP6S_REQUEST:
+		return ("REQUEST");
+	case DHCP6S_RENEW:
+		return ("RENEW");
+	case DHCP6S_REBIND:
+		return ("REBIND");
+	case DHCP6S_RELEASE:
+		return ("RELEASE");
+	case DHCP6S_IDLE:
+		return ("IDLE");
+	default:
+		return ("???"); /* XXX */
+	}
+}
+
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/common6.h busybox/networking/udhcp/common6.h
--- busybox.orig/networking/udhcp/common6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/common6.h	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* XXX: bsdi4 does not have TAILQ_EMPTY */
+#ifndef TAILQ_EMPTY
+#define	TAILQ_EMPTY(head) ((head)->tqh_first == NULL)
+#endif
+
+/* and linux *_FIRST and *_NEXT */
+#ifndef LIST_EMPTY
+#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
+#endif
+#ifndef LIST_FIRST
+#define	LIST_FIRST(head)	((head)->lh_first)
+#endif
+#ifndef LIST_NEXT
+#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
+#endif
+#ifndef LIST_FOREACH
+#define	LIST_FOREACH(var, head, field)					\
+	for ((var) = LIST_FIRST((head));				\
+	    (var);							\
+	    (var) = LIST_NEXT((var), field))
+#endif
+#ifndef TAILQ_FIRST
+#define	TAILQ_FIRST(head)	((head)->tqh_first)
+#endif
+#ifndef TAILQ_LAST
+#define	TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+#endif
+#ifndef TAILQ_PREV
+#define	TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+#endif
+#ifndef TAILQ_NEXT
+#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+#endif
+#ifndef TAILQ_FOREACH
+#define	TAILQ_FOREACH(var, head, field)					\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var);							\
+	    (var) = TAILQ_NEXT((var), field))
+#endif
+#ifdef HAVE_TAILQ_FOREACH_REVERSE_OLD
+#undef TAILQ_FOREACH_REVERSE
+#endif
+#ifndef TAILQ_FOREACH_REVERSE
+#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for ((var) = TAILQ_LAST((head), headname);			\
+	    (var);							\
+	    (var) = TAILQ_PREV((var), headname, field))
+#endif
+
+
+#ifndef SO_REUSEPORT
+#define SO_REUSEPORT SO_REUSEADDR
+#endif
+
+
+/* s*_len stuff */
+static ALWAYS_INLINE int sysdep_sa_len(const struct sockaddr *sa)
+{
+#ifndef HAVE_SA_LEN
+  switch (sa->sa_family)
+    {
+    case AF_INET6:
+      return sizeof(struct sockaddr_in6);
+    case AF_INET:
+    default:
+      return sizeof(struct sockaddr_in);
+    }
+#else
+  return sa->sa_len;
+#endif
+}
+
+/* search option for dhcp6_find_listval() */
+#define MATCHLIST_PREFIXLEN 0x1
+
+/* common.c */
+typedef enum { IFADDRCONF_ADD, IFADDRCONF_REMOVE } ifaddrconf_cmd_t;
+
+int dhcp6_copy_list(struct dhcp6_list *, struct dhcp6_list *);
+void dhcp6_move_list(struct dhcp6_list *, struct dhcp6_list *);
+void dhcp6_clear_list(struct dhcp6_list *);
+void dhcp6_clear_listval(struct dhcp6_listval *);
+struct dhcp6_listval *dhcp6_find_listval(struct dhcp6_list *,
+    dhcp6_listval_type_t, void *, int);
+struct dhcp6_listval *dhcp6_add_listval(struct dhcp6_list *,
+    dhcp6_listval_type_t, void *, struct dhcp6_list *);
+int dhcp6_vbuf_copy(struct dhcp6_vbuf *, struct dhcp6_vbuf *);
+void dhcp6_vbuf_free(struct dhcp6_vbuf *);
+int dhcp6_vbuf_cmp(struct dhcp6_vbuf *, struct dhcp6_vbuf *);
+struct dhcp6_event *dhcp6_create_event(struct dhcp6_if *, int);
+void dhcp6_remove_event(struct dhcp6_event *);
+void dhcp6_remove_evdata(struct dhcp6_event *);
+struct authparam *new_authparam(int, int, int);
+struct authparam *copy_authparam(struct authparam *);
+int dhcp6_auth_replaycheck(int, uint64_t, uint64_t);
+int getifaddr(struct in6_addr *, char *, const struct in6_addr *, int, int);
+int getifidfromaddr(struct in6_addr *, unsigned int *);
+int prefix6_mask(struct in6_addr *, int);
+char *in6addr2str(struct in6_addr *, int);
+int in6_addrscopebyif(const struct in6_addr *, const char *);
+int in6_scope(struct in6_addr *);
+int get_duid(const char *, struct duid *, int);
+void dhcp6_init_options(struct dhcp6_optinfo *);
+void dhcp6_clear_options(struct dhcp6_optinfo *);
+int dhcp6_copy_options(struct dhcp6_optinfo *,
+			   struct dhcp6_optinfo *);
+int dhcp6_get_options(struct dhcp6opt *, struct dhcp6opt *,
+			  struct dhcp6_optinfo *);
+int dhcp6_set_options(int, struct dhcp6opt *, struct dhcp6opt *,
+			  struct dhcp6_optinfo *);
+void dhcp6_set_timeoparam(struct dhcp6_event *);
+void dhcp6_reset_timer(struct dhcp6_event *);
+
+const char *dhcp6optstr(int);
+const char *dhcp6msgstr(int);
+const char *dhcp6_stcodestr(uint16_t);
+char *duidstr(struct duid *);
+const char *dhcp6_event_statestr(struct dhcp6_event *);
+int get_rdvalue(int, void *, size_t);
+int duidcpy(struct duid *, struct duid *);
+int duidcmp(struct duid *, struct duid *);
+void duidfree(struct duid *);
+int ifaddrconf(ifaddrconf_cmd_t, char *, struct sockaddr_in6 *,
+			   int, int, int);
+
+
+/*
+ * compat hacks in case libc and kernel get out of sync:
+ *
+ * glibc 2.4 and uClibc 0.9.29 introduce IPV6_RECVPKTINFO etc. and change IPV6_PKTINFO
+ * This is only supported in Linux kernel >= 2.6.14
+ *
+ * This is only an approximation because the kernel version that libc was compiled against
+ * could be older or newer than the one being run.  But this should not be a problem --
+ * we just keep using the old kernel interface.
+ *
+ * these are placed here because they're needed in all of socket.c, recv.c and send.c
+ */
+#ifdef __linux__
+#  if defined IPV6_RECVHOPLIMIT || defined IPV6_RECVPKTINFO
+#    include <linux/version.h>
+#    if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+#      if defined IPV6_RECVHOPLIMIT && defined IPV6_2292HOPLIMIT
+#        undef IPV6_RECVHOPLIMIT
+#        define IPV6_RECVHOPLIMIT IPV6_2292HOPLIMIT
+#      endif
+#      if defined IPV6_RECVPKTINFO && defined IPV6_2292PKTINFO
+#        undef IPV6_RECVPKTINFO
+#        undef IPV6_PKTINFO
+#        define IPV6_RECVPKTINFO IPV6_2292PKTINFO
+#        define IPV6_PKTINFO IPV6_2292PKTINFO
+#      endif
+#    endif
+#  endif
+#endif
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/config6.c busybox/networking/udhcp/config6.c
--- busybox.orig/networking/udhcp/config6.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/config6.c	2011-02-08 16:05:13.000000000 +0300
@@ -0,0 +1,1764 @@
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+#include <sys/ioctl.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+#ifdef __linux__
+#include <linux/if_packet.h>
+#endif
+
+#include <syslog.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ifaddrs.h>
+#include <errno.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "auth6.h"
+#include "base64.h"
+
+
+enum { DHCPOPTCODE_SEND, DHCPOPTCODE_REQUEST, DHCPOPTCODE_ALLOW };
+
+/* temporary configuration structure for DHCP interface */
+struct dhcp6_ifconf {
+	struct dhcp6_ifconf *next;
+
+	char *ifname;
+
+	/* configuration flags */
+	u_long send_flags;
+	u_long allow_flags;
+
+	int server_pref;	/* server preference (server only) */
+
+	char *scriptpath;	/* path to config script (client only) */
+
+	struct dhcp6_list reqopt_list;
+	struct ia_conflist iaconf_list;
+
+	struct authinfo *authinfo; /* authentication information
+				    * (no need to clear) */
+	struct dhcp6_poolspec pool;
+};
+
+
+static int add_pd_pif(struct iapd_conf *, struct cf_list *);
+static int add_options(int, struct dhcp6_ifconf *, struct cf_list *);
+static int add_prefix(struct dhcp6_list *, const char *, int,
+    struct dhcp6_prefix *);
+static void clear_pd_pif(struct iapd_conf *);
+static void clear_ifconf(struct dhcp6_ifconf *);
+static void clear_iaconf(struct ia_conflist *);
+static void clear_keys(struct keyinfo *);
+static void clear_authinfo(struct authinfo *);
+static int get_default_ifid(struct prefix_ifconf *);
+
+static void configure_cleanup(void);
+static void configure_commit(void);
+static int configure_interface(struct cf_namelist *);
+static int configure_ia(struct cf_namelist *, iatype_t);
+#if ENABLE_FEATURE_DHCP6_AUTH
+static char *qstrdup(char *);
+static int configure_keys(struct cf_namelist *);
+static int configure_authinfo(struct cf_namelist *);
+static struct authinfo *find_authinfo(struct authinfo *, char *);
+#endif
+
+static int configure_interface(struct cf_namelist *iflist)
+{
+	struct cf_namelist *ifp;
+	struct dhcp6_ifconf *ifc;
+	char *cp;
+
+	for (ifp = iflist; ifp; ifp = ifp->next) {
+		struct cf_list *cfl;
+
+		if (if_nametoindex(ifp->name) == 0) {
+			bb_error_msg("invalid interface(%s): %s",
+			    ifp->name, strerror(errno));
+			goto bad;
+		}
+
+		ifc = xzalloc(sizeof(*ifc));
+		ifc->next = client6_config.dhcp6_ifconflist;
+		client6_config.dhcp6_ifconflist = ifc;
+
+		ifc->ifname = xstrdup(ifp->name);
+		ifc->server_pref = DH6OPT_PREF_UNDEF;
+		TAILQ_INIT(&ifc->reqopt_list);
+		TAILQ_INIT(&ifc->iaconf_list);
+
+		for (cfl = ifp->params; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case DECL_REQUEST:
+				if (add_options(DHCPOPTCODE_REQUEST,
+						ifc, cfl->list)) {
+					goto bad;
+				}
+				break;
+			case DECL_SEND:
+				if (add_options(DHCPOPTCODE_SEND,
+						ifc, cfl->list)) {
+					goto bad;
+				}
+				break;
+			case DECL_ALLOW:
+				if (add_options(DHCPOPTCODE_ALLOW,
+						ifc, cfl->list)) {
+					goto bad;
+				}
+				break;
+			case DECL_INFO_ONLY:
+				ifc->send_flags |= DHCIFF_INFO_ONLY;
+				break;
+			case DECL_SCRIPT:
+				if (ifc->scriptpath) {
+					bb_info_msg(
+					    "%s:%d duplicated configuration",
+					    client6_config.conffile, cfl->line);
+					goto bad;
+				}
+				cp = cfl->ptr;
+				ifc->scriptpath = xstrdup(cp + 1);
+				cp = ifc->scriptpath;
+				if (*cp != '/') {
+					bb_info_msg(
+					    "script must be an absolute path");
+					goto bad;
+				}
+				cp += strlen(ifc->scriptpath) - 1;
+				*cp = '\0'; /* clear the terminating quote */
+				break;
+			default:
+				bb_error_msg("%s:%d "
+					"invalid interface configuration",
+					client6_config.conffile, cfl->line);
+				goto bad;
+			}
+		}
+	}
+	
+	return (0);
+
+  bad:
+	clear_ifconf(client6_config.dhcp6_ifconflist);
+	client6_config.dhcp6_ifconflist = NULL;
+	return (-1);
+}
+
+static int configure_ia(struct cf_namelist *ialist, iatype_t iatype)
+{
+	struct cf_namelist *iap;
+	struct ia_conf *iac = NULL;
+	size_t confsize;
+
+	switch (iatype) {
+	case IATYPE_PD:
+		confsize = sizeof(struct iapd_conf);
+		break;
+	case IATYPE_NA:
+		confsize = sizeof(struct iana_conf);
+		break;
+	default:
+		bb_error_msg("internal error");
+		goto bad;
+	}
+
+	for (iap = ialist; iap; iap = iap->next) {
+		struct cf_list *cfl;
+
+		iac = xzalloc(confsize);
+
+		/* common initialization */
+		iac->type = iatype;
+		iac->iaid = (uint32_t)atoi(iap->name);
+		TAILQ_INIT(&iac->iadata);
+		TAILQ_INSERT_TAIL(&client6_config.ia_conflist, iac, link);
+
+		/* IA-type specific initialization */
+		switch (iatype) {
+		case IATYPE_PD:
+			TAILQ_INIT(&((struct iapd_conf *)iac)->iapd_prefix_list);
+			TAILQ_INIT(&((struct iapd_conf *)iac)->iapd_pif_list);
+			break;
+		case IATYPE_NA:
+			TAILQ_INIT(&((struct iana_conf *)iac)->iana_address_list);
+			break;
+		}
+
+		/* set up parameters for the IA */
+		for (cfl = iap->params; cfl; cfl = cfl->next) {
+			struct iapd_conf *pdp = (struct iapd_conf *) iac;
+			struct iana_conf *nap = (struct iana_conf *) iac;
+
+			switch (iatype) {
+			case IATYPE_PD:
+				switch (cfl->type) {
+				case IACONF_PIF:
+					if (add_pd_pif(pdp, cfl))
+						goto bad;
+					break;
+				case IACONF_PREFIX:
+					if (add_prefix(&pdp->iapd_prefix_list,
+					    "IAPD", DHCP6_LISTVAL_PREFIX6,
+					    cfl->ptr)) {
+						bb_error_msg("failed "
+							"to configure prefix");
+						goto bad;
+					}
+					break;
+				default:
+					bb_error_msg("%s:%d "
+					    "invalid configuration",
+					    client6_config.conffile, cfl->line);
+					goto bad;
+				}
+				break;
+			case IATYPE_NA:
+				switch (cfl->type) {
+				case IACONF_ADDR:
+					if (add_prefix(&nap->iana_address_list,
+					    "IANA", DHCP6_LISTVAL_STATEFULADDR6,
+					    cfl->ptr)) {
+						bb_error_msg("failed "
+							"to configure address");
+						goto bad;
+					}
+					break;
+				default:
+					bb_error_msg("%s:%d "
+					    "invalid configuration",
+					    client6_config.conffile, cfl->line);
+					goto bad;
+				}
+				break;
+			default:
+				bb_error_msg("%s:%d "
+				    "invalid iatype %d",
+				    client6_config.conffile, cfl->line, iatype);
+				goto bad;
+			}
+		}
+	}
+
+	return (0);
+
+  bad:
+	return (-1);
+}
+
+static int add_pd_pif(struct iapd_conf *iapdc, struct cf_list *cfl0)
+{
+	struct cf_list *cfl;
+	struct prefix_ifconf *pif;
+
+	/* duplication check */
+	for (pif = TAILQ_FIRST(&iapdc->iapd_pif_list); pif;
+	    pif = TAILQ_NEXT(pif, link)) {
+		if (strcmp(pif->ifname, cfl0->ptr) == 0) {
+			bb_info_msg("%s:%d "
+			    "duplicated prefix interface: %s",
+			    client6_config.conffile, cfl0->line, (char *)cfl0->ptr);
+			return (0); /* ignore it */
+		}
+	}
+
+	pif = xzalloc(sizeof(*pif));
+
+	/* validate and copy ifname */
+	if (if_nametoindex(cfl0->ptr) == 0) {
+		bb_error_msg("%s:%d invalid interface (%s): %s",
+		    client6_config.conffile, cfl0->line,
+		    (char *)cfl0->ptr, strerror(errno));
+		goto bad;
+	}
+	pif->ifname = xstrdup(cfl0->ptr);
+
+	pif->ifid_len = IFID_LEN_DEFAULT;
+	pif->sla_len = SLA_LEN_DEFAULT;
+	if (get_default_ifid(pif)) {
+		bb_info_msg(
+		    "failed to get default IF ID for %s", pif->ifname);
+		goto bad;
+	}
+
+	for (cfl = cfl0->list; cfl; cfl = cfl->next) {
+		switch (cfl->type) {
+		case IFPARAM_SLA_ID:
+			pif->sla_id = (uint32_t)cfl->num;
+			break;
+		case IFPARAM_SLA_LEN:
+			pif->sla_len = (int)cfl->num;
+			if (pif->sla_len < 0 || pif->sla_len > 128) {
+				bb_error_msg("%s:%d "
+				    "invalid SLA length: %d",
+				    client6_config.conffile, cfl->line, pif->sla_len); 
+				goto bad;
+			}
+			break;
+		default:
+			bb_error_msg("%s:%d internal error: "
+			    "invalid configuration",
+			    client6_config.conffile, cfl->line);
+			goto bad;
+		}
+	}
+
+	TAILQ_INSERT_TAIL(&iapdc->iapd_pif_list, pif, link);
+	return (0);
+
+  bad:
+	if (pif->ifname)
+		free(pif->ifname);
+	free(pif);
+	return (-1);
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int configure_keys(struct cf_namelist *keylist)
+{
+	struct cf_namelist *key;
+	char *secretstr;
+	char secret[1024];
+	int secretlen;
+	struct keyinfo *kinfo;
+	long long keyid;
+	char *expire = NULL;
+
+	for (key = keylist; key; key = key->next) {
+		struct cf_list *cfl;
+
+		kinfo = xzalloc(sizeof(*kinfo));
+		kinfo->next = client6_config.key_list;
+		client6_config.key_list = kinfo;
+		kinfo->name = xstrdup(key->name);
+
+		keyid = -1;
+		expire = NULL;
+		for (cfl = key->params; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case KEYPARAM_REALM:
+				if (kinfo->realm != NULL) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for key %s "
+					    "(ignored)", client6_config.conffile, cfl->line,
+					    "realm", key->name);
+					continue;
+				}
+				kinfo->realm = qstrdup(cfl->ptr);
+				if (kinfo->realm == NULL)
+					goto bad;
+				kinfo->realmlen = strlen(kinfo->realm);
+				break;
+			case KEYPARAM_KEYID:
+				if (keyid != -1) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for key %s "
+					    "(ignored)", client6_config.conffile, cfl->line,
+					    "key ID", key->name);
+					continue;
+				}
+				keyid = cfl->num;
+				if (keyid < 0 || keyid > 0xffffffff) {
+					bb_info_msg("%s:%d key ID overflow",
+					     client6_config.conffile, cfl->line);
+					goto bad;
+				}
+				break;
+			case KEYPARAM_SECRET:
+				/* duplicate check */
+				if (kinfo->secret != NULL) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for key %s "
+					    "(ignored)", client6_config.conffile, cfl->line,
+					    "secret", key->name);
+					continue; /* ignored */
+				}
+
+				/* convert base64 string to binary secret */
+				if ((secretstr = qstrdup(cfl->ptr)) == NULL)
+					goto bad;
+				memset(secret, 0, sizeof(secret));
+				secretlen = base64_decodestring(secretstr,
+				    secret, sizeof(secret));
+				if (secretlen < 0) {
+					bb_error_msg(
+					    "%s:%d failed to parse base64 key",
+					    client6_config.conffile, cfl->line);
+					free(secretstr);
+					goto bad;
+				}
+				free(secretstr);
+
+				/* set the binary secret */
+				kinfo->secret = malloc_or_warn(secretlen);
+				if (kinfo->secret == NULL) {
+					goto bad;
+				}
+				memcpy(kinfo->secret, secret, secretlen); 
+				kinfo->secretlen = secretlen;
+				break;
+			case KEYPARAM_EXPIRE:
+				if (expire != NULL) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for key %s "
+					    "(ignored)", client6_config.conffile, cfl->line,
+					    "expire", key->name);
+					continue;
+				}
+				expire = qstrdup(cfl->ptr);
+				break;
+			default:
+				bb_error_msg("%s:%d invalid parameter for %s",
+				    client6_config.conffile, cfl->line, key->name);
+				goto bad;
+			}
+		}
+
+		/* check for mandatory parameters or use default */
+		if (kinfo->realm == NULL) {
+			bb_error_msg(
+			    "%s not specified for key %s", "realm", key->name);
+			goto bad;
+		}
+		if (keyid == -1) {
+			bb_error_msg(
+			    "%s not specified for key %s", "key ID", key->name);
+			goto bad;
+		}
+		kinfo->keyid = keyid;
+		if (kinfo->secret == NULL) {
+			bb_error_msg(
+			    "%s not specified for key %s", "secret",key->name);
+			goto bad;
+		}
+		kinfo->expire = 0;
+		if (expire != NULL) {
+			if (strcmp(expire, "forever") != 0) {
+				time_t now, expire_time;
+				struct tm lt;
+
+				if (time(&now) == -1) {
+					goto bad;
+				}
+				parse_datestr(expire, &lt);
+				expire_time = mktime(&lt);
+				if (expire_time < now) {
+					bb_error_msg("past "
+					    "expiration time specified: %s",
+					    expire);
+					goto bad;
+				}
+
+				kinfo->expire = expire_time;
+			}
+		}
+	}
+
+	return (0);
+
+  bad:
+	if (expire != NULL)
+		free(expire);
+	return (-1);
+}
+
+static int configure_authinfo(struct cf_namelist *authlist)
+{
+	struct cf_namelist *auth;
+	struct authinfo *ainfo;
+
+	for (auth = authlist; auth; auth = auth->next) {
+		struct cf_list *cfl;
+
+		ainfo = xzalloc(sizeof(*ainfo));
+		ainfo->next = client6_config.auth_list;
+		client6_config.auth_list = ainfo;
+		ainfo->protocol = DHCP6_AUTHPROTO_UNDEF;
+		ainfo->algorithm = DHCP6_AUTHALG_UNDEF;
+		ainfo->rdm = DHCP6_AUTHRDM_UNDEF;
+		ainfo->name = xstrdup(auth->name);
+
+		for (cfl = auth->params; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case AUTHPARAM_PROTO:
+				if (ainfo->protocol != DHCP6_AUTHPROTO_UNDEF) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for auth info %s "
+					    "(ignored)",
+					    client6_config.conffile, cfl->line,
+					    "protocol", auth->name);
+					continue; /* ignored */
+				}
+				ainfo->protocol = (int)cfl->num;
+				break;
+			case AUTHPARAM_ALG:
+				if (ainfo->algorithm != DHCP6_AUTHALG_UNDEF) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for auth info %s "
+					    "(ignored)",
+					    client6_config.conffile, cfl->line,
+					    "algorithm", auth->name);
+					continue; /* ignored */
+				}
+				ainfo->algorithm = (int)cfl->num;
+				break;
+			case AUTHPARAM_RDM:
+				if (ainfo->rdm != DHCP6_AUTHRDM_UNDEF) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for auth info %s "
+					    "(ignored)",
+					    client6_config.conffile, cfl->line,
+					    "RDM", auth->name);
+					continue; /* ignored */
+				}
+				ainfo->rdm = (int)cfl->num;
+				break;
+			case AUTHPARAM_KEY:
+				bb_info_msg(
+				    "%s:%d auth info specific keys "
+				    "are not supported",
+				    client6_config.conffile, cfl->line);
+				break;
+			default:
+				bb_error_msg("%s:%d invalid auth info parameter for %s",
+				    client6_config.conffile, cfl->line, auth->name);
+				goto bad;
+			}
+		}
+
+		/* check for mandatory parameters and consistency */
+		switch (ainfo->protocol) {
+		case DHCP6_AUTHPROTO_UNDEF:
+			bb_error_msg("auth protocol is not specified for %s",
+			    auth->name);
+			goto bad;
+		case DHCP6_AUTHPROTO_DELAYED:
+			break;
+		case DHCP6_AUTHPROTO_RECONFIG:
+			goto bad;
+			break;
+		}
+		if (ainfo->algorithm == DHCP6_AUTHALG_UNDEF)
+			ainfo->algorithm = DHCP6_AUTHALG_HMACMD5;
+		if (ainfo->rdm == DHCP6_AUTHRDM_UNDEF)
+			ainfo->rdm = DHCP6_AUTHRDM_MONOCOUNTER;
+	}
+
+	return (0);
+
+  bad:
+	/* there is currently nothing special to recover the error */
+	return (-1);
+}
+
+static struct authinfo *find_authinfo(struct authinfo *head, char *name)
+{
+	struct authinfo *ainfo;
+
+	for (ainfo = head; ainfo; ainfo = ainfo->next) {
+		if (strcmp(ainfo->name, name) == 0)
+			return (ainfo);
+	}
+
+	return (NULL);
+}
+
+static char *qstrdup(char *qstr)
+{
+	size_t len;
+	char *dst;
+
+	len = strlen(qstr);
+	if (qstr[0] != '"' || len < 2 || qstr[len - 1] != '"')
+		return (NULL);
+
+	if ((dst = malloc_or_warn(len)) == NULL)
+		return (NULL);
+
+	memcpy(dst, qstr + 1, len - 1);
+	dst[len - 2] = '\0';
+
+	return (dst);
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+/* we currently only construct EUI-64 based interface ID */
+static int get_default_ifid(struct prefix_ifconf *pif)
+{
+	struct ifaddrs *ifa, *ifap;
+#ifdef __linux__
+	struct sockaddr_ll *sll;
+#endif
+
+	if (pif->ifid_len < 64) {
+		bb_error_msg("ID length too short");
+		return (-1);
+	}
+
+	if (getifaddrs(&ifap) < 0) {
+		bb_error_msg("getifaddrs failed: %s",
+		    strerror(errno));
+		return (-1);
+	}
+
+	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+		char *cp;
+
+		if (strcmp(ifa->ifa_name, pif->ifname) != 0)
+			continue;
+
+		if (ifa->ifa_addr == NULL)
+			continue;
+
+#ifdef __linux__
+		if (ifa->ifa_addr->sa_family != AF_PACKET)
+			continue;
+
+		sll = (struct sockaddr_ll *)ifa->ifa_addr;
+		if (sll->sll_halen < 6) {
+			bb_info_msg(
+			    "link layer address is too short (%s)",
+			    pif->ifname);
+			goto fail;
+		}
+
+		memset(pif->ifid, 0, sizeof(pif->ifid));
+		cp = (char *)(sll->sll_addr);
+#else // TODO!!!
+		cp = (char *)"000001";
+#endif
+		pif->ifid[8] = cp[0];
+		pif->ifid[8] ^= 0x02; /* reverse the u/l bit*/
+		pif->ifid[9] = cp[1];
+		pif->ifid[10] = cp[2];
+		pif->ifid[11] = 0xff;
+		pif->ifid[12] = 0xfe;
+		pif->ifid[13] = cp[3];
+		pif->ifid[14] = cp[4];
+		pif->ifid[15] = cp[5];
+
+		break;
+	}
+
+	if (ifa == NULL) {
+		bb_info_msg(
+		    "cannot find interface information for %s", pif->ifname);
+		goto fail;
+	}
+
+	freeifaddrs(ifap);
+	return (0);
+
+  fail:
+	freeifaddrs(ifap);
+	return (-1);
+}
+
+static void configure_cleanup(void)
+{
+	clear_iaconf(&client6_config.ia_conflist);
+	clear_ifconf(client6_config.dhcp6_ifconflist);
+	client6_config.dhcp6_ifconflist = NULL;
+}
+
+static void configure_commit(void)
+{
+	struct dhcp6_ifconf *ifc;
+	struct dhcp6_if *ifp;
+	struct ia_conf *iac;
+
+	/* commit interface configuration */
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		/* re-initialization */
+		ifp->send_flags = 0;
+		ifp->allow_flags = 0;
+		dhcp6_clear_list(&ifp->reqopt_list);
+		clear_iaconf(&ifp->iaconf_list);
+		ifp->server_pref = DH6OPT_PREF_UNDEF;
+		if (ifp->scriptpath != NULL)
+			free(ifp->scriptpath);
+		ifp->scriptpath = NULL;
+		ifp->authproto = DHCP6_AUTHPROTO_UNDEF;
+		ifp->authalgorithm = DHCP6_AUTHALG_UNDEF; 
+		ifp->authrdm = DHCP6_AUTHRDM_UNDEF;
+
+		for (ifc = client6_config.dhcp6_ifconflist; ifc; ifc = ifc->next) {
+			if (strcmp(ifp->ifname, ifc->ifname) == 0)
+				break;
+		}
+		if (ifc == NULL)
+			continue;
+
+		/* copy new configuration */
+		ifp->send_flags = ifc->send_flags;
+		ifp->allow_flags = ifc->allow_flags;
+		dhcp6_copy_list(&ifp->reqopt_list, &ifc->reqopt_list);
+		while ((iac = TAILQ_FIRST(&ifc->iaconf_list)) != NULL) {
+			TAILQ_REMOVE(&ifc->iaconf_list, iac, link);
+			TAILQ_INSERT_TAIL(&ifp->iaconf_list,
+			    iac, link);
+		}
+		ifp->server_pref = ifc->server_pref;
+		ifp->scriptpath = ifc->scriptpath;
+		ifc->scriptpath = NULL;
+
+		if (ifc->authinfo != NULL) {
+			ifp->authproto = ifc->authinfo->protocol;
+			ifp->authalgorithm = ifc->authinfo->algorithm;
+			ifp->authrdm = ifc->authinfo->rdm;
+		}
+		ifp->pool = ifc->pool;
+		ifc->pool.name = NULL;
+	}
+
+	clear_ifconf(client6_config.dhcp6_ifconflist);
+	client6_config.dhcp6_ifconflist = NULL;
+
+	/* clear unused IA configuration */
+	if (!TAILQ_EMPTY(&client6_config.ia_conflist)) {
+		bb_info_msg("some IA configuration defined but not used");
+	}
+	clear_iaconf(&client6_config.ia_conflist);
+}
+
+static void clear_ifconf(struct dhcp6_ifconf *iflist)
+{
+	struct dhcp6_ifconf *ifc, *ifc_next;
+
+	for (ifc = iflist; ifc; ifc = ifc_next) {
+		ifc_next = ifc->next;
+
+		free(ifc->ifname);
+		dhcp6_clear_list(&ifc->reqopt_list);
+
+		clear_iaconf(&ifc->iaconf_list);
+
+		if (ifc->scriptpath)
+			free(ifc->scriptpath);
+
+		if (ifc->pool.name)
+			free(ifc->pool.name);
+		free(ifc);
+	}
+}
+
+static void clear_pd_pif(struct iapd_conf *iapdc)
+{
+	struct prefix_ifconf *pif, *pif_next;
+
+	for (pif = TAILQ_FIRST(&iapdc->iapd_pif_list); pif; pif = pif_next) {
+		pif_next = TAILQ_NEXT(pif, link);
+
+		free(pif->ifname);
+		free(pif);
+	}
+
+	dhcp6_clear_list(&iapdc->iapd_prefix_list);
+}
+
+static void clear_iaconf(struct ia_conflist *ialist)
+{
+	struct ia_conf *iac;
+
+	while ((iac = TAILQ_FIRST(ialist)) != NULL) {
+		TAILQ_REMOVE(ialist, iac, link);
+
+		switch (iac->type) {
+		case IATYPE_PD:
+			if (!TAILQ_EMPTY(&iac->iadata)) {
+				bb_error_msg_and_die("assumption failure");
+			}
+			clear_pd_pif((struct iapd_conf *)iac);
+			break;
+		case IATYPE_NA:
+			break;
+		}
+		free(iac);
+	}
+}
+
+static void clear_keys(struct keyinfo *klist)
+{
+	struct keyinfo *key = klist, *key_next;
+
+	while (key) {
+		key_next = key->next;
+
+		free(key->name);
+		free(key->realm);
+		free(key->secret);
+		free(key);
+
+		key = key_next;
+	}
+}
+
+static void clear_authinfo(struct authinfo *alist)
+{
+	struct authinfo *auth = alist, *auth_next;
+
+	while (auth) {
+		auth_next = auth->next;
+		free(auth);
+		auth = auth_next;
+	}
+}
+
+static int add_options(int opcode, struct dhcp6_ifconf *ifc,
+			struct cf_list *cfl0)
+{
+	struct cf_list *cfl;
+	int opttype;
+	struct ia_conf *iac;
+#if ENABLE_FEATURE_DHCP6_AUTH
+	struct authinfo *ainfo;
+#endif
+
+	for (cfl = cfl0; cfl; cfl = cfl->next) {
+		switch (cfl->type) {
+		case DHCPOPT_RAPID_COMMIT:
+			switch (opcode) {
+			case DHCPOPTCODE_SEND:
+				ifc->send_flags |= DHCIFF_RAPID_COMMIT;
+				break;
+			case DHCPOPTCODE_ALLOW:
+				ifc->allow_flags |= DHCIFF_RAPID_COMMIT;
+				break;
+			default:
+				bb_error_msg("invalid operation (%d) "
+				    "for option type (%d)",
+				    opcode, cfl->type);
+				return (-1);
+			}
+			break;
+#if ENABLE_FEATURE_DHCP6_AUTH
+		case DHCPOPT_AUTHINFO:
+			if (opcode != DHCPOPTCODE_SEND) {
+				bb_error_msg("invalid operation (%d) "
+				    "for option type (%d)",
+				    opcode, cfl->type);
+				return (-1);
+			}
+			ainfo = find_authinfo(client6_config.auth_list, cfl->ptr);
+			if (ainfo == NULL) {
+				bb_error_msg("%s:%d "
+				    "auth info (%s) is not defined",
+				    client6_config.conffile, cfl->line,
+				    (char *)cfl->ptr);
+				return (-1);
+			}
+			if (ifc->authinfo != NULL) {
+				bb_error_msg("%s:%d authinfo is doubly specified on %s",
+				    client6_config.conffile, cfl->line, ifc->ifname);
+				return (-1);
+			}
+			ifc->authinfo = ainfo; 
+			break;
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+		case DHCPOPT_IA_PD:
+			switch (opcode) {
+			case DHCPOPTCODE_SEND:
+				iac = find_iaconf(&client6_config.ia_conflist, IATYPE_PD,
+				    (uint32_t)cfl->num);
+				if (iac == NULL) {
+					bb_error_msg("%s:%d "
+					    "IA_PD (%lu) is not defined",
+					    client6_config.conffile, cfl->line,
+					    (u_long)cfl->num);
+					return (-1);
+				}
+
+				TAILQ_REMOVE(&client6_config.ia_conflist, iac, link);
+				TAILQ_INSERT_TAIL(&ifc->iaconf_list,
+				    iac, link);
+
+				break;
+			default:
+				bb_error_msg("invalid operation (%d) "
+				    "for option type (%d)", opcode, cfl->type);
+				break;
+			}
+			break;
+		case DHCPOPT_IA_NA:
+			switch (opcode) {
+			case DHCPOPTCODE_SEND:
+				iac = find_iaconf(&client6_config.ia_conflist, IATYPE_NA,
+				    (uint32_t)cfl->num);
+				if (iac == NULL) {
+					bb_error_msg("%s:%d "
+					    "IA_NA (%lu) is not defined",
+					    client6_config.conffile, cfl->line,
+					    (u_long)cfl->num);
+					return (-1);
+				}
+
+				TAILQ_REMOVE(&client6_config.ia_conflist, iac, link);
+				TAILQ_INSERT_TAIL(&ifc->iaconf_list,
+				    iac, link);
+
+				break;
+			default:
+				bb_error_msg("invalid operation (%d) "
+				    "for option type (%d)", opcode, cfl->type);
+				break;
+			}
+			break;
+		case DHCPOPT_SIP:
+		case DHCPOPT_SIPNAME:
+		case DHCPOPT_DNS:
+		case DHCPOPT_DNSNAME:
+		case DHCPOPT_NTP:
+		case DHCPOPT_NIS:
+		case DHCPOPT_NISNAME:
+		case DHCPOPT_NISP:
+		case DHCPOPT_NISPNAME:
+		case DHCPOPT_BCMCS:
+		case DHCPOPT_BCMCSNAME:
+		case DHCPOPT_REFRESHTIME:
+			switch (cfl->type) {
+			case DHCPOPT_SIP:
+				opttype = DH6OPT_SIP_SERVER_A;
+				break;
+			case DHCPOPT_SIPNAME:
+				opttype = DH6OPT_SIP_SERVER_D;
+				break;
+			case DHCPOPT_DNS:
+				opttype = DH6OPT_DNS;
+				break;
+			case DHCPOPT_DNSNAME:
+				opttype = DH6OPT_DNSNAME;
+				break;
+			case DHCPOPT_NTP:
+				opttype = DH6OPT_NTP;
+				break;
+			case DHCPOPT_NIS:
+				opttype = DH6OPT_NIS_SERVERS;
+				break;
+			case DHCPOPT_NISNAME:
+				opttype = DH6OPT_NIS_DOMAIN_NAME;
+				break;
+			case DHCPOPT_NISP:
+				opttype = DH6OPT_NISP_SERVERS;
+				break;
+			case DHCPOPT_NISPNAME:
+				opttype = DH6OPT_NISP_DOMAIN_NAME;
+				break;
+			case DHCPOPT_BCMCS:
+				opttype = DH6OPT_BCMCS_SERVER_A;
+				break;
+			case DHCPOPT_BCMCSNAME:
+				opttype = DH6OPT_BCMCS_SERVER_D;
+				break;
+			case DHCPOPT_REFRESHTIME:
+				opttype = DH6OPT_REFRESHTIME;
+				break;
+			}
+			switch (opcode) {
+			case DHCPOPTCODE_REQUEST:
+				if (dhcp6_find_listval(&ifc->reqopt_list,
+					DHCP6_LISTVAL_NUM, &opttype, 0)
+				    != NULL) {
+					bb_info_msg(
+					    "duplicated requested option: %s",
+					    dhcp6optstr(opttype));
+					goto next; /* ignore it */
+				}
+				if (dhcp6_add_listval(&ifc->reqopt_list,
+				    DHCP6_LISTVAL_NUM, &opttype, NULL)
+				    == NULL) {
+					bb_error_msg("failed to "
+					    "configure an option");
+					return (-1);
+				}
+				break;
+			default:
+				bb_error_msg("invalid operation (%d) "
+				    "for option type (%d)", opcode, cfl->type);
+				break;
+			}
+			break;
+		default:
+			bb_error_msg("%s:%d unsupported option type: %d",
+			    client6_config.conffile, cfl->line, cfl->type);
+			return (-1);
+		}
+
+	  next:
+		;
+	}
+
+	return (0);
+}
+
+static int add_prefix(struct dhcp6_list *head, const char *name, int type,
+		   struct dhcp6_prefix *prefix0)
+{
+	struct dhcp6_prefix oprefix;
+
+	oprefix = *prefix0;
+
+	/* additional validation of parameters */
+	if (oprefix.plen < 4 || oprefix.plen > 128) {
+		bb_error_msg("invalid prefix: %d", oprefix.plen);
+		return (-1);
+	}
+	/* clear trailing bits */
+	prefix6_mask(&oprefix.addr, oprefix.plen);
+	if (!IN6_ARE_ADDR_EQUAL(&prefix0->addr, &oprefix.addr)) {
+		char *p0 = in6addr2str(&prefix0->addr, 0);
+		char *p = in6addr2str(&oprefix.addr, 0);
+		bb_info_msg("prefix %s/%d for %s "
+		    "has a trailing garbage.  It should be %s/%d",
+		    p0, prefix0->plen, name, p, oprefix.plen);
+		free(p0);
+		free(p);
+		/* ignore the error */
+	}
+
+	/* avoid invalid prefix addresses */
+	if (IN6_IS_ADDR_MULTICAST(&oprefix.addr) ||
+	    IN6_IS_ADDR_LINKLOCAL(&oprefix.addr) ||
+	    IN6_IS_ADDR_SITELOCAL(&oprefix.addr)) {
+		char *p = in6addr2str(&oprefix.addr, 0);
+		bb_error_msg("invalid prefix address: %s", p);
+		free(p);
+		return (-1);
+	}
+
+	/* prefix duplication check */
+	if (dhcp6_find_listval(head, type, &oprefix, 0)) {
+		char *p = in6addr2str(&oprefix.addr, 0);
+		if (type == DHCP6_LISTVAL_PREFIX6) {
+			bb_info_msg("duplicated prefix: %s/%d for %s",
+			    p, oprefix.plen, name);
+		} else {
+			bb_info_msg("duplicated address: %s for %s",
+			    p, name);
+		}
+		free(p);
+		return (-1);
+	}
+
+	/* validation about relationship of pltime and vltime */
+	if (oprefix.vltime != DHCP6_DURATION_INFINITE &&
+	    (oprefix.pltime == DHCP6_DURATION_INFINITE ||
+	    oprefix.pltime > oprefix.vltime)) {
+		char *p = in6addr2str(&oprefix.addr, 0);
+		if (type == DHCP6_LISTVAL_PREFIX6) {
+			bb_info_msg(
+			    "%s/%d has larger preferred lifetime "
+			    "than valid lifetime",
+			    p, oprefix.plen);
+		} else {
+			bb_info_msg(
+			    "%s has larger preferred lifetime "
+			    "than valid lifetime",
+			    p);
+		}
+		free(p);
+		return (-1);
+	}
+
+	/* insert the new prefix to the chain */
+	if (dhcp6_add_listval(head, type, &oprefix, NULL) == NULL) {
+		return (-1);
+	}
+
+	return (0);
+}
+
+struct ia_conf *find_iaconf(struct ia_conflist *head, int type, uint32_t iaid)
+{
+	struct ia_conf *iac;
+
+	for (iac = TAILQ_FIRST(head); iac; iac = TAILQ_NEXT(iac, link)) {
+		if (iac->type == type && iac->iaid == iaid)
+			return (iac);
+	}
+
+	return (NULL);
+}
+
+struct dhcp6_prefix *
+find_prefix6(struct dhcp6_list *list, struct dhcp6_prefix *prefix)
+{
+	struct dhcp6_listval *v;
+
+	for (v = TAILQ_FIRST(list); v; v = TAILQ_NEXT(v, link)) {
+		if (v->val_prefix6.plen == prefix->plen &&
+		    IN6_ARE_ADDR_EQUAL(&v->val_prefix6.addr, &prefix->addr)) {
+			return (&v->val_prefix6);
+		}
+	}
+	return (NULL);
+}
+
+struct keyinfo *find_key(char *realm, size_t realmlen, uint32_t id)
+{
+	struct keyinfo *key;
+
+	for (key = client6_config.key_list; key; key = key->next) {
+		if (key->realmlen == realmlen &&
+		    memcmp(key->realm, realm, realmlen) == 0 &&
+		    key->keyid == id) {
+			return (key);
+		}
+	}
+
+	return (NULL);
+}
+
+////////////////////////////////////////////////////////////////////////
+
+
+#define MAKE_NAMELIST(l, n, p) do { \
+	(l) = (struct cf_namelist *)xzalloc(sizeof(*(l))); \
+	l->line = lineno; \
+	l->name = xstrdup((n)); \
+	l->params = (p); \
+	} while (0)
+
+#define MAKE_CFLIST(l, t, pp, pl) do { \
+	(l) = (struct cf_list *)xzalloc(sizeof(*(l))); \
+	l->line = lineno; \
+	l->type = (t); \
+	l->ptr = xstrdup((pp)); \
+	l->list = (pl); \
+	l->tail = (l); \
+	} while (0)
+
+static int add_namelist(struct cf_namelist *, struct cf_namelist **);
+static void cf_cleanup(void);
+static void cleanup_namelist(struct cf_namelist *);
+static void cleanup_cflist(struct cf_list *);
+
+/* supplement routines for configuration */
+static int add_namelist(struct cf_namelist *new, struct cf_namelist **headp)
+{
+	struct cf_namelist *n;
+
+	/* check for duplicated configuration */
+	for (n = *headp; n; n = n->next) {
+		if (strcmp(n->name, new->name) == 0) {
+			bb_info_msg("duplicated name: %s (ignored)",
+			       new->name);
+			cleanup_namelist(new);
+			return (0);
+		}
+	}
+
+	/* insert at first pos */
+	new->next = *headp;
+	*headp = new;
+
+	return (0);
+}
+
+static int add_cfparam(struct cf_list *new, struct cf_namelist *headp)
+{
+	if (headp->params == NULL) {
+		new->tail = new;
+		new->next = NULL;
+		headp->params = new;
+	}
+	else {
+		/* add to the end of list */
+		headp->params->tail->next = new;
+		headp->params->tail = new->tail;
+	}
+	return (0);
+}
+
+static int add_cfsubparam(struct cf_list *new, struct cf_list *parent)
+{
+	if (parent->list == NULL) {
+		new->tail = new;
+		new->next = NULL;
+		parent->list = new;
+	}
+	else {
+		/* add to the end of list */
+		parent->list->tail->next = new;
+		parent->list->tail = new->tail;
+	}
+	return (0);
+}
+
+/* free temporary resources */
+static void cf_cleanup(void)
+{
+	cleanup_namelist(client6_config.iflist_head);
+	client6_config.iflist_head = NULL;
+	cleanup_namelist(client6_config.iapdlist_head);
+	client6_config.iapdlist_head = NULL;
+	cleanup_namelist(client6_config.ianalist_head);
+	client6_config.ianalist_head = NULL;
+	cleanup_namelist(client6_config.authinfolist_head);
+	client6_config.authinfolist_head = NULL;
+	cleanup_namelist(client6_config.keylist_head);
+	client6_config.keylist_head = NULL;
+}
+
+static void cleanup_namelist(struct cf_namelist *head)
+{
+	struct cf_namelist *ifp, *ifp_next;
+
+	for (ifp = head; ifp; ifp = ifp_next) {
+		ifp_next = ifp->next;
+		cleanup_cflist(ifp->params);
+		free(ifp->name);
+		free(ifp);
+	}
+}
+
+static void cleanup_cflist(struct cf_list *p)
+{
+	struct cf_list *n;
+
+	if (p == NULL)
+		return;
+
+	n = p->next;
+	if (p->ptr)
+		free(p->ptr);
+	if (p->list)
+		cleanup_cflist(p->list);
+	free(p);
+
+	cleanup_cflist(n);
+}
+
+struct dhcp_options {
+    const char *optname;
+    int optval;
+    uint16_t paramt; /* 0-none, 1-string, 2-integer */
+};
+
+static const struct dhcp_options dhcp_option_list[] = {
+    { "rapid-commit",             DHCPOPT_RAPID_COMMIT,  0 },
+    { "ia-pd",                    DHCPOPT_IA_PD,         2 },
+    { "ia-na",                    DHCPOPT_IA_NA,         2 },
+    { "domain-name-servers",      DHCPOPT_DNS,           0 },
+    { "domain-name",              DHCPOPT_DNSNAME,       0 },
+    { "sip-server-address",       DHCPOPT_SIP,           0 },
+    { "sip-server-domain-name",   DHCPOPT_SIPNAME,       0 },
+    { "ntp-servers",              DHCPOPT_NTP,           0 },
+    { "nis-server-address",       DHCPOPT_NIS,           0 },
+    { "nis-domain-name",          DHCPOPT_NISNAME,       0 },
+    { "nisp-server-address",      DHCPOPT_NISP,          0 },
+    { "nisp-domain-name",         DHCPOPT_NISPNAME,      0 },
+    { "bcmcs-server-address",     DHCPOPT_BCMCS,         0 },
+    { "bcmcs-server-domain-name", DHCPOPT_BCMCSNAME,     0 },
+    { "authentication",           DHCPOPT_AUTHINFO,      1 },
+};
+
+static int FAST_FUNC create_iface(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_namelist *ifl;
+
+    if (cnt < 2)
+        return (-2);
+
+    MAKE_NAMELIST(ifl, varr[1], NULL);
+
+    if (add_namelist(ifl, &client6_config.iflist_head))
+        return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC create_assoc(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_namelist *ia;
+    const char *id;
+
+    if (cnt < 2)
+	return (-2);
+    if (cnt >=3 && strcmp(varr[2], "{"))
+	id = varr[2];
+    else
+	id = "0";
+
+    MAKE_NAMELIST(ia, id, NULL);
+
+    if (strcasecmp(varr[1], "pd") == 0) {
+	if (add_namelist(ia, &client6_config.iapdlist_head))
+            return (-1);
+    }
+    else if (strcasecmp(varr[1], "na") == 0) {
+	if (add_namelist(ia, &client6_config.ianalist_head))
+            return (-1);
+    }
+    else
+        return (-3);
+
+    return 0;
+}
+
+static int FAST_FUNC parse_iface(int lineno, int kw_ind, char **varr, int cnt)
+{
+    struct cf_list *l;
+    int i, j;
+
+    switch (kw_ind) {
+	case 0: /* send */
+		MAKE_CFLIST(l, DECL_SEND, NULL, NULL);
+		add_cfparam(l, client6_config.iflist_head);
+		break;
+	case 1: /* request */
+		MAKE_CFLIST(l, DECL_REQUEST, NULL, NULL);
+		add_cfparam(l, client6_config.iflist_head);
+		break;
+	case 2: /* script */
+		if (cnt < 2)
+		    return (-2);
+		MAKE_CFLIST(l, DECL_SCRIPT, varr[1], NULL);
+		add_cfparam(l, client6_config.iflist_head);
+		return 0;
+	case 3: /* information-only */
+		MAKE_CFLIST(l, DECL_INFO_ONLY, NULL, NULL);
+		add_cfparam(l, client6_config.iflist_head);
+		return 0;
+	default:
+		return (-1);
+    }
+    /* add params */
+    for (i = 1; i < cnt; i++) {
+
+	for (j = 0; j < ARRAY_SIZE(dhcp_option_list); j++) {
+	    if (strcasecmp(dhcp_option_list[j].optname, varr[i]) == 0) {
+
+		MAKE_CFLIST(l, dhcp_option_list[j].optval, NULL, NULL);
+		if (dhcp_option_list[j].paramt && (i < cnt - 1)) {
+		    switch (dhcp_option_list[j].paramt) {
+		        case 1:
+			    l->ptr = xstrdup(varr[i+1]);
+			    break;
+		        case 2:
+			    l->num = xatou(varr[i+1]);
+			    break;
+		    }
+		    i++;
+		}
+		if (add_cfsubparam(l, client6_config.iflist_head->params->tail))
+		    return (-1);
+		break;
+
+	    }
+	}
+	if (j >= ARRAY_SIZE(dhcp_option_list))
+	    return (-3);
+
+    }
+    return 0;
+}
+
+static int FAST_FUNC create_prefiff(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_list *ifl;
+
+    if (cnt < 2)
+        return (-2);
+
+    MAKE_CFLIST(ifl, IACONF_PIF, varr[1], NULL);
+
+    if (add_cfparam(ifl, client6_config.iapdlist_head))
+        return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC parse_prefiff(int lineno, int kw_ind, char **varr, int cnt)
+{
+    struct cf_list *l;
+
+    if (cnt < 2)
+        return (-2);
+
+    switch (kw_ind) {
+	case 0: /* sla-id */
+		MAKE_CFLIST(l, IFPARAM_SLA_ID, varr[1], NULL);
+		break;
+	case 1: /* sla-len */
+		MAKE_CFLIST(l, IFPARAM_SLA_LEN, varr[1], NULL);
+		break;
+	default:
+		return (-1);
+    }
+    if (add_cfsubparam(l, client6_config.iapdlist_head->params->tail))
+        return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC parse_assoc(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+	struct dhcp6_prefix *pconf;
+
+	if (cnt < 2)
+		return (-2);
+
+	switch (kw_ind) {
+		case 0: /* address */
+			MAKE_CFLIST(l, IACONF_ADDR, NULL, NULL);
+			break;
+		case 1: /* prefix */
+			MAKE_CFLIST(l, IACONF_PREFIX, NULL, NULL);
+			break;
+		default:
+			return (-1);
+	}
+	pconf = xzalloc(sizeof(*pconf));
+	if (inet_pton(AF_INET6, varr[1], &pconf->addr) != 1) {
+		bb_error_msg("invalid IPv6 address: %s", varr[1]);
+                free(pconf);
+                return (-1);
+        }
+	/* validate other parameters later */
+	pconf->plen = 128; /* XXX this field is ignored */
+	if (cnt < 3)
+		pconf->pltime = DHCP6_DURATION_INFINITE;
+	else {
+		pconf->pltime = xatoul(varr[2]);
+		if (cnt < 4)
+			pconf->vltime = DHCP6_DURATION_INFINITE;
+		else
+			pconf->vltime = xatoul(varr[3]);
+	}
+	l->ptr = pconf;
+
+	if (add_cfparam(l, client6_config.authinfolist_head))
+		return (-1);
+
+	return 0;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int FAST_FUNC create_auth(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_namelist *authinfo;
+
+    if (cnt < 2)
+        return (-2);
+
+    MAKE_NAMELIST(authinfo, varr[1], NULL);
+
+    if (add_namelist(authinfo, &client6_config.authinfolist_head))
+	    return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC create_keyinfo(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_namelist *key;
+
+    if (cnt < 2)
+        return (-2);
+
+    MAKE_NAMELIST(key, varr[1], NULL);
+
+    if (add_namelist(key, &client6_config.keylist_head))
+        return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC parse_auth(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return (-2);
+
+	switch (kw_ind) {
+		case 0: /* protocol */
+			MAKE_CFLIST(l, AUTHPARAM_PROTO, NULL, NULL);
+			if (strcasecmp(varr[1], "delayed") == 0)
+				l->num = DHCP6_AUTHPROTO_DELAYED;
+/* server-only
+			else if (strcasecmp(varr[1], "reconfig") == 0)
+				l->num = DHCP6_AUTHPROTO_RECONFIG;
+*/
+			else
+				return (-3);
+			break;
+		case 1: /* algorithm */
+			MAKE_CFLIST(l, AUTHPARAM_ALG, NULL, NULL);
+			if (strcasecmp(varr[1], "hmac-md5") == 0 ||
+			    strcasecmp(varr[1], "hmacmd5") == 0)
+				l->num = DHCP6_AUTHALG_HMACMD5;
+			else
+				return (-3);
+			break;
+		case 2: /* rdm */
+			MAKE_CFLIST(l, AUTHPARAM_RDM, NULL, NULL);
+			if (strcasecmp(varr[1], "monocounter") == 0)
+				l->num = DHCP6_AUTHRDM_MONOCOUNTER;
+			else
+				return (-3);
+			break;
+		default:
+			return (-1);
+	}
+	if (add_cfparam(l, client6_config.authinfolist_head))
+		return (-1);
+
+	return 0;
+}
+
+static int FAST_FUNC parse_keyinfo(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return (-2);
+
+	switch (kw_ind) {
+		case 0: /* realm */
+			MAKE_CFLIST(l, KEYPARAM_REALM, varr[1], NULL);
+			break;
+		case 1: /* keyid */
+			MAKE_CFLIST(l, KEYPARAM_KEYID, NULL, NULL);
+			l->num = xatou(varr[1]);
+			break;
+		case 2: /* secret */
+			MAKE_CFLIST(l, KEYPARAM_SECRET, varr[1], NULL);
+			break;
+		case 3: /* expire */
+			MAKE_CFLIST(l, KEYPARAM_EXPIRE, varr[1], NULL);
+			break;
+		default:
+			return (-1);
+	}
+	if (add_cfparam(l, client6_config.keylist_head))
+		return (-1);
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+struct config_keyword;
+
+struct config_keyword {
+	const char *keyword;
+	const struct config_keyword *next_level;
+
+	int (*handler)(int lineno, int kw_ind, char **varr, int cnt) FAST_FUNC;
+};
+
+static const struct config_keyword interface_kw[] = {
+ { "send",             NULL,          &parse_iface    },
+ { "request",          NULL,          &parse_iface    },
+ { "script",           NULL,          &parse_iface    },
+ { "information-only", NULL,          &parse_iface    },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword prefiff_kw[] = {
+ { "sla-id",           NULL,          &parse_prefiff  },
+ { "sla-len",          NULL,          &parse_prefiff  },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword assoc_kw[] = {
+ { "address",          NULL,          &parse_assoc    },
+ { "prefix",           NULL,          &parse_assoc    },
+ { "prefix-interface", prefiff_kw,    &create_prefiff },
+ { NULL,               NULL,          NULL },
+};
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static const struct config_keyword auth_kw[] = {
+ { "protocol",         NULL,          &parse_auth     },
+ { "algorithm",        NULL,          &parse_auth     },
+ { "rdm",              NULL,          &parse_auth     },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword keyinfo_kw[] = {
+ { "realm",            NULL,          &parse_keyinfo  },
+ { "keyid",            NULL,          &parse_keyinfo  },
+ { "secret",           NULL,          &parse_keyinfo  },
+ { "expire",           NULL,          &parse_keyinfo  },
+ { NULL,               NULL,          NULL },
+};
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static const struct config_keyword level0_kw[] = {
+ { "interface",        interface_kw,  &create_iface   },
+ { "id-assoc",         assoc_kw,      &create_assoc   },
+#if ENABLE_FEATURE_DHCP6_AUTH
+ { "authentication",   auth_kw,       &create_auth    },
+ { "keyinfo",          keyinfo_kw,    &create_keyinfo },
+#endif
+ { NULL,               NULL,          NULL            },
+};
+
+TAILQ_HEAD(keyword6_list, keywords6);
+struct keywords6 {
+        TAILQ_ENTRY(keywords6) link;
+
+	const struct config_keyword *kw;
+};
+
+
+int FAST_FUNC read_config6(const char *file)
+{
+        parser_t *parser;
+	struct keyword6_list kwq_head;
+        struct keywords6 *kl;
+        unsigned i = 0, j, m, n;
+#define MAX_TOKENS	15
+        char *token[MAX_TOKENS];
+        const struct config_keyword *req_next_level = NULL;
+
+	/* cleanup config */
+	client6_config.iflist_head = NULL;
+	TAILQ_INIT(&client6_config.ia_conflist);
+	clear_keys(client6_config.key_list);
+	client6_config.key_list = NULL;
+	clear_authinfo(client6_config.auth_list);
+	client6_config.auth_list = NULL;
+
+	TAILQ_INIT(&kwq_head);
+	kl = xzalloc(sizeof(*kl));
+	kl->kw = level0_kw;
+	TAILQ_INSERT_TAIL(&kwq_head, kl, link);
+	parser = config_open(file);
+	while ((n = config_read(parser, token, MAX_TOKENS, 1, "# \t,", PARSE_NORMAL))) {
+		const struct config_keyword *k;
+		int was_found;
+
+		kl = TAILQ_LAST(&kwq_head, keyword6_list);
+		i = 0;
+restart_scan:
+		if (kl == NULL)
+			goto scan_fail;
+		k = kl->kw;
+		j = 0;
+		was_found = 0;
+		/* Just skip alone ';' */
+	        if (strcmp(token[i], ";") == 0)
+		    i++;
+		while (i < n && k[j].keyword != NULL) {
+		    if (strcasecmp(token[i], k[j].keyword) == 0) {
+			if (k[j].handler != NULL) {
+			    /* scan for ';' statement trailer */
+			    int pos;
+			    for (m = i+1; m < n; m++) {
+				if (strcmp(token[m], "{") == 0 || strcmp(token[m], ";") == 0)
+				    break;
+				pos = strlen(token[m]) - 1;
+				if (token[m][pos] == ';') {
+				    token[m][pos] = '\0';
+				    m++;
+				    break;
+				}
+			    }
+			    if ((*k[j].handler)(parser->lineno, j, &token[i], m-i) < 0)
+				goto scan_fail;
+
+			    i = m;
+			} else
+			    i++;
+			req_next_level = k[j].next_level;
+			was_found = 1;
+			break;
+		    }
+		    j++;
+		}
+		if (i >= n)	// EOL
+		    continue;
+
+		if (req_next_level != NULL) {
+		    if (strcmp(token[i], "{") != 0)
+			goto scan_fail;
+		    kl = xzalloc(sizeof(*kl));
+		    kl->kw = req_next_level;
+		    TAILQ_INSERT_TAIL(&kwq_head, kl, link);
+		    req_next_level = NULL;
+		    if (++i >= n)	// EOL
+		        continue;
+		    goto restart_scan;
+		}
+		if (strncmp(token[i], "}", 1) == 0) {
+		    TAILQ_REMOVE(&kwq_head, kl, link);
+		    free(kl);
+		    kl = TAILQ_LAST(&kwq_head, keyword6_list);
+		    if (++i >= n)	// EOL
+		        continue;
+		    goto restart_scan;
+		}
+		if (was_found)
+		    goto restart_scan;
+
+scan_fail:
+		bb_error_msg("%s: can't parse line %u near token '%s'", file, parser->lineno, token[i]);
+		break;
+	}
+	config_close(parser);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (configure_keys(client6_config.keylist_head))
+		goto cf_fail;
+
+	if (configure_authinfo(client6_config.authinfolist_head))
+		goto cf_fail;
+#endif
+
+	if (configure_ia(client6_config.iapdlist_head, IATYPE_PD))
+		goto cf_fail;
+
+	if (configure_ia(client6_config.ianalist_head, IATYPE_NA))
+		goto cf_fail;
+
+	if (configure_interface(client6_config.iflist_head))
+		goto cf_fail;
+
+	configure_commit();
+	cf_cleanup();
+	return (0);
+
+cf_fail:
+	configure_cleanup();
+	cf_cleanup();
+	return (-1);
+}
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/config6.h busybox/networking/udhcp/config6.h
--- busybox.orig/networking/udhcp/config6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/config6.h	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,309 @@
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "timer.h"
+
+typedef enum { IATYPE_PD, IATYPE_NA } iatype_t;
+
+/* definitions of tail-queue types */
+TAILQ_HEAD(ia_conflist, ia_conf);
+TAILQ_HEAD(pifc_list, prefix_ifconf);
+
+struct dhcp6_poolspec {
+	char* name;
+	uint32_t pltime;
+	uint32_t vltime;
+};
+
+struct dhcp6_range {
+	struct in6_addr min;
+	struct in6_addr max;
+};
+
+struct pool_conf {
+	struct pool_conf *next;
+
+	char* name;
+
+	struct in6_addr min;
+	struct in6_addr max;
+};
+
+/* per-interface information */
+struct dhcp6_if {
+	struct dhcp6_if *next;
+
+	/* timer for the interface */
+	struct dhcp6_timer *timer;
+
+	/* event queue */
+	TAILQ_HEAD(, dhcp6_event) event_list;
+
+	/* static parameters of the interface */
+	char *ifname;
+	unsigned int ifid;
+	uint32_t linkid;	/* to send link-local packets */
+	/* multiple global address configuration is not supported now */
+	struct in6_addr addr; 	/* global address */
+
+	/* configuration parameters */
+	u_long send_flags;
+	u_long allow_flags;
+#define DHCIFF_INFO_ONLY 0x1
+#define DHCIFF_RAPID_COMMIT 0x2
+
+	int server_pref;	/* server preference (server only) */
+	struct dhcp6_poolspec pool;	/* address pool (server only) */
+	char *scriptpath;	/* path to config script (client only) */
+
+	struct dhcp6_list reqopt_list;
+	struct ia_conflist iaconf_list;
+
+	/* authentication information */
+	int authproto;		/* protocol */
+	/* the followings are valid only if authproto is not UNDEF */
+	int authalgorithm;	/* algorithm */
+	int authrdm;		/* replay attack detection method */
+};
+
+/* run-time authentication parameters */
+struct authparam {
+	int authproto;
+	int authalgorithm;
+	int authrdm;
+	struct keyinfo *key;
+	int flags;
+#define AUTHPARAM_FLAGS_NOPREVRD	0x1
+
+	uint64_t prevrd;	/* previous RD value provided by the peer */
+};
+
+struct dhcp6_event {
+	TAILQ_ENTRY(dhcp6_event) link;
+
+	struct dhcp6_if *ifp;
+	struct dhcp6_timer *timer;
+
+	struct duid serverid;
+
+	unsigned long long t_start; /* timestamp(ms) when the 1st msg is sent */
+
+	/* internal timer parameters */
+	unsigned long retrans;
+	unsigned long init_retrans;
+	long max_retrans_cnt;
+	long max_retrans_time;
+	long max_retrans_dur;
+	int timeouts;		/* number of timeouts */
+
+	uint32_t xid;		/* current transaction ID */
+	int state;
+
+	/* list of known servers */
+	struct dhcp6_serverinfo *current_server;
+	struct dhcp6_serverinfo *servers;
+
+	/* authentication parameters */
+	struct authparam *authparam;
+
+	TAILQ_HEAD(, dhcp6_eventdata) data_list;
+};
+
+struct dhcp6_eventdata {
+	TAILQ_ENTRY(dhcp6_eventdata) link;
+
+	struct dhcp6_event *event;
+	iatype_t type;
+	void *data;
+};
+
+struct dhcp6_serverinfo {
+	struct dhcp6_serverinfo *next;
+
+	/* option information provided in the advertisement */
+	struct dhcp6_optinfo optinfo;
+
+	int pref;		/* preference */
+	int active;		/* bool; if this server is active or not */
+
+	struct authparam *authparam; /* authentication parameters */
+
+	/* TODO: remember available information from the server */
+};
+
+/* client status code */
+enum {DHCP6S_INIT, DHCP6S_SOLICIT, DHCP6S_INFOREQ, DHCP6S_REQUEST,
+      DHCP6S_RENEW, DHCP6S_REBIND, DHCP6S_RELEASE, DHCP6S_IDLE};
+
+struct prefix_ifconf {
+	TAILQ_ENTRY(prefix_ifconf) link;
+
+	char *ifname;		/* interface name such as ne0 */
+	int sla_len;		/* SLA ID length in bits */
+	uint32_t sla_id;	/* need more than 32bits? */
+	int ifid_len;		/* interface ID length in bits */
+	int ifid_type;		/* EUI-64 and manual (unused?) */
+	char ifid[16];		/* Interface ID, up to 128bits */
+};
+#define IFID_LEN_DEFAULT 64
+#define SLA_LEN_DEFAULT 16
+
+struct ia_conf {
+	TAILQ_ENTRY(ia_conf) link;
+	/*struct ia_conf *next;*/
+	iatype_t type;
+	uint32_t iaid;
+
+	TAILQ_HEAD(, ia) iadata; /* struct ia is an opaque type */
+
+	/* type dependent values follow */
+};
+
+struct iapd_conf {
+	struct ia_conf iapd_ia;
+
+	/* type dependent values follow */
+	struct dhcp6_list iapd_prefix_list;
+	struct pifc_list iapd_pif_list;
+};
+#define iapd_next iapd_ia.next
+#define iapd_type iapd_ia.type
+#define iapd_id iapd_ia.iaid
+
+struct iana_conf {
+	struct ia_conf iana_ia;
+
+	/* type dependent values follow */
+	struct dhcp6_list iana_address_list;
+};
+#define iana_next iana_ia.next
+
+/* per-host configuration */
+struct host_conf {
+	struct host_conf *next;
+
+	char *name;		/* host name to identify the host */
+	struct duid duid;	/* DUID for the host */
+
+	/* prefixes to be delegated to the host */
+	struct dhcp6_list prefix_list;
+	/* address to be assigned for the host */
+	struct dhcp6_list addr_list;
+	/* address pool from which addresses are assigned for the host */
+	struct dhcp6_poolspec pool;
+
+	/* secret key shared with the client for delayed authentication */
+	struct keyinfo *delayedkey;
+	/* previous replay detection value from the client */
+	int saw_previous_rd;	/* if we remember the previous value */
+	uint64_t previous_rd;
+};
+
+/* DHCPv6 authentication information */
+struct authinfo {
+	struct authinfo *next;
+
+	char *name;		/* auth info name */
+
+	int protocol;		/* authentication protocol */
+	int algorithm;		/* authentication algorithm */
+	int rdm;		/* random attack detection method */
+
+	/* keys specific to this info? */
+};
+
+/* structures and definitions used in the config file parser */
+struct cf_namelist {
+	struct cf_namelist *next;
+	char *name;
+	int line;		/* the line number of the config file */
+	struct cf_list *params;
+};
+
+struct cf_list {
+	struct cf_list *next;
+	struct cf_list *tail;
+	int type;
+	int line;		/* the line number of the config file */
+
+	/* type dependent values: */
+	long long num;
+	struct cf_list *list;
+	void *ptr;
+};
+
+struct client6_config_t {
+	const char *conffile;
+
+	struct dhcp6_if *dhcp6c_if;
+
+	struct dhcp6_ifconf *dhcp6_ifconflist;
+	struct ia_conflist ia_conflist;
+	struct keyinfo *key_list;
+	struct authinfo *auth_list;
+
+	struct cf_namelist *iflist_head, *iapdlist_head, *ianalist_head;
+	struct cf_namelist *authinfolist_head, *keylist_head;
+
+	LIST_HEAD(, dhcp6_timer) timer_head;
+	unsigned long long tm_sentinel;
+	struct timeval tm_check;
+};
+
+#define client6_config (*(struct client6_config_t*)(&bb_common_bufsiz1))
+
+enum { DECL_SEND, DECL_ALLOW, DECL_INFO_ONLY, DECL_REQUEST, DECL_DUID,
+       DECL_PREFIX, DECL_PREFERENCE, DECL_SCRIPT, DECL_DELAYEDKEY,
+       DECL_ADDRESS,
+       DECL_RANGE, DECL_ADDRESSPOOL,
+       IFPARAM_SLA_ID, IFPARAM_SLA_LEN,
+       DHCPOPT_RAPID_COMMIT, DHCPOPT_AUTHINFO,
+       DHCPOPT_DNS, DHCPOPT_DNSNAME,
+       DHCPOPT_IA_PD, DHCPOPT_IA_NA, DHCPOPT_NTP,
+       DHCPOPT_REFRESHTIME,
+       DHCPOPT_NIS, DHCPOPT_NISNAME, 
+       DHCPOPT_NISP, DHCPOPT_NISPNAME, 
+       DHCPOPT_BCMCS, DHCPOPT_BCMCSNAME, 
+       CFLISTENT_GENERIC,
+       IACONF_PIF, IACONF_PREFIX, IACONF_ADDR,
+       DHCPOPT_SIP, DHCPOPT_SIPNAME,
+       AUTHPARAM_PROTO, AUTHPARAM_ALG, AUTHPARAM_RDM, AUTHPARAM_KEY,
+       KEYPARAM_REALM, KEYPARAM_KEYID, KEYPARAM_SECRET, KEYPARAM_EXPIRE };
+
+
+struct dhcp6_if *if6init(char *);
+int ifreset(struct dhcp6_if *);
+
+struct dhcp6_if *find_ifconf_byid(unsigned int );
+struct prefix_ifconf *find_prefixifconf(char *);
+struct dhcp6_prefix *find_prefix6(struct dhcp6_list *, struct dhcp6_prefix *);
+struct ia_conf *find_iaconf(struct ia_conflist *, int, uint32_t);
+struct keyinfo *find_key(char *, size_t, uint32_t);
+
+int FAST_FUNC read_config6(const char *file);
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/Config.src busybox/networking/udhcp/Config.src
--- busybox.orig/networking/udhcp/Config.src	2011-01-16 21:19:55.000000000 +0300
+++ busybox/networking/udhcp/Config.src	2011-02-07 19:49:21.000000000 +0300
@@ -82,7 +82,7 @@ config UDHCP_DEBUG
 	int "Maximum verbosity level for udhcp applets (0..9)"
 	default 9
 	range 0 9
-	depends on UDHCPD || UDHCPC || DHCPRELAY
+	depends on UDHCPD || UDHCPC || DHCPRELAY || DHCP6C || DHCP6RELAY
 	help
 	  Verbosity can be increased with multiple -v options.
 	  This option controls how high it can be cranked up.
@@ -130,3 +130,27 @@ config UDHCPC_SLACK_FOR_BUGGY_SERVERS
 	    maximum size of entire IP packet, and sends packets which are
 	    28 bytes too large.
 	  Seednet (ISP) VDSL: sends packets 2 bytes too large.
+
+config DHCP6C
+	bool "DHCPv6 client daemon (dhcp6c)"
+	default n
+	depends on PLATFORM_LINUX && FEATURE_IPV6
+	help
+	  dhcp6c is a DHCPv6 client geared primarily toward embedded systems,
+	  while striving to be fully functional and RFC compliant.
+
+config FEATURE_DHCP6_AUTH
+	bool "Support DHCPv6 messages authentication"
+	default n
+	depends on DHCP6C
+	help
+	  If selected, client will support DHCPv6 messages authentication,
+	  currently HMAC-MD5 only.
+
+config DHCP6RELAY
+	bool "dhcp6relay"
+	default n
+	depends on FEATURE_IPV6 && DHCP6C
+	help
+	  dhcp6relay listens for DHCPv6 requests on one or more interfaces
+	  and forwards these requests to a different interface.
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/dhcp6c.c busybox/networking/udhcp/dhcp6c.c
--- busybox.orig/networking/udhcp/dhcp6c.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c.c	2011-02-07 22:32:18.000000000 +0300
@@ -0,0 +1,1659 @@
+/*
+ * DHCPv6 client
+ *
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Original code taken from wide-dhcpv6-20080615 and converted into
+ * a busybox applet by Leonid Lisovskiy <lly@sf.net>
+ */
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/queue.h>
+#include <errno.h>
+#include <limits.h>
+#include <net/if.h>
+#ifdef __FreeBSD__
+#include <net/if_var.h>
+#endif
+
+#include <netinet/in.h>
+
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <err.h>
+#include <ifaddrs.h>
+
+/* Override ENABLE_FEATURE_PIDFILE */
+#define WANT_PIDFILE 1
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "dhcp6c.h"
+#include "dhcp6c_ia.h"
+#include "auth6.h"
+
+#define DHCP6C_CONF     "/etc/dhcp6c.conf"
+#define DHCP6C_PIDFILE  "/var/run/dhcp6c.pid"
+#define DUID_FILE       "/var/state/dhcp6c_duid"
+
+struct globals {
+	struct sockaddr_in6 sa6_allagent;
+
+	const char *pid_file;
+
+	int csock;	/* inbound/outbound udp port */
+	int rtsock;	/* routing socket */
+
+	char rbuf[BUFSIZ], sbuf[BUFSIZ], cmsgbuf[BUFSIZ];
+
+	struct duid client_duid;
+	int duid_type;
+};
+
+#define G (*ptr_to_globals)
+#define csock		(G.csock        )
+#define rtsock		(G.rtsock       )
+#define client_duid	(G.client_duid  )
+#define duid_type	(G.duid_type    )
+#define INIT_G() do { \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+	G.pid_file = DHCP6C_PIDFILE; \
+	duid_type = 1; \
+} while (0)
+
+
+static inline int get_val32(char **, int *, uint32_t *);
+static inline int get_ifname(char **, int *, char *, int);
+
+static void client6_init(void);
+static void client6_startall(int);
+static void free_resources(struct dhcp6_if *);
+static void client6_mainloop(void);
+static void check_exit(void);
+static struct dhcp6_serverinfo *find_server(struct dhcp6_event *,
+						 struct duid *);
+static struct dhcp6_serverinfo *select_server(struct dhcp6_event *);
+static void client6_recv(void);
+static int client6_recvadvert(struct dhcp6_if *, struct dhcp6 *,
+				   ssize_t, struct dhcp6_optinfo *);
+static int client6_recvreply(struct dhcp6_if *, struct dhcp6 *,
+				  ssize_t, struct dhcp6_optinfo *);
+static struct dhcp6_event *find_event_withid(struct dhcp6_if *,
+						  uint32_t);
+static int construct_confdata(struct dhcp6_if *, struct dhcp6_event *);
+static int construct_reqdata(struct dhcp6_if *, struct dhcp6_optinfo *,
+    struct dhcp6_event *);
+static struct dhcp6_timer *client6_expire_refreshtime(void *);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int process_auth(struct authparam *, struct dhcp6 *dh6, ssize_t,
+    struct dhcp6_optinfo *);
+static int set_auth(struct dhcp6_event *, struct dhcp6_optinfo *);
+#endif
+
+#define MAX_ELAPSED_TIME 0xffff
+
+//usage:#define dhcp6c_trivial_usage
+//usage:       "[-vfi] [-c FILE] [-D LL|LLT] [-p FILE] interface [interfaces...]"
+//usage:#define dhcp6c_full_usage "\n"
+//usage:      "\n	-v         Print debugging messages(may be repeated)"
+//usage:      "\n	-f         Foreground mode"
+//usage:      "\n	-i         Info-req(information-only) mode"
+//usage:      "\n	-c FILE    Use FILE as the configuration file"
+//usage:      "\n	-D LL|LLT  Use LL or LLT to override default(LLT) DUID type generation"
+//usage:      "\n	-p FILE    Use FILE to dump the process ID of dhcp6c"
+
+enum {
+        OPT_FOREGROUND = 1 << 0,
+        OPT_i = 1 << 1,
+        OPT_c = 1 << 2,
+        OPT_D = 1 << 3,
+        OPT_p = 1 << 4,
+        OPT_VERBOSE = 1 << 5,
+};
+
+int dhcp6c_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int dhcp6c_main(int argc, char **argv)
+{
+	int opt;
+	const char *str_D;
+	struct dhcp6_if *ifp;
+
+	INIT_G();
+	client6_config.conffile = DHCP6C_CONF;
+
+#ifndef HAVE_ARC4RANDOM
+	srandom(time(NULL) & getpid());
+#endif
+
+	opt_complementary = ""
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+		":vv"
+#endif
+		;
+
+	opt = getopt32(argv, "fic:D:p:v",
+			&client6_config.conffile, &str_D, &G.pid_file
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+			,&dhcp_verbose
+#endif
+			);
+	if (opt & OPT_D) {
+		if (!strcasecmp(str_D, "LL"))
+			duid_type = 3;
+		else if (!strcasecmp(str_D, "LLT"))
+			duid_type = 1;
+	}
+
+	argv += optind;
+	argc -= optind;
+	if (argc < 1)
+		bb_show_usage();
+
+	if (!(opt & OPT_FOREGROUND) && !(opt & OPT_i)) {
+		bb_daemonize_or_rexec(DAEMON_CLOSE_EXTRA_FDS, argv);
+		openlog(applet_name, LOG_PID, LOG_DAEMON);
+		logmode = LOGMODE_SYSLOG;
+	}
+
+	client6_init();
+	while (*argv) { 
+		if ((ifp = if6init(*argv)) == NULL) {
+			bb_error_msg_and_die("failed to initialize %s", *argv);
+		}
+		argv++;
+	}
+
+	if (!(opt & OPT_i) && (read_config6(client6_config.conffile)) != 0) {
+		bb_error_msg_and_die("failed to parse configuration file");
+	}
+
+	/* dump current PID */
+	write_pidfile(G.pid_file);
+
+	client6_startall(0);
+	bb_info_msg("started");
+	client6_mainloop();
+	return (0);
+}
+
+
+/*------------------------------------------------------------*/
+
+void client6_init(void)
+{
+	struct addrinfo hints, *res;
+	int error, on = 1;
+
+	/* get our DUID */
+	if (get_duid(DUID_FILE, &client_duid, duid_type)) {
+		bb_error_msg_and_die("failed to get a DUID");
+	}
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(NULL, DH6PORT_DOWNSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	csock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+	if (csock < 0) {
+		bb_error_msg_and_die("socket(csock): %s", strerror(errno));
+	}
+	if (setsockopt(csock, SOL_SOCKET, SO_REUSEPORT,
+		       &on, sizeof(on)) < 0) {
+		bb_error_msg_and_die("setsockopt(SO_REUSEPORT): %s", strerror(errno));
+	}
+#ifdef IPV6_RECVPKTINFO
+	if (setsockopt(csock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
+		       sizeof(on)) < 0) {
+		bb_error_msg_and_die("setsockopt(IPV6_RECVPKTINFO): %s",
+			strerror(errno));
+	}
+#else
+	if (setsockopt(csock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
+		       sizeof(on)) < 0) {
+		bb_error_msg_and_die("setsockopt(IPV6_PKTINFO): %s",
+			strerror(errno));
+	}
+#endif
+	if (setsockopt(csock, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &on,
+		       sizeof(on)) < 0) {
+		bb_error_msg_and_die("setsockopt(IPV6_MULTICAST_LOOP): %s",
+		    strerror(errno));
+	}
+#ifdef IPV6_V6ONLY
+	if (setsockopt(csock, IPPROTO_IPV6, IPV6_V6ONLY,
+	    &on, sizeof(on)) < 0) {
+		bb_error_msg_and_die("setsockopt(IPV6_V6ONLY): %s",
+		    strerror(errno));
+	}
+#endif
+
+	/*
+	 * According RFC3315 2.2, only the incoming port should be bound to UDP
+	 * port 546.  However, to have an interoperability with some servers,
+	 * the outgoing port is also bound to the DH6PORT_DOWNSTREAM.
+	 */
+	if (bind(csock, res->ai_addr, res->ai_addrlen) < 0) {
+		bb_error_msg_and_die("bind: %s", strerror(errno));
+	}
+	freeaddrinfo(res);
+
+	/* open a routing socket to watch the routing table */
+	if ((rtsock = socket(PF_ROUTE, SOCK_RAW, 0)) < 0) {
+		bb_error_msg_and_die("open a routing socket: %s",
+		    strerror(errno));
+	}
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	error = getaddrinfo(DH6ADDR_ALLAGENT, DH6PORT_UPSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s",
+		    gai_strerror(error));
+	}
+	memcpy(&G.sa6_allagent, res->ai_addr, res->ai_addrlen);
+	freeaddrinfo(res);
+
+	bb_signals(0 + (1 << SIGHUP) + (1 << SIGTERM) + (1 << SIGQUIT),
+		  record_signo);
+}
+
+int client6_start(struct dhcp6_if *ifp)
+{
+	struct dhcp6_event *ev;
+
+	/* make sure that the interface does not have a timer */
+	if (ifp->timer)
+		dhcp6_timer_remove(&ifp->timer);
+
+	/* create an event for the initial delay */
+	ev = dhcp6_create_event(ifp, DHCP6S_INIT);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	ev->authparam = new_authparam(ifp->authproto,
+	    ifp->authalgorithm, ifp->authrdm);
+#endif
+
+	dhcp6_reset_timer(ev);
+
+	return (0);
+}
+
+static void client6_startall(int isrestart)
+{
+	struct dhcp6_if *ifp;
+
+	if (isrestart) {
+		/* reload the configuration file */
+		if (read_config6(client6_config.conffile))
+			bb_error_msg_and_die("failed to parse configuration file");
+	}
+
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		if (isrestart &&ifreset(ifp)) {
+			bb_info_msg("failed to reset %s", ifp->ifname);
+			continue; /* XXX: try to recover? */
+		}
+		if (client6_start(ifp))
+			exit(1); /* initialization failure.  we give up. */
+	}
+}
+
+static void free_resources(struct dhcp6_if *freeifp)
+{
+	struct dhcp6_if *ifp;
+
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		struct dhcp6_event *ev, *ev_next;
+
+		if (freeifp != NULL && freeifp != ifp)
+			continue;
+
+		/* release all IAs as well as send RELEASE message(s) */
+		release_all_ia(ifp);
+
+		/*
+		 * Cancel all outstanding events for each interface except
+		 * ones being released.
+		 */
+		for (ev = TAILQ_FIRST(&ifp->event_list); ev; ev = ev_next) {
+			ev_next = TAILQ_NEXT(ev, link);
+
+			if (ev->state == DHCP6S_RELEASE)
+				continue; /* keep it for now */
+
+			dhcp6_remove_event(ev);
+		}
+	}
+}
+
+static void check_exit(void)
+{
+	struct dhcp6_if *ifp;
+
+	if (!bb_got_signal)
+		return;
+
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		/*
+		 * Check if we have an outstanding event.  If we do, we cannot
+		 * exit for now.
+		 */
+		if (!TAILQ_EMPTY(&ifp->event_list))
+			return;
+	}
+
+	/* We have no existing event.  Do exit. */
+	bb_info_msg("exiting");
+	free_resources(NULL);
+	remove_pidfile(G.pid_file);
+
+	exit(0);
+}
+
+static void client6_mainloop(void)
+{
+	struct timeval *w;
+	int ret, maxsock;
+	fd_set r;
+
+	while (1) {
+		if (bb_got_signal) {
+			switch (bb_got_signal) {
+			case SIGQUIT:
+			case SIGTERM:
+				check_exit();
+				break;
+			case SIGHUP:
+				bb_info_msg("restarting");
+				bb_got_signal = 0;
+				free_resources(NULL);
+				client6_startall(1);
+				break;
+			}
+		}
+
+		w = dhcp6_timer_check();
+
+		FD_ZERO(&r);
+		FD_SET(csock, &r);
+		maxsock = csock;
+
+		ret = select(maxsock + 1, &r, NULL, NULL, w);
+
+		switch (ret) {
+		case -1:
+			if (errno != EINTR) {
+				bb_error_msg_and_die("select: %s",
+				    strerror(errno));
+			}
+			continue;
+		case 0:	/* timeout */
+			break;	/* dhcp6_timer_check() will treat the case */
+		default:
+			break;
+		}
+		if (FD_ISSET(csock, &r))
+			client6_recv();
+	}
+}
+
+static inline int get_val32(char **bpp, int *lenp, uint32_t *valp)
+{
+	char *bp = *bpp;
+	int len = *lenp;
+	uint32_t i32;
+
+	if (len < sizeof(*valp))
+		return (-1);
+
+	memcpy(&i32, bp, sizeof(i32));
+	*valp = ntohl(i32);
+
+	*bpp = bp + sizeof(*valp);
+	*lenp = len - sizeof(*valp);
+
+	return (0);
+}
+
+static inline int get_ifname(char **bpp, int *lenp, char *ifbuf, int ifbuflen)
+{
+	char *bp = *bpp;
+	int len = *lenp, ifnamelen;
+	uint32_t i32;
+
+	if (get_val32(bpp, lenp, &i32))
+		return (-1);
+	ifnamelen = (int)i32;
+
+	if (*lenp < ifnamelen || ifnamelen > ifbuflen)
+		return (-1);
+
+	memset(ifbuf, 0, sizeof(ifbuf));
+	memcpy(ifbuf, *bpp, ifnamelen);
+	if (ifbuf[ifbuflen - 1] != '\0')
+		return (-1);	/* not null terminated */
+
+	*bpp = bp + sizeof(i32) + ifnamelen;
+	*lenp = len - (sizeof(i32) + ifnamelen);
+
+	return (0);
+}
+
+static struct dhcp6_timer *client6_expire_refreshtime(void *arg)
+{
+	struct dhcp6_if *ifp = (struct dhcp6_if *)arg;
+
+	log1("information refresh time on %s expired", ifp->ifname);
+
+	dhcp6_timer_remove(&ifp->timer);
+	client6_start(ifp);
+
+	return (NULL);
+}
+
+struct dhcp6_timer *client6_timo(void *arg)
+{
+	struct dhcp6_event *ev = (struct dhcp6_event *)arg;
+	struct dhcp6_if *ifp;
+	int state = ev->state;
+
+	ifp = ev->ifp;
+	ev->timeouts++;
+
+	/*
+	 * Unless MRC is zero, the message exchange fails once the client has
+	 * transmitted the message MRC times.
+	 * [RFC3315 14.]
+	 */
+	if (ev->max_retrans_cnt && ev->timeouts >= ev->max_retrans_cnt) {
+		bb_info_msg("no responses were received");
+		dhcp6_remove_event(ev);
+
+		if (state == DHCP6S_RELEASE)
+			check_exit();
+
+		return (NULL);
+	}
+
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		ev->timeouts = 0; /* indicate to generate a new XID. */
+		if ((ifp->send_flags & DHCIFF_INFO_ONLY) || (option_mask32 & OPT_i))
+			ev->state = DHCP6S_INFOREQ;
+		else {
+			ev->state = DHCP6S_SOLICIT;
+			if (construct_confdata(ifp, ev)) {
+				bb_error_msg_and_die("can't send solicit"); /* XXX */
+			}
+		}
+		dhcp6_set_timeoparam(ev); /* XXX */
+		/* fall through */
+	case DHCP6S_REQUEST:
+	case DHCP6S_RELEASE:
+	case DHCP6S_INFOREQ:
+		client6_send(ev);
+		break;
+	case DHCP6S_RENEW:
+	case DHCP6S_REBIND:
+		if (!TAILQ_EMPTY(&ev->data_list))
+			client6_send(ev);
+		else {
+			bb_info_msg("all information to be updated was canceled");
+			dhcp6_remove_event(ev);
+			return (NULL);
+		}
+		break;
+	case DHCP6S_SOLICIT:
+		if (ev->servers) {
+			/*
+			 * Send a Request to the best server.
+			 * Note that when we set Rapid-commit in Solicit,
+			 * but a direct Reply has been delayed (very much),
+			 * the transition to DHCP6S_REQUEST (and the change of
+			 * transaction ID) will invalidate the reply even if it
+			 * ever arrives.
+			 */
+			ev->current_server = select_server(ev);
+			if (ev->current_server == NULL) {
+				/* this should not happen! */
+				bb_error_msg_and_die("can't find a server");
+			}
+			if (duidcpy(&ev->serverid,
+			    &ev->current_server->optinfo.serverID))
+				return (NULL); /* XXX: better recovery? */
+			ev->timeouts = 0;
+			ev->state = DHCP6S_REQUEST;
+			dhcp6_set_timeoparam(ev);
+
+			if (ev->authparam != NULL)
+				free(ev->authparam);
+			ev->authparam = ev->current_server->authparam;
+			ev->current_server->authparam = NULL;
+
+			if (construct_reqdata(ifp,
+			    &ev->current_server->optinfo, ev)) {
+				bb_info_msg("failed to construct request data");
+				break;
+			}
+		}
+		client6_send(ev);
+		break;
+	}
+
+	dhcp6_reset_timer(ev);
+
+	return (ev->timer);
+}
+
+static int construct_confdata(struct dhcp6_if *ifp, struct dhcp6_event *ev)
+{
+	struct ia_conf *iac;
+	struct dhcp6_eventdata *evd = NULL;
+	struct dhcp6_list *ial = NULL, pl;
+	struct dhcp6_ia iaparam;
+
+	TAILQ_INIT(&pl);	/* for safety */
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		/* ignore IA config currently used */
+		if (!TAILQ_EMPTY(&iac->iadata))
+			continue;
+
+		evd = xzalloc(sizeof(*evd));
+
+		memset(&iaparam, 0, sizeof(iaparam));
+		iaparam.iaid = iac->iaid;
+		ial = xmalloc(sizeof(*ial));
+		TAILQ_INIT(ial);
+
+		TAILQ_INIT(&pl);
+
+		switch (iac->type) {
+		case IATYPE_PD:
+			dhcp6_copy_list(&pl,
+			    &((struct iapd_conf *)iac)->iapd_prefix_list);
+			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IAPD,
+			    &iaparam, &pl) == NULL) {
+				goto fail;
+			}
+			break;
+		case IATYPE_NA:
+			dhcp6_copy_list(&pl,
+			    &((struct iana_conf *)iac)->iana_address_list);
+			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IANA,
+			    &iaparam, &pl) == NULL) {
+				goto fail;
+			}
+			break;
+		default:
+			bb_error_msg_and_die("internal error");
+		}
+
+		dhcp6_clear_list(&pl);
+
+		evd->type = iac->type;
+		evd->data = ial;
+		evd->event = ev;
+		TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+	}
+
+	return (0);
+
+  fail:
+	if (evd)
+		free(evd);
+	if (ial)
+		free(ial);
+	dhcp6_remove_event(ev);	/* XXX */
+
+	return (-1);
+}
+
+static int construct_reqdata(struct dhcp6_if *ifp, struct dhcp6_optinfo *optinfo,
+		  struct dhcp6_event *ev)
+{
+	struct ia_conf *iac;
+	struct dhcp6_eventdata *evd = NULL;
+	struct dhcp6_list *ial = NULL;
+	struct dhcp6_ia iaparam;
+
+	/* discard previous event data */
+	dhcp6_remove_evdata(ev);
+
+	if (optinfo == NULL)
+		return (0);
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		struct dhcp6_listval *v;
+
+		/* ignore IA config currently used */
+		if (!TAILQ_EMPTY(&iac->iadata))
+			continue;
+
+		memset(&iaparam, 0, sizeof(iaparam));
+		iaparam.iaid = iac->iaid;
+
+		switch (iac->type) {
+		case IATYPE_PD:
+			if ((v = dhcp6_find_listval(&optinfo->iapd_list,
+			    DHCP6_LISTVAL_IAPD, &iaparam, 0)) == NULL)
+				continue;
+
+			ial = xmalloc(sizeof(*ial));
+			TAILQ_INIT(ial);
+
+			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IAPD,
+			    &iaparam, &v->sublist) == NULL) {
+				goto fail;
+			}
+			break;
+		case IATYPE_NA:
+			if ((v = dhcp6_find_listval(&optinfo->iana_list,
+			    DHCP6_LISTVAL_IANA, &iaparam, 0)) == NULL)
+				continue;
+
+			ial = xmalloc(sizeof(*ial));
+			TAILQ_INIT(ial);
+
+			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IANA,
+			    &iaparam, &v->sublist) == NULL) {
+				goto fail;
+			}
+			break;
+		default:
+			bb_error_msg_and_die("internal error");
+		}
+
+		evd = xzalloc(sizeof(*evd));
+		evd->type = iac->type;
+		evd->data = ial;
+		evd->event = ev;
+		TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+	}
+
+	return (0);
+
+  fail:
+	if (evd)
+		free(evd);
+	if (ial)
+		free(ial);
+	dhcp6_remove_event(ev);	/* XXX */
+
+	return (-1);
+}
+
+static struct dhcp6_serverinfo *select_server(struct dhcp6_event *ev)
+{
+	struct dhcp6_serverinfo *s;
+
+	/*
+	 * pick the best server according to RFC3315 Section 17.1.3.
+	 * XXX: we currently just choose the one that is active and has the
+	 * highest preference.
+	 */
+	s = ev->servers;
+	while (s) {
+		if (s->active) {
+			log1("picked a server (ID: %s)",
+			    duidstr(&s->optinfo.serverID));
+			return (s);
+		}
+		s = s->next;
+	}
+
+	return (NULL);
+}
+
+void client6_send(struct dhcp6_event *ev)
+{
+	struct dhcp6_if *ifp;
+	struct sockaddr_in6 dst;
+	struct dhcp6 *dh6;
+	struct dhcp6_optinfo optinfo;
+	ssize_t optlen, len;
+	struct dhcp6_list *dstlist;
+	struct dhcp6_eventdata *evd;
+
+	ifp = ev->ifp;
+
+	dh6 = (struct dhcp6 *)G.sbuf;
+	memset(dh6, 0, sizeof(*dh6));
+
+	switch (ev->state) {
+	case DHCP6S_SOLICIT:
+		dh6->dh6_msgtype = DH6_SOLICIT;
+		break;
+	case DHCP6S_REQUEST:
+		dh6->dh6_msgtype = DH6_REQUEST;
+		break;
+	case DHCP6S_RENEW:
+		dh6->dh6_msgtype = DH6_RENEW;
+		break;
+	case DHCP6S_REBIND:
+		dh6->dh6_msgtype = DH6_REBIND;
+		break;
+	case DHCP6S_RELEASE:
+		dh6->dh6_msgtype = DH6_RELEASE;
+		break;
+	case DHCP6S_INFOREQ:
+		dh6->dh6_msgtype = DH6_INFORM_REQ;
+		break;
+	default:
+		bb_error_msg_and_die("unexpected state");
+	}
+
+	if (ev->timeouts == 0) {
+		/*
+		 * A client SHOULD generate a random number that cannot easily
+		 * be guessed or predicted to use as the transaction ID for
+		 * each new message it sends.
+		 *
+		 * A client MUST leave the transaction-ID unchanged in
+		 * retransmissions of a message. [RFC3315 15.1]
+		 */
+#ifdef HAVE_ARC4RANDOM
+		ev->xid = arc4random() & DH6_XIDMASK;
+#else
+		ev->xid = random() & DH6_XIDMASK;
+#endif
+		log1("a new XID (%x) is generated",
+		    ev->xid);
+	}
+	dh6->dh6_xid &= ~ntohl(DH6_XIDMASK);
+	dh6->dh6_xid |= htonl(ev->xid);
+	len = sizeof(*dh6);
+
+	/*
+	 * construct options
+	 */
+	dhcp6_init_options(&optinfo);
+
+	/* server ID */
+	switch (ev->state) {
+	case DHCP6S_REQUEST:
+	case DHCP6S_RENEW:
+	case DHCP6S_RELEASE:
+		if (duidcpy(&optinfo.serverID, &ev->serverid))
+			goto end;
+		break;
+	}
+
+	/* client ID */
+	if (duidcpy(&optinfo.clientID, &client_duid))
+		goto end;
+
+	/* rapid commit (in Solicit only) */
+	if (ev->state == DHCP6S_SOLICIT &&
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT)) {
+		optinfo.rapidcommit = 1;
+	}
+
+	/* elapsed time */
+	if (ev->timeouts == 0) {
+		ev->t_start = monotonic_ms();
+		optinfo.elapsed_time = 0;
+	} else {
+		long long t_diff;
+		long et;
+
+		t_diff = monotonic_ms() - ev->t_start;
+
+		/*
+		 * The client uses the value 0xffff to represent any elapsed
+		 * time values greater than the largest time value that can be
+		 * represented in the Elapsed Time option (hundredths of a second).
+		 * [RFC3315 22.9.]
+		 */
+		if (t_diff >= (MAX_ELAPSED_TIME + 100LL) * 10LL) {
+			/*
+			 * Perhaps we are nervous too much, but without this
+			 * additional check, we would see an overflow in 248
+			 * days (of no responses). 
+			 */
+			et = MAX_ELAPSED_TIME;
+		} else {
+			et = t_diff / 10LL;
+			if (et >= MAX_ELAPSED_TIME)
+				et = MAX_ELAPSED_TIME;
+		}
+		optinfo.elapsed_time = (int32_t )et;
+	}
+
+	/* option request options */
+	if (ev->state != DHCP6S_RELEASE &&
+	    dhcp6_copy_list(&optinfo.reqopt_list, &ifp->reqopt_list)) {
+		bb_error_msg("failed to copy requested options");
+		goto end;
+	}
+
+	/* configuration information specified as event data */
+	evd = TAILQ_FIRST(&ev->data_list);
+	while (evd) {
+		switch (evd->type) {
+		case IATYPE_PD:
+			dstlist = &optinfo.iapd_list;
+			break;
+		case IATYPE_NA:
+			dstlist = &optinfo.iana_list;
+			break;
+		default:
+			bb_error_msg_and_die("unexpected event data (%d)",
+			    evd->type);
+		}
+		if (dhcp6_copy_list(dstlist, (struct dhcp6_list *)evd->data)) {
+			bb_info_msg("failed to add an IANA");
+			goto end;
+		}
+		evd = TAILQ_NEXT(evd, link);
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* authentication information */
+	if (set_auth(ev, &optinfo)) {
+		goto end;
+	}
+#endif
+
+	/* set options in the message */
+	if ((optlen = dhcp6_set_options(dh6->dh6_msgtype,
+	    (struct dhcp6opt *)(dh6 + 1),
+	    (struct dhcp6opt *)(G.sbuf + sizeof(G.sbuf)), &optinfo)) < 0) {
+		bb_info_msg("failed to construct options");
+		goto end;
+	}
+	len += optlen;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* calculate MAC if necessary, and put it to the message */
+	if (ev->authparam != NULL) {
+		switch (ev->authparam->authproto) {
+		case DHCP6_AUTHPROTO_DELAYED:
+			if (ev->authparam->key == NULL)
+				break;
+
+			if (dhcp6_calc_mac((char *)dh6, len,
+			    optinfo.authproto, optinfo.authalgorithm,
+			    optinfo.delayedauth_offset + sizeof(*dh6),
+			    ev->authparam->key)) {
+				bb_error_msg(
+				    "failed to calculate MAC");
+				goto end;
+			}
+			break;
+		default:
+			break;	/* do nothing */
+		}
+	}
+#endif
+
+	/*
+	 * Unless otherwise specified in this document or in a document that
+	 * describes how IPv6 is carried over a specific type of link (for link
+	 * types that do not support multicast), a client sends DHCP messages
+	 * to the All_DHCP_Relay_Agents_and_Servers.
+	 * [RFC3315 Section 13.]
+	 */
+	dst = G.sa6_allagent;
+	dst.sin6_scope_id = ifp->linkid;
+
+	if (sendto(csock, G.sbuf, len, 0, (struct sockaddr *)&dst,
+	    sysdep_sa_len((struct sockaddr *)&dst)) == -1) {
+		bb_error_msg("transmit failed: %s", strerror(errno));
+		goto end;
+	}
+
+	log1("send %s to %s", dhcp6msgstr(dh6->dh6_msgtype),
+	    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&dst));
+
+  end:
+	dhcp6_clear_options(&optinfo);
+	return;
+}
+
+static void client6_recv(void)
+{
+	struct msghdr mhdr;
+	struct iovec iov;
+	struct sockaddr_storage from;
+	struct dhcp6_if *ifp;
+	struct dhcp6opt *p, *ep;
+	struct dhcp6_optinfo optinfo;
+	ssize_t len;
+	struct dhcp6 *dh6;
+	struct cmsghdr *cm;
+	struct in6_pktinfo *pi = NULL;
+
+	memset(&iov, 0, sizeof(iov));
+	memset(&mhdr, 0, sizeof(mhdr));
+
+	iov.iov_base = (caddr_t)G.rbuf;
+	iov.iov_len = sizeof(G.rbuf);
+	mhdr.msg_name = (caddr_t)&from;
+	mhdr.msg_namelen = sizeof(from);
+	mhdr.msg_iov = &iov;
+	mhdr.msg_iovlen = 1;
+	mhdr.msg_control = (caddr_t)G.cmsgbuf;
+	mhdr.msg_controllen = sizeof(G.cmsgbuf);
+	if ((len = recvmsg(csock, &mhdr, 0)) < 0) {
+		bb_error_msg("recvmsg: %s", strerror(errno));
+		return;
+	}
+
+	/* detect receiving interface */
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&mhdr); cm;
+	     cm = (struct cmsghdr *)CMSG_NXTHDR(&mhdr, cm)) {
+		if (cm->cmsg_level == IPPROTO_IPV6 &&
+		    cm->cmsg_type == IPV6_PKTINFO &&
+		    cm->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
+			pi = (struct in6_pktinfo *)(CMSG_DATA(cm));
+		}
+	}
+	if (pi == NULL) {
+		bb_info_msg("failed to get packet info");
+		return;
+	}
+
+	if ((ifp = find_ifconf_byid((unsigned int)pi->ipi6_ifindex)) == NULL) {
+		bb_info_msg("unexpected interface (%d)",
+		    (unsigned int)pi->ipi6_ifindex);
+		return;
+	}
+
+	if (len < sizeof(*dh6)) {
+		bb_info_msg("short packet (%d bytes)", (int )len);
+		return;
+	}
+
+	dh6 = (struct dhcp6 *)G.rbuf;
+
+	log1("receive %s from %s on %s", dhcp6msgstr(dh6->dh6_msgtype),
+	    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from), ifp->ifname);
+
+	/* get options */
+	dhcp6_init_options(&optinfo);
+	p = (struct dhcp6opt *)(dh6 + 1);
+	ep = (struct dhcp6opt *)((char *)dh6 + len);
+	if (dhcp6_get_options(p, ep, &optinfo) < 0) {
+		bb_info_msg("failed to parse options");
+		return;
+	}
+
+	switch (dh6->dh6_msgtype) {
+	case DH6_ADVERTISE:
+		(void)client6_recvadvert(ifp, dh6, len, &optinfo);
+		break;
+	case DH6_REPLY:
+		(void)client6_recvreply(ifp, dh6, len, &optinfo);
+		break;
+	default:
+		{
+		char *a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from);
+		bb_info_msg("received an unexpected message (%s) from %s",
+			dhcp6msgstr(dh6->dh6_msgtype), a);
+		free(a);
+		break;
+		}
+	}
+
+	dhcp6_clear_options(&optinfo);
+	return;
+}
+
+static int client6_recvadvert(struct dhcp6_if *ifp, struct dhcp6 *dh6,
+				ssize_t authlen DHCP6_AUTH_ATTR((unused)),
+				struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6_serverinfo *newserver, **sp;
+	struct dhcp6_event *ev;
+	struct dhcp6_eventdata *evd;
+#if ENABLE_FEATURE_DHCP6_AUTH
+	struct authparam *authparam = NULL, authparam0;
+#endif
+
+	/* find the corresponding event based on the received xid */
+	ev = find_event_withid(ifp, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
+	if (ev == NULL) {
+		bb_info_msg("XID mismatch");
+		return (-1);
+	}
+
+	/* packet validation based on Section 15.3 of RFC3315. */
+	if (optinfo->serverID.duid_len == 0) {
+		bb_info_msg("no server ID option");
+		return (-1);
+	} else {
+		log1("server ID: %s, pref=%d",
+		    duidstr(&optinfo->serverID),
+		    optinfo->pref);
+	}
+	if (optinfo->clientID.duid_len == 0) {
+		bb_info_msg("no client ID option");
+		return (-1);
+	}
+	if (duidcmp(&optinfo->clientID, &client_duid)) {
+		bb_info_msg("client DUID mismatch");
+		return (-1);
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* validate authentication */
+	authparam0 = *ev->authparam;
+	if (process_auth(&authparam0, dh6, authlen, optinfo)) {
+		bb_info_msg("failed to process authentication");
+		return (-1);
+	}
+#endif
+
+	/*
+	 * The requesting router MUST ignore any Advertise message that
+	 * includes a Status Code option containing the value NoPrefixAvail
+	 * [RFC3633 Section 11.1].
+	 * Likewise, the client MUST ignore any Advertise message that includes
+	 * a Status Code option containing the value NoAddrsAvail. 
+	 * [RFC3315 Section 17.1.3].
+	 * We only apply this when we are going to request an address or
+	 * a prefix.
+	 */
+	for (evd = TAILQ_FIRST(&ev->data_list); evd;
+	    evd = TAILQ_NEXT(evd, link)) {
+		uint16_t stcode;
+		char *stcodestr;
+
+		switch (evd->type) {
+		case IATYPE_PD:
+			stcode = DH6OPT_STCODE_NOPREFIXAVAIL;
+			stcodestr = (char *)"NoPrefixAvail";
+			break;
+		case IATYPE_NA:
+			stcode = DH6OPT_STCODE_NOADDRSAVAIL;
+			stcodestr = (char *)"NoAddrsAvail";
+			break;
+		default:
+			continue;
+		}
+		if (dhcp6_find_listval(&optinfo->stcode_list,
+		    DHCP6_LISTVAL_STCODE, &stcode, 0)) {
+			bb_info_msg("advertise contains %s status", stcodestr);
+			return (-1);
+		}
+	}
+
+	if (ev->state != DHCP6S_SOLICIT ||
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) || (option_mask32 & OPT_i)) {
+		/*
+		 * We expected a reply message, but do actually receive an
+		 * Advertise message.  The server should be configured not to
+		 * allow the Rapid Commit option.
+		 * We process the message as if we expected the Advertise.
+		 * [RFC3315 Section 17.1.4]
+		 */
+		bb_info_msg("unexpected advertise");
+		/* proceed anyway */
+	}
+
+	/* ignore the server if it is known */
+	if (find_server(ev, &optinfo->serverID)) {
+		bb_info_msg("duplicated server (ID: %s)",
+		    duidstr(&optinfo->serverID));
+		return (-1);
+	}
+
+	/* keep the server */
+	newserver = xzalloc(sizeof(*newserver));
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* remember authentication parameters */
+	newserver->authparam = ev->authparam;
+	newserver->authparam->flags = authparam0.flags;
+	newserver->authparam->prevrd = authparam0.prevrd;
+	newserver->authparam->key = authparam0.key;
+
+	/* allocate new authentication parameter for the soliciting event */
+	authparam = new_authparam(ev->authparam->authproto,
+	    ev->authparam->authalgorithm, ev->authparam->authrdm);
+	ev->authparam = authparam;
+#endif
+
+	/* copy options */
+	dhcp6_init_options(&newserver->optinfo);
+	if (dhcp6_copy_options(&newserver->optinfo, optinfo)) {
+		bb_error_msg("failed to copy options");
+		if (newserver->authparam != NULL)
+			free(newserver->authparam);
+		free(newserver);
+		return (-1);
+	}
+	if (optinfo->pref != DH6OPT_PREF_UNDEF)
+		newserver->pref = optinfo->pref;
+	newserver->active = 1;
+	for (sp = &ev->servers; *sp; sp = &(*sp)->next) {
+		if ((*sp)->pref != DH6OPT_PREF_MAX &&
+		    (*sp)->pref < newserver->pref) {
+			break;
+		}
+	}
+	newserver->next = *sp;
+	*sp = newserver;
+
+	if (newserver->pref == DH6OPT_PREF_MAX) {
+		/*
+		 * If the client receives an Advertise message that includes a
+		 * Preference option with a preference value of 255, the client
+		 * immediately begins a client-initiated message exchange.
+		 * [RFC3315 Section 17.1.2]
+		 */
+		ev->current_server = newserver;
+		if (duidcpy(&ev->serverid, &ev->current_server->optinfo.serverID))
+			return (-1); /* XXX: better recovery? */
+		if (construct_reqdata(ifp, &ev->current_server->optinfo, ev)) {
+			bb_info_msg("failed to construct request data");
+			return (-1); /* XXX */
+		}
+
+		ev->timeouts = 0;
+		ev->state = DHCP6S_REQUEST;
+
+		free(ev->authparam);
+		ev->authparam = newserver->authparam;
+		newserver->authparam = NULL;
+
+		client6_send(ev);
+
+		dhcp6_set_timeoparam(ev);
+		dhcp6_reset_timer(ev);
+	} else if (ev->servers->next == NULL) {
+		unsigned long long elapsed, timo;
+
+		/*
+		 * If this is the first advertise, adjust the timer so that
+		 * the client can collect other servers until IRT elapses.
+		 */
+		elapsed = ev->retrans - dhcp6_timer_rest(ev->timer);
+		if (elapsed <= ev->init_retrans)
+			timo = ev->init_retrans - elapsed;
+		else
+			timo = 0;
+
+		log1("reset timer for %s to %d.%03d",
+		    ifp->ifname, (int )(timo/1000ULL), (int )(timo%1000ULL));
+
+		dhcp6_timer_set(timo, ev->timer);
+	}
+
+	return (0);
+}
+
+static struct dhcp6_serverinfo *find_server(struct dhcp6_event *ev,
+					 struct duid *duid)
+{
+	struct dhcp6_serverinfo *s;
+
+	s = ev->servers;
+	while (s) {
+		if (duidcmp(&s->optinfo.serverID, duid) == 0)
+			return (s);
+
+		s = s->next;
+	}
+
+	return (NULL);
+}
+
+static int
+client6_recvreply(struct dhcp6_if *ifp, struct dhcp6 *dh6,
+		  ssize_t authlen DHCP6_AUTH_ATTR((unused)),
+		  struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6_listval *lv;
+	struct dhcp6_event *ev;
+	int state;
+
+	/* find the corresponding event based on the received xid */
+	ev = find_event_withid(ifp, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
+	if (ev == NULL) {
+		bb_info_msg("XID mismatch");
+		return (-1);
+	}
+
+	state = ev->state;
+	if (state != DHCP6S_INFOREQ &&
+	    state != DHCP6S_REQUEST &&
+	    state != DHCP6S_RENEW &&
+	    state != DHCP6S_REBIND &&
+	    state != DHCP6S_RELEASE &&
+	    (state != DHCP6S_SOLICIT ||
+	     !(ifp->send_flags & DHCIFF_RAPID_COMMIT))) {
+		bb_info_msg("unexpected reply");
+		return (-1);
+	}
+
+	/* A Reply message must contain a Server ID option */
+	if (optinfo->serverID.duid_len == 0) {
+		bb_info_msg("no server ID option");
+		return (-1);
+	}
+
+	/*
+	 * DUID in the Client ID option (which must be contained for our
+	 * client implementation) must match ours.
+	 */
+	if (optinfo->clientID.duid_len == 0) {
+		bb_info_msg("no client ID option");
+		return (-1);
+	}
+	if (duidcmp(&optinfo->clientID, &client_duid)) {
+		bb_info_msg("client DUID mismatch");
+		return (-1);
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* validate authentication */
+	if (process_auth(ev->authparam, dh6, authlen, optinfo)) {
+		bb_info_msg("failed to process authentication");
+		return (-1);
+	}
+#endif
+
+	/*
+	 * If the client included a Rapid Commit option in the Solicit message,
+	 * the client discards any Reply messages it receives that do not
+	 * include a Rapid Commit option.
+	 * (should we keep the server otherwise?)
+	 * [RFC3315 Section 17.1.4]
+	 */
+	if (state == DHCP6S_SOLICIT &&
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) &&
+	    !optinfo->rapidcommit) {
+		bb_info_msg("no rapid commit");
+		return (-1);
+	}
+
+	/*
+	 * The client MAY choose to report any status code or message from the
+	 * status code option in the Reply message.
+	 * [RFC3315 Section 18.1.8]
+	 */
+	for (lv = TAILQ_FIRST(&optinfo->stcode_list); lv;
+	     lv = TAILQ_NEXT(lv, link)) {
+		bb_info_msg("status code: %s", dhcp6_stcodestr(lv->val_num16));
+	}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	if (!TAILQ_EMPTY(&optinfo->dns_list)) {
+		struct dhcp6_listval *d;
+		int i = 0;
+
+		for (d = TAILQ_FIRST(&optinfo->dns_list); d;
+		     d = TAILQ_NEXT(d, link), i++) {
+			log1("nameserver[%d] %s",
+			    i, in6addr2str(&d->val_addr6, 0));
+		}
+	}
+
+	if (!TAILQ_EMPTY(&optinfo->dnsname_list)) {
+		struct dhcp6_listval *d;
+		int i = 0;
+
+		for (d = TAILQ_FIRST(&optinfo->dnsname_list); d;
+		     d = TAILQ_NEXT(d, link), i++) {
+			log1("Domain search list[%d] %s",
+			    i, d->val_vbuf.dv_buf);
+		}
+	}
+
+	if (!TAILQ_EMPTY(&optinfo->ntp_list)) {
+		struct dhcp6_listval *d;
+		int i = 0;
+
+		for (d = TAILQ_FIRST(&optinfo->ntp_list); d;
+		     d = TAILQ_NEXT(d, link), i++) {
+			log1("NTP server[%d] %s",
+			    i, in6addr2str(&d->val_addr6, 0));
+		}
+	}
+
+	if (!TAILQ_EMPTY(&optinfo->sip_list)) {
+		struct dhcp6_listval *d;
+		int i = 0;
+
+		for (d = TAILQ_FIRST(&optinfo->sip_list); d;
+		     d = TAILQ_NEXT(d, link), i++) {
+			log1("SIP server address[%d] %s",
+			    i, in6addr2str(&d->val_addr6, 0));
+		}
+	}
+
+	if (!TAILQ_EMPTY(&optinfo->sipname_list)) {
+		struct dhcp6_listval *d;
+		int i = 0;
+
+		for (d = TAILQ_FIRST(&optinfo->sipname_list); d;
+		     d = TAILQ_NEXT(d, link), i++) {
+			log1("SIP domain name[%d] %s",
+			    i, d->val_vbuf.dv_buf);
+		}
+	}
+#endif /* CONFIG_UDHCP_DEBUG */
+
+	/*
+	 * Set refresh timer for configuration information specified in
+	 * information-request.  If the timer value is specified by the server
+	 * in an information refresh time option, use it; use the protocol
+	 * default otherwise.
+	 */
+	if (state == DHCP6S_INFOREQ) {
+		unsigned long long refreshtime = DHCP6_IRT_DEFAULT;
+
+		if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF)
+			refreshtime = optinfo->refreshtime;
+
+		ifp->timer = dhcp6_timer_add(client6_expire_refreshtime, ifp);
+
+		if (refreshtime > 0x7fffffffULL) {
+			/*
+			 * XXX: tv_sec can overflow for an
+			 * unsigned 32bit value.
+			 */
+			bb_info_msg("refresh time is too large: %llu", refreshtime);
+			refreshtime = 0x1f3fffffc18;	/* 0x7fffffff * 1000 */
+		}
+		else
+			refreshtime *= 1000ULL;
+		dhcp6_timer_set(refreshtime, ifp->timer);
+
+	} else if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
+		/*
+		 * draft-ietf-dhc-lifetime-02 clarifies that refresh time
+		 * is only used for information-request and reply exchanges.
+		 */
+		bb_info_msg("unexpected information refresh time option (ignored)");
+	}
+
+	/* update stateful configuration information */
+	if (state != DHCP6S_RELEASE) {
+		update_ia(IATYPE_PD, &optinfo->iapd_list, ifp,
+		    &optinfo->serverID, ev->authparam);
+		update_ia(IATYPE_NA, &optinfo->iana_list, ifp,
+		    &optinfo->serverID, ev->authparam);
+	}
+
+	/*
+	 * Call the configuration script, if specified, to handle various
+	 * configuration parameters.
+	 */
+	if (ifp->scriptpath != NULL) {
+		log1("executes %s", ifp->scriptpath);
+		dhcp6_script(ifp->scriptpath,
+			     fill_envp_client6(optinfo, ifp->ifname));
+	}
+
+	dhcp6_remove_event(ev);
+
+	if (state == DHCP6S_RELEASE) {
+		/*
+		 * When the client receives a valid Reply message in response
+		 * to a Release message, the client considers the Release event
+		 * completed, regardless of the Status Code option(s) returned
+		 * by the server.
+		 * [RFC3315 Section 18.1.8]
+		 */
+		check_exit();
+	}
+
+	log1("got an expected reply, sleeping.");
+
+	if (option_mask32 & OPT_i) {
+		bb_got_signal = SIGTERM;
+		check_exit();
+	}
+	return (0);
+}
+
+static struct dhcp6_event *find_event_withid(struct dhcp6_if *ifp, uint32_t xid)
+{
+	struct dhcp6_event *ev;
+
+	for (ev = TAILQ_FIRST(&ifp->event_list); ev;
+	     ev = TAILQ_NEXT(ev, link)) {
+		if (ev->xid == xid)
+			return (ev);
+	}
+
+	return (NULL);
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int
+process_auth(struct authparam *authparam, struct dhcp6 *dh6, ssize_t len,
+	     struct dhcp6_optinfo *optinfo)
+{
+	struct keyinfo *key = NULL;
+	int authenticated = 0;
+
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_UNDEF:
+		/* server did not provide authentication option */
+		break;
+	case DHCP6_AUTHPROTO_DELAYED:
+		if ((optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+			bb_info_msg("server did not include "
+			    "authentication information");
+			break;
+		}
+
+		if (optinfo->authalgorithm != DHCP6_AUTHALG_HMACMD5) {
+			bb_info_msg("unknown authentication algorithm: %d",
+				 optinfo->authalgorithm);
+			break;
+		}
+
+		if (optinfo->authrdm != DHCP6_AUTHRDM_MONOCOUNTER) {
+			bb_info_msg("unknown RDM (%d)",
+			    optinfo->authrdm);
+			break;
+		}
+
+		/*
+		 * Replay protection.  If we do not know the previous RD value,
+		 * we accept the message anyway (XXX).
+		 */
+		if ((authparam->flags & AUTHPARAM_FLAGS_NOPREVRD)) {
+			bb_info_msg("previous RD value is unknown (accept it)");
+		} else {
+			if (dhcp6_auth_replaycheck(optinfo->authrdm,
+			    authparam->prevrd, optinfo->authrd)) {
+				bb_info_msg("possible replay attack detected");
+				break;
+			}
+		}
+
+		/* identify the secret key */
+		if ((key = authparam->key) != NULL) {
+			/*
+			 * If we already know a key, its identification should
+			 * match that contained in the received option.
+			 * (from Section 21.4.5.1 of RFC3315)
+			 */
+			if (optinfo->delayedauth_keyid != key->keyid ||
+			    optinfo->delayedauth_realmlen != key->realmlen ||
+			    memcmp(optinfo->delayedauth_realmval, key->realm,
+			    key->realmlen) != 0) {
+				bb_info_msg("authentication key mismatch");
+				break;
+			}
+		} else {
+			key = find_key(optinfo->delayedauth_realmval,
+			    optinfo->delayedauth_realmlen,
+			    optinfo->delayedauth_keyid);
+			if (key == NULL) {
+				bb_info_msg("failed to find key "
+				    "provided by the server (ID: %x)",
+				    optinfo->delayedauth_keyid);
+				break;
+			} else {
+				log1("found key for "
+				    "authentication: %s", key->name);
+			}
+			authparam->key = key;
+		}
+
+		/* check for the key lifetime */
+		if (dhcp6_validate_key(key)) {
+			bb_info_msg("key %s has expired", key->name);
+			break;
+		}
+
+		/* validate MAC */
+		if (dhcp6_verify_mac((char *)dh6, len, optinfo->authproto,
+		    optinfo->authalgorithm,
+		    optinfo->delayedauth_offset + sizeof(*dh6), key) == 0) {
+			log1("message authentication validated");
+			authenticated = 1;
+		} else {
+			bb_info_msg("invalid message authentication");
+		}
+
+		break;
+	default:
+		bb_info_msg("unsupported authentication protocol: %d",
+			 optinfo->authproto);
+		break;
+	}
+
+	if (authenticated == 0) {
+		if (authparam->authproto != DHCP6_AUTHPROTO_UNDEF) {
+			bb_info_msg("message not authenticated "
+			    "while authentication required");
+
+			/*
+			 * Right now, we simply discard unauthenticated
+			 * messages.
+			 */
+			return (-1);
+		}
+	} else {
+		/* if authenticated, update the "previous" RD value */
+		authparam->prevrd = optinfo->authrd;
+		authparam->flags &= ~AUTHPARAM_FLAGS_NOPREVRD;
+	}
+
+	return (0);
+}
+
+static int set_auth(struct dhcp6_event *ev, struct dhcp6_optinfo *optinfo)
+{
+	struct authparam *authparam = ev->authparam;
+
+	if (authparam == NULL)
+		return (0);
+
+	optinfo->authproto = authparam->authproto;
+	optinfo->authalgorithm = authparam->authalgorithm;
+	optinfo->authrdm = authparam->authrdm;
+
+	switch (authparam->authproto) {
+	case DHCP6_AUTHPROTO_UNDEF: /* we simply do not need authentication */
+		return (0);
+	case DHCP6_AUTHPROTO_DELAYED:
+		if (ev->state == DHCP6S_INFOREQ) {
+			/*
+			 * In the current implementation, delayed
+			 * authentication for Information-request and Reply
+			 * exchanges doesn't work.  Specification is also
+			 * unclear on this usage.
+			 */
+			bb_info_msg("delayed authentication "
+			    "cannot be used for Information-request yet");
+			return (-1);
+		}
+
+		if (ev->state == DHCP6S_SOLICIT) {
+			optinfo->authflags |= DHCP6OPT_AUTHFLAG_NOINFO;
+			return (0); /* no auth information is needed */
+		}
+
+		if (authparam->key == NULL) {
+			bb_info_msg("no authentication key for %s",
+			    dhcp6_event_statestr(ev));
+			return (-1);
+		}
+
+		if (dhcp6_validate_key(authparam->key)) {
+			bb_info_msg("key %s is invalid",
+			    authparam->key->name);
+			return (-1);
+		}
+
+		if (get_rdvalue(optinfo->authrdm, &optinfo->authrd,
+		    sizeof(optinfo->authrd))) {
+			bb_error_msg("failed to get a replay detection value");
+			return (-1);
+		}
+
+		optinfo->delayedauth_keyid = authparam->key->keyid;
+		optinfo->delayedauth_realmlen = authparam->key->realmlen;
+		optinfo->delayedauth_realmval =
+		    malloc_or_warn(optinfo->delayedauth_realmlen);
+		if (optinfo->delayedauth_realmval == NULL)
+			return (-1);
+		memcpy(optinfo->delayedauth_realmval, authparam->key->realm,
+		    optinfo->delayedauth_realmlen);
+
+		break;
+	default:
+		bb_error_msg("unsupported authentication protocol: %d",
+		    authparam->authproto);
+		return (-1);
+	}
+
+	return (0);
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH*/
+
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/dhcp6c.h busybox/networking/udhcp/dhcp6c.h
--- busybox.orig/networking/udhcp/dhcp6c.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c.h	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifdef __GNUC__
+#define DHCP6_AUTH_ATTR(x)	IF_NOT_FEATURE_DHCP6_AUTH(__attribute__(x))
+#else
+#define DHCP6_AUTH_ATTR(x)
+#endif
+
+struct dhcp6_timer *client6_timo(void *);
+int client6_start(struct dhcp6_if *);
+void client6_send(struct dhcp6_event *);
+
+
+char **fill_envp_client6(struct dhcp6_optinfo *optinfo, char *ifname);
+char **fill_envp_relay6(struct dhcp6_optinfo *optinfo, char *clientaddr);
+int dhcp6_script(const char *scriptpath, char **envp);
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/dhcp6c_ia.c busybox/networking/udhcp/dhcp6c_ia.c
--- busybox.orig/networking/udhcp/dhcp6c_ia.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c_ia.c	2011-02-08 12:12:44.000000000 +0300
@@ -0,0 +1,919 @@
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/types.h>
+#include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+
+#include <netinet/in.h>
+
+#include <syslog.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "dhcp6c.h"
+#include "dhcp6c_ia.h"
+
+typedef enum {IAS_ACTIVE, IAS_RENEW, IAS_REBIND} iastate_t;
+
+struct ia {
+	TAILQ_ENTRY(ia) link;
+
+	/* back pointer to configuration */
+	struct ia_conf *conf;
+
+	/* common parameters of IA */
+	uint32_t t1;		/* duration for renewal */
+	uint32_t t2;		/* duration for rebind  */
+
+	/* internal parameters for renewal/rebinding */
+	iastate_t state;
+	struct dhcp6_timer *timer;
+
+	/* DHCP related parameters */
+	struct dhcp6_if *ifp;	/* DHCP interface */
+	struct duid serverid;	/* the server ID that provided this IA */
+
+	/* control information shared with each particular config routine */
+	struct iactl *ctl;
+
+	/* authentication parameters for transaction with servers on this IA */
+	struct authparam *authparam;
+};
+
+void destruct_iadata(struct dhcp6_eventdata *evd);
+
+static void ia_callback(struct ia *);
+static int prepare_iaevent(struct ia *, int);
+static int reestablish_ia(struct ia *);
+static void remove_ia(struct ia *);
+static struct ia *get_ia(iatype_t, struct dhcp6_if *, struct ia_conf *,
+    struct dhcp6_listval *, struct duid *);
+static struct ia *find_ia(struct ia_conf *, iatype_t, uint32_t);
+static struct dhcp6_timer *ia_timo(void *);
+
+static const char *iastr(iatype_t);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int update_authparam(struct ia *, struct authparam *);
+#endif
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static const char *statestr(iastate_t);
+#endif
+
+static int update_prefix6(iatype_t, struct ia *, struct dhcp6_listval *,
+        struct pifc_list *, struct dhcp6_if *, struct iactl **,
+        void (*)(struct ia *));
+static struct iaprefix *find_iaprefix(struct iaprefix_list *,
+    struct dhcp6_prefix *, int);
+static int remove_iaprefix(struct iaprefix *, iatype_t);
+
+static int iapref_renew(struct iactl *, struct dhcp6_ia *,
+        struct dhcp6_eventdata *);
+static int pref_isvalid(struct iactl *);
+static uint32_t pref_duration(struct iactl *);
+static void pref_cleanup(struct iactl *);
+static struct dhcp6_timer *iapref_timo(void *);
+static int add_ifprefix(struct iaprefix *,
+    struct dhcp6_prefix *, struct prefix_ifconf *);
+
+static ALWAYS_INLINE int pd_ifaddrconf(ifaddrconf_cmd_t, struct dhcp6_ifprefix *ifpfx);
+static int na_ifaddrconf(ifaddrconf_cmd_t, struct iaprefix *);
+
+
+void update_ia(iatype_t iatype, struct dhcp6_list *ialist, struct dhcp6_if *ifp,
+	  struct duid *serverid,
+	  struct authparam *authparam DHCP6_AUTH_ATTR((unused)))
+{
+	struct ia *ia;
+	struct ia_conf *iac;
+	struct iapd_conf *iapdc;
+	struct dhcp6_listval *iav, *siav;
+
+	for (iav = TAILQ_FIRST(ialist); iav; iav = TAILQ_NEXT(iav, link)) {
+		/* if we're not interested in this IA, ignore it. */
+		if ((iac = find_iaconf(&ifp->iaconf_list, iatype,
+		    iav->val_ia.iaid)) == NULL) {
+			continue;
+		}
+
+		/* validate parameters */
+		/*
+		 * If a client receives an IA_NA with T1 greater than T2, and
+		 * both T1 and T2 are greater than 0, the client discards the
+		 * IA_NA option and processes the remainder of the message as
+		 * though the server had not included the invalid IA_NA option.
+		 * [RFC3315 22.4]
+		 * We apply the same rule to IA_PD as well.
+		 */
+		if (iav->val_ia.t2 != 0 && iav->val_ia.t1 > iav->val_ia.t2) {
+			bb_info_msg("invalid IA: T1(%u) > T2(%u)",
+			    iav->val_ia.t1, iav->val_ia.t2);
+			continue;
+		}
+
+		/* locate the local IA or make a new one */
+		ia = get_ia(iatype, ifp, iac, iav, serverid);
+		if (ia == NULL) {
+			bb_info_msg("failed to get an IA "
+			    "type: %s, ID: %u", iastr(iac->type), iac->iaid);
+			continue;
+		}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+		/* update authentication parameters */
+		if (update_authparam(ia, authparam)) {
+			bb_info_msg("failed to update "
+			    "authentication param for IA "
+			    "type: %s, ID: %u", iastr(iac->type), iac->iaid);
+			remove_ia(ia);
+			continue;
+		}
+#endif
+
+		/* update IA configuration information */
+		for (siav = TAILQ_FIRST(&iav->sublist); siav;
+		    siav = TAILQ_NEXT(siav, link)) {
+			switch (siav->type) {
+			case DHCP6_LISTVAL_PREFIX6:
+				/* add or update the prefix */
+				iapdc = (struct iapd_conf *)iac;
+				if (update_prefix6(IATYPE_PD, ia, siav,
+				    &iapdc->iapd_pif_list, ifp, &ia->ctl,
+				    ia_callback)) {
+					char *p = in6addr2str(&siav->val_prefix6.addr, 0);
+					bb_error_msg("failed to update a prefix %s/%d",
+					    p, siav->val_prefix6.plen);
+					free(p);
+				}
+				break;
+			case DHCP6_LISTVAL_STATEFULADDR6:
+				if (update_prefix6(IATYPE_NA, ia, siav,
+				    NULL, ifp, &ia->ctl,
+				    ia_callback)) {
+					char *p = in6addr2str(&siav->val_statefuladdr6.addr, 0);
+					bb_error_msg("failed to update an address %s",
+					    p);
+					free(p);
+				}
+				break;
+			case DHCP6_LISTVAL_STCODE:
+				bb_info_msg("status code for %s-%u: %s",
+				    iastr(iatype), iav->val_ia.iaid,
+				    dhcp6_stcodestr(siav->val_num16));
+				if ((ia->state == IAS_RENEW ||
+				    ia->state == IAS_REBIND) &&
+				    siav->val_num16 == DH6OPT_STCODE_NOBINDING) {
+					/*
+					 * For each IA in the original Renew or
+					 * Rebind message, the client
+					 * sends a Request message if the IA
+					 * contained a Status Code option
+					 * with the NoBinding status.
+					 * [RFC3315 18.1.8]
+					 * XXX: what about the PD case?
+					 */
+					bb_info_msg("receive NoBinding against "
+					    "renew/rebind for %s-%u",
+					    iastr(ia->conf->type),
+					    ia->conf->iaid);
+					reestablish_ia(ia);
+					goto nextia;
+				}
+				break;
+			default:
+				bb_error_msg("impossible subopt");
+				goto nextia;
+			}
+		}
+
+		/* see if this IA is still valid.  if not, remove it. */
+		if (ia->ctl == NULL || !pref_isvalid(ia->ctl)) {
+			log1("IA %s-%u invalidated",
+			    iastr(ia->conf->type), ia->conf->iaid);
+			remove_ia(ia);
+			continue;
+		}
+
+		/* if T1 or T2 is 0, determine appropriate values locally. */
+		if (ia->t1 == 0 || ia->t2 == 0) {
+			uint32_t duration;
+
+			if (ia->ctl)
+				duration = pref_duration(ia->ctl);
+			else
+				duration = 1800; /* 30min. XXX: no rationale */
+
+			if (ia->t1 == 0) {
+				if (duration == DHCP6_DURATION_INFINITE)
+					ia->t1 = DHCP6_DURATION_INFINITE;
+				else
+					ia->t1 = duration / 2;
+			}
+			if (ia->t2 == 0) {
+				if (duration == DHCP6_DURATION_INFINITE)
+					ia->t2 = DHCP6_DURATION_INFINITE;
+				else
+					ia->t2 = duration * 4 / 5;
+			}
+
+			/* make sure T1 <= T2 */
+			if (ia->t1 > ia->t2)
+				ia->t1 = ia->t2 * 5 / 8;
+
+			bb_info_msg("T1(%u) and/or T2(%u) "
+			    "is locally determined",  ia->t1, ia->t2);
+		}
+
+		/*
+		 * Be proactive for too-small timeout values.  Note that
+		 * the adjusted values may make some information expire
+		 * without renewal.
+		 */
+		if (ia->t2 < DHCP6_DURATION_MIN) {
+			bb_info_msg("T1 (%u) or T2 (%u) "
+			    "is too small", ia->t1, ia->t2);
+			ia->t2 = DHCP6_DURATION_MIN;
+			ia->t1 = ia->t2 * 5 / 8;
+			bb_info_msg(" adjusted to %u and %u", ia->t1, ia->t2);
+		}
+
+		/* set up a timer for this IA. */
+		if (ia->t1 == DHCP6_DURATION_INFINITE) {
+			if (ia->timer)
+				dhcp6_timer_remove(&ia->timer);
+		} else {
+			if (ia->timer == NULL)
+				ia->timer = dhcp6_timer_add(ia_timo, ia);
+			dhcp6_timer_set(ia->t1 * 1000ULL, ia->timer);
+		}
+
+		ia->state = IAS_ACTIVE;
+
+	  nextia:
+		;
+	}
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int update_authparam(struct ia *ia, struct authparam *authparam)
+{
+	if (authparam == NULL)
+		return (0);
+
+	if (ia->authparam == NULL) {
+		if ((ia->authparam = copy_authparam(authparam)) == NULL) {
+			return (-1);
+		}
+		return (0);
+	}
+
+	/* update the previous RD value and flags */
+	ia->authparam->prevrd = authparam->prevrd;
+	ia->authparam->flags = authparam->flags;
+
+	return (0);
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static int prepare_iaevent(struct ia *ia, int dhcpstate)
+{
+	struct dhcp6_event *ev;
+	struct dhcp6_ia iaparam;
+	struct dhcp6_eventdata *evd;
+
+	ev = dhcp6_create_event(ia->ifp, dhcpstate);
+
+	if (dhcpstate == DHCP6S_RELEASE ||
+	    dhcpstate == DHCP6S_REQUEST ||
+	    dhcpstate == DHCP6S_RENEW
+	    ) {
+		if (duidcpy(&ev->serverid, &ia->serverid))
+			goto fail;
+	}
+
+	evd = xzalloc(sizeof(*evd));
+	evd->event = ev;
+	memset(&iaparam, 0, sizeof(iaparam));
+	iaparam.iaid = ia->conf->iaid;
+	/* XXX: should we set T1/T2 to 0 on release?  spec is silent on this. */
+	iaparam.t1 = ia->t1;
+	iaparam.t2 = ia->t2;
+
+	if (ia->ctl && iapref_renew(ia->ctl, &iaparam, evd)) {
+		bb_error_msg("failed to prepare IA data");
+			goto fail;
+	}
+	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (ia->authparam != NULL) {
+		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
+			goto fail;
+		}
+	}
+#endif
+
+	ev->timeouts = 0;
+	dhcp6_set_timeoparam(ev);
+	dhcp6_reset_timer(ev);
+
+	client6_send(ev);
+	return (0);
+
+fail:
+	if (ev)
+		dhcp6_remove_event(ev);
+	return (-1);
+}
+
+static int reestablish_ia(struct ia *ia)
+{
+
+	log1("re-establishing IA: %s-%u", 
+	    iastr(ia->conf->type), ia->conf->iaid);
+
+	if (ia->state != IAS_RENEW && ia->state != IAS_REBIND) {
+		bb_error_msg_and_die("internal error (invalid IA status)");
+	}
+
+	/* we don't need a timer for the IA (see comments in ia_timo()) */
+	if (ia->timer)
+		dhcp6_timer_remove(&ia->timer);
+
+	return (prepare_iaevent(ia, DHCP6S_REQUEST));
+}
+
+static void ia_callback(struct ia *ia)
+{
+	/* see if this IA is still valid.  if not, remove it. */
+	if (ia->ctl == NULL || !pref_isvalid(ia->ctl)) {
+		log1("IA %s-%u is invalidated",
+		    iastr(ia->conf->type), ia->conf->iaid);
+		remove_ia(ia);
+	}
+}
+
+void release_all_ia(struct dhcp6_if *ifp)
+{
+	struct ia_conf *iac;
+	struct ia *ia, *ia_next;
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		for (ia = TAILQ_FIRST(&iac->iadata); ia; ia = ia_next) {
+			ia_next = TAILQ_NEXT(ia, link);
+
+			log1("release an IA: %s-%u",
+				iastr(ia->conf->type), ia->conf->iaid);
+
+			prepare_iaevent(ia, DHCP6S_RELEASE);
+
+			/*
+			 * The client MUST stop using all of the addresses
+			 * being released as soon as the client begins the
+			 * Release message exchange process.
+			 * [RFC3315 Section 18.1.6]
+			 */
+			remove_ia(ia);
+		}
+	}
+}
+
+static void remove_ia(struct ia *ia)
+{
+	struct ia_conf *iac = ia->conf;
+	struct dhcp6_if *ifp = ia->ifp;
+
+	log1("remove an IA: %s-%u", iastr(ia->conf->type), ia->conf->iaid);
+
+	TAILQ_REMOVE(&iac->iadata, ia, link);
+
+	duidfree(&ia->serverid);
+
+	if (ia->timer)
+		dhcp6_timer_remove(&ia->timer);
+
+	if (ia->ctl)
+		pref_cleanup(ia->ctl);
+
+	if (ia->authparam != NULL)
+		free(ia->authparam);
+
+	free(ia);
+
+	(void)client6_start(ifp);
+}
+
+static struct dhcp6_timer *ia_timo(void *arg)
+{
+	struct ia *ia = (struct ia *)arg;
+	int dhcpstate;
+
+	log1("IA timeout for %s-%u, state=%s",
+	    iastr(ia->conf->type), ia->conf->iaid, statestr(ia->state));
+
+	switch (ia->state) {
+	case IAS_ACTIVE:
+		ia->state = IAS_RENEW;
+		dhcpstate = DHCP6S_RENEW;
+		dhcp6_timer_set((ia->t1 < ia->t2) ? (ia->t2 - ia->t1) * 1000ULL
+						  : 0,
+				ia->timer);
+		break;
+	case IAS_RENEW:
+		ia->state = IAS_REBIND;
+		dhcpstate = DHCP6S_REBIND;
+
+		/*
+		 * We need keep DUID for sending Release in this state.
+		 * But we don't need a timer for the IA.  We'll just wait for a
+		 * reply for the REBIND until all associated configuration
+		 * parameters for this IA expire.
+		 */
+		dhcp6_timer_remove(&ia->timer);
+		break;
+	default:
+		bb_error_msg("invalid IA state (%d)", (int)ia->state);
+		return (NULL);	/* XXX */
+	}
+
+	if (prepare_iaevent(ia, dhcpstate) == 0)
+		return (ia->timer);
+	else
+		return (NULL);
+}
+
+static struct ia *get_ia(iatype_t type, struct dhcp6_if *ifp,
+	struct ia_conf *iac, struct dhcp6_listval *iaparam,
+	struct duid *serverid)
+{
+	struct ia *ia;
+	int create;
+
+	if ((ia = find_ia(iac, type, iaparam->val_ia.iaid)) == NULL) {
+		ia = xzalloc(sizeof(*ia));
+		ia->state = IAS_ACTIVE;
+
+		TAILQ_INSERT_TAIL(&iac->iadata, ia, link);
+		ia->conf = iac;
+
+		create = 1;
+	} else {
+		duidfree(&ia->serverid);
+
+		create = 0;
+	}
+
+	ia->t1 = iaparam->val_ia.t1;
+	ia->t2 = iaparam->val_ia.t2;
+	ia->ifp = ifp;
+	if (duidcpy(&ia->serverid, serverid))
+		return (NULL);
+
+	log1("%s an IA: %s-%u",
+	    create ? "make" : "update", iastr(type), ia->conf->iaid);
+
+	return (ia);
+}
+
+static struct ia *find_ia(struct ia_conf *iac, iatype_t type, uint32_t iaid)
+{
+	struct ia *ia;
+
+	for (ia = TAILQ_FIRST(&iac->iadata); ia;
+	    ia = TAILQ_NEXT(ia, link)) {
+		if (ia->conf->type == type && ia->conf->iaid == iaid)
+			return (ia);
+	}
+
+	return (NULL);
+}
+
+void destruct_iadata(struct dhcp6_eventdata *evd)
+{
+	struct dhcp6_list *ial;
+
+	if (evd->type != IATYPE_PD && evd->type != IATYPE_NA) {
+		bb_error_msg_and_die("assumption failure %d", evd->type);
+	}
+
+	ial = (struct dhcp6_list *)evd->data;
+	dhcp6_clear_list(ial);
+	free(ial);
+
+	free(evd);
+}
+
+static const char *iastr(iatype_t type)
+{
+	switch (type) {
+	case IATYPE_PD:
+		return ("PD");
+	case IATYPE_NA:
+		return ("NA");
+	default:
+		return ("???");	/* should be a bug */
+	}
+}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static const char *statestr(iastate_t state)
+{
+	switch (state) {
+	case IAS_ACTIVE:
+		return "ACTIVE";
+	case IAS_RENEW:
+		return "RENEW";
+	case IAS_REBIND:
+		return "REBIND";
+	default:
+		return "???";	/* should be a bug */
+	}
+}
+#endif
+
+
+static int update_prefix6(iatype_t type, struct ia *ia, struct dhcp6_listval *lv,
+		struct pifc_list *pifc,	struct dhcp6_if * dhcpifp,
+		struct iactl **ctlp,
+		void (*callback)(struct ia *))
+{
+	struct iactl *iac = (struct iactl *)*ctlp;
+	struct iaprefix *sp;
+	struct dhcp6_prefix pinfo;
+	struct prefix_ifconf *pif;
+	int spcreate = 0;
+
+	switch (type) {
+		case IATYPE_PD:
+			memcpy(&pinfo, &lv->uv.uv_prefix6, sizeof(pinfo));
+			break;
+		case IATYPE_NA:
+			memcpy(&pinfo, &lv->uv.uv_statefuladdr6, sizeof(struct dhcp6_statefuladdr));
+			pinfo.plen = 128;
+			break;
+	}
+
+	/*
+	 * A client discards any addresses for which the preferred
+         * lifetime is greater than the valid lifetime.
+	 * [RFC3315 22.6] 
+	 */
+	if (pinfo.vltime != DHCP6_DURATION_INFINITE &&
+	    (pinfo.pltime == DHCP6_DURATION_INFINITE ||
+	    pinfo.pltime > pinfo.vltime)) {
+		char *p = in6addr2str(&pinfo.addr, 0);
+		bb_info_msg("invalid prefix %s/%d: "
+		    "pltime (%u) is larger than vltime (%u)",
+		    p, pinfo.plen,
+		    pinfo.pltime, pinfo.vltime);
+		free(p);
+		return (-1);
+	}
+
+	if (iac == NULL) {
+		iac = xzalloc(sizeof(*iac));
+		iac->iactl_ia = ia;
+		iac->callback = callback;
+		iac->type = type;
+
+		iac->pifc_head = pifc;
+		TAILQ_INIT(&iac->iaprefix_head);
+		*ctlp = (struct iactl *)iac;
+	}
+
+	/* search for the given prefix, and make a new one if it fails */
+	if ((sp = find_iaprefix(&iac->iaprefix_head, &pinfo, (type==IATYPE_PD))) == NULL) {
+		sp = xzalloc(sizeof(*sp));
+		sp->pa.addr = pinfo.addr;
+		sp->pa.plen = pinfo.plen;
+		sp->ctl = iac;
+
+		if (type == IATYPE_PD)
+			TAILQ_INIT(&sp->u.ifprefix_list);
+
+		TAILQ_INSERT_TAIL(&iac->iaprefix_head, sp, link);
+
+		spcreate = 1;
+	}
+
+	/* update the timestamp of update */
+	sp->updatetime = time(NULL);
+
+	/* update the prefix according to pinfo */
+	sp->pa.pltime = pinfo.pltime;
+	sp->pa.vltime = pinfo.vltime;
+	if (type == IATYPE_NA)
+		sp->u.dhcpif = dhcpifp;
+
+	log2("%s a address %s/%d pltime=%u, vltime=%u",
+	    spcreate ? "create" : "update",
+	    in6addr2str(&pinfo.addr, 0), pinfo.plen,
+	    pinfo.pltime, pinfo.vltime);
+
+	/* update prefix interfaces if necessary */
+	if (sp->pa.vltime != 0) {
+		if (type == IATYPE_PD && spcreate) {
+			for (pif = TAILQ_FIRST(iac->pifc_head); pif;
+			    pif = TAILQ_NEXT(pif, link)) {
+			/*
+			 * The requesting router MUST NOT assign any delegated
+			 * prefixes or subnets from the delegated prefix(es) to
+			 * the link through which it received the DHCP message
+			 * from the delegating router.
+			 * [RFC3633 Section 12.1]
+			 */
+				if (strcmp(pif->ifname, dhcpifp->ifname) == 0) {
+					bb_info_msg("skip %s as a prefix interface",
+					    dhcpifp->ifname);
+					continue;
+				}
+
+				add_ifprefix(sp, &pinfo, pif);
+			}
+		}
+		else if (type == IATYPE_NA) {
+			if (na_ifaddrconf(IFADDRCONF_ADD, sp) < 0)
+				return (-1);
+		}
+	}
+
+	/*
+	 * If the new vltime is 0, this prefix immediately expires.
+	 * Otherwise, set up or update the associated timer.
+	 */
+	switch (sp->pa.vltime) {
+	case 0:
+		remove_iaprefix(sp, type);
+		break;
+	case DHCP6_DURATION_INFINITE:
+		if (sp->timer)
+			dhcp6_timer_remove(&sp->timer);
+		break;
+	default:
+		if (sp->timer == NULL) {
+			sp->timer = dhcp6_timer_add(iapref_timo, sp);
+		}
+		/* update the timer */
+		dhcp6_timer_set(sp->pa.vltime * 1000ULL, sp->timer);
+		break;
+	}
+
+	return (0);
+}
+
+static struct iaprefix *find_iaprefix(struct iaprefix_list *head, struct dhcp6_prefix *addr,
+		int match_plen)
+{
+	struct iaprefix *sp;
+
+	for (sp = TAILQ_FIRST(head); sp; sp = TAILQ_NEXT(sp, link)) {
+		if (!IN6_ARE_ADDR_EQUAL(&sp->pa.addr, &addr->addr))
+			continue;
+		if (match_plen == 0 || sp->pa.plen == addr->plen)
+			return (sp);
+	}
+
+	return (NULL);
+}
+
+static int remove_iaprefix(struct iaprefix *sp, iatype_t type)
+{
+	int ret = 0;
+
+	log2("remove an address %s/%d",
+	    in6addr2str(&sp->pa.addr, 0), sp->pa.plen);
+
+	if (sp->timer)
+		dhcp6_timer_remove(&sp->timer);
+
+	if (type == IATYPE_PD) {
+		struct dhcp6_ifprefix *ip;
+
+		/* remove all interface prefixes */
+		while ((ip = TAILQ_FIRST(&sp->u.ifprefix_list)) != NULL) {
+			TAILQ_REMOVE(&sp->u.ifprefix_list, ip, plink);
+			pd_ifaddrconf(IFADDRCONF_REMOVE, ip);
+			free(ip);
+		}
+	}
+	else {
+		ret = na_ifaddrconf(IFADDRCONF_REMOVE, sp);
+	}
+
+	TAILQ_REMOVE(&sp->ctl->iaprefix_head, sp, link);
+	free(sp);
+	return ret;
+}
+
+static int pref_isvalid(struct iactl *iac)
+{
+	if (TAILQ_EMPTY(&iac->iaprefix_head))
+		return (0);	/* this IA is invalid */
+	return (1);
+}
+
+static uint32_t pref_duration(struct iactl *iac)
+{
+	struct iaprefix *sp;
+	uint32_t base = DHCP6_DURATION_INFINITE, pltime, passed;
+	time_t now;
+
+	/* Determine the smallest period until pltime expires. */
+	now = time(NULL);
+	for (sp = TAILQ_FIRST(&iac->iaprefix_head); sp;
+	    sp = TAILQ_NEXT(sp, link)) {
+		passed = now > sp->updatetime ?
+		    (uint32_t)(now - sp->updatetime) : 0;
+		pltime = sp->pa.pltime > passed ?
+		    sp->pa.pltime - passed : 0;
+
+		if (base == DHCP6_DURATION_INFINITE || pltime < base)
+			base = pltime;
+	}
+
+	return (base);
+}
+
+static void pref_cleanup(struct iactl *iac)
+{
+	struct iaprefix *sp;
+
+	while ((sp = TAILQ_FIRST(&iac->iaprefix_head)) != NULL) {
+		TAILQ_REMOVE(&iac->iaprefix_head, sp, link);
+		remove_iaprefix(sp, iac->type);
+	}
+
+	free(iac);
+}
+
+static int iapref_renew(struct iactl *iac, struct dhcp6_ia *iaparam,
+		struct dhcp6_eventdata *evd)
+{
+	struct iaprefix *sp;
+	struct dhcp6_list *ial = NULL, pl;
+
+	TAILQ_INIT(&pl);
+	for (sp = TAILQ_FIRST(&iac->iaprefix_head); sp;
+	    sp = TAILQ_NEXT(sp, link)) {
+		if (dhcp6_add_listval(&pl,
+		    (iac->type == IATYPE_PD) ? DHCP6_LISTVAL_PREFIX6 : DHCP6_LISTVAL_STATEFULADDR6,
+		    &sp->pa, NULL) == NULL)
+			goto fail;
+	}
+
+	ial = xmalloc(sizeof(*ial));
+	TAILQ_INIT(ial);
+	if (dhcp6_add_listval(ial,
+		 (iac->type == IATYPE_PD) ? DHCP6_LISTVAL_IAPD : DHCP6_LISTVAL_IANA,
+		 iaparam, &pl) == NULL)
+		goto fail;
+	dhcp6_clear_list(&pl);
+
+	evd->type = iac->type;
+	evd->data = ial;
+
+	return (0);
+
+  fail:
+	dhcp6_clear_list(&pl);
+	if (ial)
+		free(ial);
+	return (-1);
+}
+
+static struct dhcp6_timer *iapref_timo(void *arg)
+{
+	struct iaprefix *sp = (struct iaprefix *)arg;
+
+	log1("address timeout for %s/%d",
+	    in6addr2str(&sp->pa.addr, 0), sp->pa.plen);
+
+	if (sp->timer)
+		dhcp6_timer_remove(&sp->timer);
+
+	remove_iaprefix(sp, sp->ctl->type);
+
+	(*sp->ctl->callback)(sp->ctl->iactl_ia);
+
+	return (NULL);
+}
+
+static int add_ifprefix(struct iaprefix *iaprefix,
+		struct dhcp6_prefix *prefix, struct prefix_ifconf *pconf)
+{
+	struct dhcp6_ifprefix *ifpfx = NULL;
+	struct in6_addr *a;
+	u_long sla_id;
+	char *sp;
+	int b, i;
+
+	ifpfx = xzalloc(sizeof(*ifpfx));
+
+	ifpfx->ifconf = pconf;
+
+	ifpfx->paddr.sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+	ifpfx->paddr.sin6_len = sizeof(struct sockaddr_in6);
+#endif
+	ifpfx->paddr.sin6_addr = prefix->addr;
+	ifpfx->plen = prefix->plen + pconf->sla_len;
+	/*
+	 * XXX: our current implementation assumes ifid len is a multiple of 8
+	 */
+	if ((pconf->ifid_len % 8) != 0) {
+		bb_error_msg("assumption failure on the length of interface ID");
+		goto bad;
+	}
+	if (ifpfx->plen + pconf->ifid_len < 0 ||
+	    ifpfx->plen + pconf->ifid_len > 128) {
+		bb_info_msg("invalid prefix length %d + %d + %d",
+			prefix->plen, pconf->sla_len, pconf->ifid_len);
+		goto bad;
+	}
+
+	/* copy prefix and SLA ID */
+	a = &ifpfx->paddr.sin6_addr;
+	b = prefix->plen;
+	for (i = 0, b = prefix->plen; b > 0; b -= 8, i++)
+		a->s6_addr[i] = prefix->addr.s6_addr[i];
+	sla_id = htonl(pconf->sla_id);
+	sp = ((char *)&sla_id + 3);
+	i = (128 - pconf->ifid_len) / 8;
+	for (b = pconf->sla_len; b > 7; b -= 8, sp--)
+		a->s6_addr[--i] = *sp;
+	if (b)
+		a->s6_addr[--i] |= *sp;
+
+	/* configure the corresponding address */
+	ifpfx->ifaddr = ifpfx->paddr;
+	for (i = 15; i >= pconf->ifid_len / 8; i--)
+		ifpfx->ifaddr.sin6_addr.s6_addr[i] = pconf->ifid[i];
+	if (pd_ifaddrconf(IFADDRCONF_ADD, ifpfx))
+		goto bad;
+
+	/* TODO: send a control message for other processes */
+
+	TAILQ_INSERT_TAIL(&iaprefix->u.ifprefix_list, ifpfx, plink);
+
+	return (0);
+
+  bad:
+	if (ifpfx)
+		free(ifpfx);
+	return (-1);
+}
+
+static ALWAYS_INLINE int pd_ifaddrconf(ifaddrconf_cmd_t cmd, struct dhcp6_ifprefix *ifpfx)
+{
+	return (ifaddrconf(cmd, ifpfx->ifconf->ifname,
+	    &ifpfx->ifaddr, ifpfx->plen,
+	    DHCP6_DURATION_INFINITE, DHCP6_DURATION_INFINITE));
+}
+
+static int na_ifaddrconf(ifaddrconf_cmd_t cmd, struct iaprefix *sa)
+{
+	struct sockaddr_in6 sin6;
+
+	memset(&sin6, 0, sizeof(sin6));
+	sin6.sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+	sin6.sin6_len = sizeof(sin6);
+#endif
+	sin6.sin6_addr = sa->pa.addr;
+
+	return (ifaddrconf(cmd, sa->u.dhcpif->ifname, &sin6, 128,
+		sa->pa.pltime, sa->pa.vltime));
+}
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/dhcp6c_ia.h busybox/networking/udhcp/dhcp6c_ia.h
--- busybox.orig/networking/udhcp/dhcp6c_ia.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c_ia.h	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+struct ia;			/* this is an opaque type */
+
+TAILQ_HEAD(iaprefix_list, iaprefix);
+
+struct iaprefix {
+	TAILQ_ENTRY(iaprefix) link;
+
+	struct dhcp6_prefix pa;
+	time_t updatetime;
+	struct dhcp6_timer *timer;
+	struct iactl *ctl;
+
+	union {
+		TAILQ_HEAD(, dhcp6_ifprefix) ifprefix_list; /* interface prefixes */
+		struct dhcp6_if *dhcpif;
+	} u;
+};
+
+struct dhcp6_ifprefix {
+	TAILQ_ENTRY(dhcp6_ifprefix) plink;
+
+	/* interface configuration */
+	struct prefix_ifconf *ifconf;
+
+	/* interface prefix parameters */
+	struct sockaddr_in6 paddr;
+	int plen;
+
+	/* address assigned on the interface based on the prefix */
+	struct sockaddr_in6 ifaddr;
+};
+
+struct iactl {
+	struct ia *iactl_ia;	/* back pointer to IA */
+
+	/* callback function called when something may happen on the IA */
+	void (*callback)(struct ia *);
+
+	iatype_t type;
+
+        struct pifc_list *pifc_head;
+        struct iaprefix_list iaprefix_head;
+};
+
+void update_ia(iatype_t, struct dhcp6_list *,
+	struct dhcp6_if *, struct duid *, struct authparam *);
+void release_all_ia(struct dhcp6_if *);
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/dhcp6c_script.c busybox/networking/udhcp/dhcp6c_script.c
--- busybox.orig/networking/udhcp/dhcp6c_script.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c_script.c	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+
+#include <netinet/in.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <errno.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "dhcp6c.h"
+
+static int safefile(const char *);
+
+
+typedef struct {
+	const char *name;
+	int elem_type;               /* ==0 for strlen() */
+	size_t list_off;
+} envp_list_t;
+
+static const envp_list_t client6_envp_list[] = {
+    { "new_sip_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, sip_list)       },
+    { "new_sip_name",				    0, offsetof(struct dhcp6_optinfo, sipname_list)   },
+    { "new_domain_name_servers",  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, dns_list)       },
+    { "new_domain_name", 			    0, offsetof(struct dhcp6_optinfo, dnsname_list)   },
+    { "new_ntp_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, ntp_list)       },
+    { "new_nis_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, nis_list)       },
+    { "new_nis_name", 				    0, offsetof(struct dhcp6_optinfo, nisname_list)   },
+    { "new_nisp_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, nisp_list)      },
+    { "new_nisp_name",				    0, offsetof(struct dhcp6_optinfo, nispname_list)  },
+    { "new_bcmcs_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, bcmcs_list)     },
+    { "new_bcmcs_name",				    0, offsetof(struct dhcp6_optinfo, bcmcsname_list) },
+};
+
+char **fill_envp_client6(struct dhcp6_optinfo *optinfo, char *ifname)
+{
+	char reason[] = "REASON=NBI";
+	int i, sz, envc, elen;
+	char **envp, **curr;
+	struct dhcp6_listval *v;
+	int elens[ARRAY_SIZE(client6_envp_list)];
+
+	envc = 3;     /* we at least include the interface,reason and the terminator */
+
+	/* count the number of variables & total env. length */
+	for (i=0; i < ARRAY_SIZE(client6_envp_list); i++)
+	{
+	    sz = 0;
+	    v = TAILQ_FIRST((struct dhcp6_list *)(((void *)optinfo) + client6_envp_list[i].list_off));
+	    while (v)
+	    {
+		switch (client6_envp_list[i].elem_type) {
+		    case 0:
+			    sz += v->val_vbuf.dv_len + 1;
+			    break;
+		    case DHCP6_LISTVAL_ADDR6:
+			    sz += INET6_ADDRSTRLEN + 1 + 1;
+			    break;
+		}
+		v = TAILQ_NEXT(v, link);
+	    }
+	    elens[i] = sz;
+	    envc += sz ? 1 : 0;
+	}
+
+	/* allocate an environments array */
+	curr = envp = xzalloc(sizeof(char *) * envc);
+
+	/*
+	 * Copy the parameters as environment variables
+	 */
+	/* reason */
+	*curr = xstrdup(reason);
+	putenv(*curr++);
+	/* interface name */
+	*curr = xasprintf("interface=%s", ifname);
+	putenv(*curr++);
+
+	/* "var=addr1 addr2 ... addrN" + null char for termination */
+	for (i=0; i < ARRAY_SIZE(client6_envp_list); i++) {
+	    if (elens[i] > 0) {
+		elen = strlen(client6_envp_list[i].name) + 1 + elens[i];
+		*curr = xzalloc(elen);
+		snprintf(*curr, elen, "%s=", client6_envp_list[i].name);
+
+		for (v = TAILQ_FIRST((struct dhcp6_list *)(((void *)optinfo) + client6_envp_list[i].list_off)); v;
+		    v = TAILQ_NEXT(v, link)) {
+			char *a;
+			/* since we count total length above, it is safely to use strcat() */
+			switch (client6_envp_list[i].elem_type) {
+			    case 0:
+				    strcat(*curr, v->val_vbuf.dv_buf);
+				    strcat(*curr, " ");
+				    break;
+			    case DHCP6_LISTVAL_ADDR6:
+				    a = in6addr2str(&v->val_addr6, 0);
+				    strcat(*curr, a);
+				    strcat(*curr, " ");
+				    free(a);
+				    break;
+			}
+		}
+		putenv(*curr++);
+	    }
+	}
+
+	return envp;
+}
+
+#if ENABLE_DHCP6RELAY
+static const envp_list_t relay6_envp_list[] = {
+    { "iapd_%d=",        DHCP6_LISTVAL_PREFIX6, offsetof(struct dhcp6_optinfo, iapd_list) },
+    { "iana_%d=",  DHCP6_LISTVAL_STATEFULADDR6, offsetof(struct dhcp6_optinfo, iana_list) },
+};
+
+static char *ia2str(int, struct dhcp6_listval *, const char *);
+
+char **fill_envp_relay6(struct dhcp6_optinfo *optinfo, char *clientaddr)
+{
+	int i, j, envc;
+	char **envp, **curr;
+	struct dhcp6_listval *v;
+
+	envc = 2;     /* we at least include the address and the terminator */
+
+	/* count the number of variables */
+	for (i=0; i < ARRAY_SIZE(relay6_envp_list); i++) {
+		v = TAILQ_FIRST((struct dhcp6_list *)(((void *)optinfo) + relay6_envp_list[i].list_off));
+		while (v) {
+			envc++;
+			v = TAILQ_NEXT(v, link);
+		}
+	}
+
+	/* allocate an environments array */
+	curr = envp = xzalloc(sizeof(char *) * envc);
+
+	/*
+	 * Copy the parameters as environment variables
+	 */
+	/* address */
+	*curr = xasprintf("client=%s", clientaddr);
+	putenv(*curr++);
+	/* IAs */
+	for (i=0; i < ARRAY_SIZE(relay6_envp_list); i++) {
+		j = 0;
+		v = TAILQ_FIRST((struct dhcp6_list *)(((void *)optinfo) + relay6_envp_list[i].list_off));
+		while (v) {
+
+			if ((*curr = ia2str(j++, v, relay6_envp_list[i].name)) == NULL)
+				return NULL;
+
+			putenv(*curr++);
+			v = TAILQ_NEXT(v, link);
+		}
+	}
+
+	return envp;
+}
+
+
+static char *ia2str(int num, struct dhcp6_listval *iav, const char *fmt)
+{
+	struct dhcp6_listval *siav;
+	char *s, *r;
+	const char *comma;
+	int len;
+
+#define IASTR_MAXSIZE	((16/*name*/ + (INET6_ADDRSTRLEN + 1)/*addr6*/ + 4/*prefix*/ + 1) * 32)
+	if ((s = malloc_or_warn(IASTR_MAXSIZE)) == NULL)
+		return NULL;
+	memset(s, 0, IASTR_MAXSIZE);
+	len = 0;
+
+	len += snprintf(s, IASTR_MAXSIZE, fmt, num);
+	comma = "";
+
+	for (siav = TAILQ_FIRST(&iav->sublist); siav;
+	    siav = TAILQ_NEXT(siav, link)) {
+		if (len >= IASTR_MAXSIZE)
+			goto out;
+		switch (siav->type) {
+		case DHCP6_LISTVAL_STATEFULADDR6:
+			r = in6addr2str(&siav->val_statefuladdr6.addr, 0);
+			len += snprintf(s + len, IASTR_MAXSIZE - len,
+			    "%s%s", comma, r);
+			free(r);
+			break;
+
+		case DHCP6_LISTVAL_PREFIX6:
+			r = in6addr2str(&siav->val_prefix6.addr, 0);
+			len += snprintf(s + len, IASTR_MAXSIZE - len,
+			    "%s%s/%d", comma, r, siav->val_prefix6.plen);
+			free(r);
+			break;
+
+		case DHCP6_LISTVAL_STCODE:
+			len += snprintf(s + len, IASTR_MAXSIZE - len,
+			    "%s#%d", comma, siav->val_num16);
+			break;
+
+		default:
+			bb_error_msg("impossible subopt");
+		}
+		comma = ",";
+	}
+ out:
+	return s;
+}
+#endif /* ENABLE_DHCP6RELAY */
+
+static int ALWAYS_INLINE safefile(const char *path)
+{
+	struct stat s;
+	uid_t myuid;
+
+	/* no setuid */
+	if (getuid() != geteuid()) {
+		bb_info_msg("setuid'ed execution not allowed");
+		return (-1);
+	}
+
+	if (lstat(path, &s) != 0)
+		return (-1);
+
+	/* the file must be owned by the running uid */
+	myuid = getuid();
+	if (s.st_uid != myuid) {
+		bb_info_msg("%s has invalid owner uid", path);
+		return (-1);
+	}
+
+	switch (s.st_mode & S_IFMT) {
+	case S_IFREG:
+	case S_IFLNK:
+		break;
+	default:
+		bb_info_msg("%s is an invalid file type 0x%o",
+		    path, (s.st_mode & S_IFMT));
+		return (-1);
+	}
+
+	return (0);
+}
+
+int dhcp6_script(const char *scriptpath, char **envp)
+{
+	char *argv[2];
+
+        /* if a script is not specified, do nothing */
+        if (strlen(scriptpath) == 0)
+                return -2;
+
+	if (safefile(scriptpath)) {
+		bb_error_msg("script \"%s\" cannot be executed safely",
+			    scriptpath);
+		return -2;
+	}
+	/* launch the script */
+	argv[0] = (char *)scriptpath;
+	argv[1] = NULL;
+	spawn_and_wait(argv);
+
+	/* free env */
+	if (envp != NULL) {
+		char **curr;
+
+		for (curr = envp; *curr; curr++) {
+			bb_unsetenv_and_free(*curr);
+		}
+		free(envp);
+	}
+	return 0;
+}
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/dhcp6.h busybox/networking/udhcp/dhcp6.h
--- busybox.orig/networking/udhcp/dhcp6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6.h	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,393 @@
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __DHCP6_H_DEFINED
+#define __DHCP6_H_DEFINED
+
+#ifdef __sun__
+#ifndef CMSG_SPACE
+#define	CMSG_SPACE(l) \
+	((unsigned int)_CMSG_HDR_ALIGN(sizeof(struct cmsghdr) + (l)))
+#endif
+#ifndef CMSG_LEN
+#define	CMSG_LEN(l) \
+	((unsigned int)_CMSG_DATA_ALIGN(sizeof(struct cmsghdr)) + (l))
+#endif
+#endif
+
+/* Error Values */
+#define DH6ERR_FAILURE		16
+#define DH6ERR_AUTHFAIL		17
+#define DH6ERR_POORLYFORMED	18
+#define DH6ERR_UNAVAIL		19
+#define DH6ERR_OPTUNAVAIL	20
+
+/* Message type */
+#define DH6_SOLICIT	1
+#define DH6_ADVERTISE	2
+#define DH6_REQUEST	3
+#define DH6_CONFIRM	4
+#define DH6_RENEW	5
+#define DH6_REBIND	6
+#define DH6_REPLY	7
+#define DH6_RELEASE	8
+#define DH6_DECLINE	9
+#define DH6_RECONFIGURE	10
+#define DH6_INFORM_REQ	11
+#define DH6_RELAY_FORW	12
+#define DH6_RELAY_REPLY	13
+
+/* Predefined addresses */
+#define DH6ADDR_ALLAGENT	"ff02::1:2"
+#define DH6ADDR_ALLSERVER	"ff05::1:3"
+#define DH6PORT_DOWNSTREAM	"546"
+#define DH6PORT_UPSTREAM	"547"
+
+/* Protocol constants */
+
+/* timer parameters (msec, unless explicitly commented) */
+#define SOL_MAX_DELAY	1000
+#define SOL_TIMEOUT	1000
+#define SOL_MAX_RT	120000
+#define INF_TIMEOUT	1000
+#define INF_MAX_RT	120000
+#define REQ_TIMEOUT	1000
+#define REQ_MAX_RT	30000
+#define REQ_MAX_RC	10	/* Max Request retry attempts */
+#define REN_TIMEOUT	10000	/* 10secs */
+#define REN_MAX_RT	600000	/* 600secs */
+#define REB_TIMEOUT	10000	/* 10secs */
+#define REB_MAX_RT	600000	/* 600secs */
+#define REL_TIMEOUT	1000	/* 1 sec */
+#define REL_MAX_RC	5
+
+#define DHCP6_DURATION_INFINITE 0xffffffff
+#define DHCP6_DURATION_MIN 30
+
+#define DHCP6_RELAY_MULTICAST_HOPS 32
+#define DHCP6_RELAY_HOP_COUNT_LIMIT 32
+
+#define DHCP6_IRT_DEFAULT 86400	/* 1 day */
+#define DHCP6_IRT_MINIMUM 600
+
+/* DUID: DHCP unique Identifier */
+struct duid {
+	size_t duid_len;	/* length */
+	char *duid_id;		/* variable length ID value (must be opaque) */
+};
+
+struct dhcp6_vbuf {		/* generic variable length buffer */
+	int dv_len;
+	caddr_t dv_buf;
+};
+
+/* option information */
+struct dhcp6_ia {		/* identity association */
+	uint32_t iaid;
+	uint32_t t1;
+	uint32_t t2;
+};
+
+struct dhcp6_prefix {		/* IA_PD */
+	uint32_t pltime;
+	uint32_t vltime;
+	struct in6_addr addr;
+	int plen;
+};
+
+struct dhcp6_statefuladdr {	/* IA_NA */
+	uint32_t pltime;
+	uint32_t vltime;
+	struct in6_addr addr;
+};
+
+/* Internal data structure */
+typedef enum { DHCP6_LISTVAL_NUM = 1,
+	       DHCP6_LISTVAL_STCODE, DHCP6_LISTVAL_ADDR6,
+	       DHCP6_LISTVAL_IAPD, DHCP6_LISTVAL_PREFIX6,
+	       DHCP6_LISTVAL_IANA, DHCP6_LISTVAL_STATEFULADDR6,
+	       DHCP6_LISTVAL_VBUF
+} dhcp6_listval_type_t;
+TAILQ_HEAD(dhcp6_list, dhcp6_listval);
+struct dhcp6_listval {
+	TAILQ_ENTRY(dhcp6_listval) link;
+
+	dhcp6_listval_type_t type;
+
+	union {
+		int uv_num;
+		uint16_t uv_num16;
+		struct in6_addr uv_addr6;
+		struct dhcp6_prefix uv_prefix6;
+		struct dhcp6_statefuladdr uv_statefuladdr6;
+		struct dhcp6_ia uv_ia;
+		struct dhcp6_vbuf uv_vbuf;
+	} uv;
+
+	struct dhcp6_list sublist;
+};
+#define val_num uv.uv_num
+#define val_num16 uv.uv_num16
+#define val_addr6 uv.uv_addr6
+#define val_ia uv.uv_ia
+#define val_prefix6 uv.uv_prefix6
+#define val_statefuladdr6 uv.uv_statefuladdr6
+#define val_vbuf uv.uv_vbuf
+
+struct dhcp6_optinfo {
+	struct duid clientID;	/* DUID */
+	struct duid serverID;	/* DUID */
+
+	int rapidcommit;	/* bool */
+	int pref;		/* server preference */
+	int32_t elapsed_time;	/* elapsed time (from client to server only) */
+	int64_t refreshtime;	/* info refresh time for stateless options */
+
+	struct dhcp6_list iapd_list; /* list of IA_PD */
+	struct dhcp6_list iana_list; /* list of IA_NA */
+	struct dhcp6_list reqopt_list; /* options in option request */
+	struct dhcp6_list stcode_list; /* status code */
+	struct dhcp6_list sip_list; /* SIP server list */
+	struct dhcp6_list sipname_list; /* SIP domain list */
+	struct dhcp6_list dns_list; /* DNS server list */
+	struct dhcp6_list dnsname_list; /* Domain Search list */
+	struct dhcp6_list ntp_list; /* NTP server list */
+	struct dhcp6_list prefix_list; /* prefix list */
+	struct dhcp6_list nis_list; /* NIS server list */
+	struct dhcp6_list nisname_list; /* NIS domain list */
+	struct dhcp6_list nisp_list; /* NIS+ server list */
+	struct dhcp6_list nispname_list; /* NIS+ domain list */
+	struct dhcp6_list bcmcs_list; /* BCMC server list */
+	struct dhcp6_list bcmcsname_list; /* BCMC domain list */
+
+	struct dhcp6_vbuf relay_msg; /* relay message */
+#define relaymsg_len relay_msg.dv_len
+#define relaymsg_msg relay_msg.dv_buf
+
+	struct dhcp6_vbuf ifidopt; /* Interface-id */
+#define ifidopt_len ifidopt.dv_len
+#define ifidopt_id ifidopt.dv_buf
+
+	uint16_t authflags;
+#define DHCP6OPT_AUTHFLAG_NOINFO	0x1
+	int authproto;
+	int authalgorithm;
+	int authrdm;
+	/* the followings are effective only when NOINFO is unset */
+	uint64_t authrd;
+	union {
+		struct {
+			uint32_t keyid;
+			struct dhcp6_vbuf realm;
+			int offset; /* offset to the HMAC field */
+		} aiu_delayed;
+		struct {
+			int type;
+			int offset; /* offset to the HMAC field */
+			char val[16]; /* key value */
+		} aiu_reconfig;
+	} authinfo;
+#define delayedauth_keyid authinfo.aiu_delayed.keyid
+#define delayedauth_realmlen authinfo.aiu_delayed.realm.dv_len
+#define delayedauth_realmval authinfo.aiu_delayed.realm.dv_buf
+#define delayedauth_offset authinfo.aiu_delayed.offset
+#define reconfigauth_type authinfo.aiu_reconfig.type
+#define reconfigauth_offset authinfo.aiu_reconfig.offset
+#define reconfigauth_val authinfo.aiu_reconfig.val
+};
+
+/* DHCP6 base packet format */
+struct dhcp6 {
+	union {
+		uint8_t m;
+		uint32_t x;
+	} dh6_msgtypexid;
+	/* options follow */
+} __attribute__ ((__packed__));
+#define dh6_msgtype	dh6_msgtypexid.m
+#define dh6_xid		dh6_msgtypexid.x
+#define DH6_XIDMASK	0x00ffffff
+
+/* DHCPv6 relay messages */
+struct dhcp6_relay {
+	uint8_t dh6relay_msgtype;
+	uint8_t dh6relay_hcnt;
+	struct in6_addr dh6relay_linkaddr; /* XXX: badly aligned */
+	struct in6_addr dh6relay_peeraddr; /* ditto */
+	/* options follow */
+} __attribute__ ((__packed__));
+
+/* options */
+#define DH6OPT_CLIENTID	1
+#define DH6OPT_SERVERID	2
+#define DH6OPT_IA_NA 3
+#define DH6OPT_IA_TA 4
+#define DH6OPT_IAADDR 5
+#define DH6OPT_ORO 6
+#define DH6OPT_PREFERENCE 7
+#  define DH6OPT_PREF_UNDEF -1
+#  define DH6OPT_PREF_MAX 255
+#define DH6OPT_ELAPSED_TIME 8
+#  define DH6OPT_ELAPSED_TIME_UNDEF -1
+#define DH6OPT_RELAY_MSG 9
+/* #define DH6OPT_SERVER_MSG 10: deprecated */
+#define DH6OPT_AUTH 11
+#  define DH6OPT_AUTH_PROTO_DELAYED 2
+#  define DH6OPT_AUTH_RRECONFIGURE 3
+#  define DH6OPT_AUTH_ALG_HMACMD5 1
+#define DH6OPT_UNICAST 12
+#define DH6OPT_STATUS_CODE 13
+#  define DH6OPT_STCODE_SUCCESS 0
+#  define DH6OPT_STCODE_UNSPECFAIL 1
+#  define DH6OPT_STCODE_NOADDRSAVAIL 2
+#  define DH6OPT_STCODE_NOBINDING 3
+#  define DH6OPT_STCODE_NOTONLINK 4
+#  define DH6OPT_STCODE_USEMULTICAST 5
+#  define DH6OPT_STCODE_NOPREFIXAVAIL 6
+
+#define DH6OPT_RAPID_COMMIT 14
+#define DH6OPT_USER_CLASS 15
+#define DH6OPT_VENDOR_CLASS 16
+#define DH6OPT_VENDOR_OPTS 17
+#define DH6OPT_INTERFACE_ID 18
+#define DH6OPT_RECONF_MSG 19
+
+#define DH6OPT_SIP_SERVER_D 21
+#define DH6OPT_SIP_SERVER_A 22
+#define DH6OPT_DNS 23
+#define DH6OPT_DNSNAME 24
+#define DH6OPT_IA_PD 25
+#define DH6OPT_IA_PD_PREFIX 26
+#define DH6OPT_NIS_SERVERS 27
+#define DH6OPT_NISP_SERVERS 28
+#define DH6OPT_NIS_DOMAIN_NAME 29
+#define DH6OPT_NISP_DOMAIN_NAME 30
+#define DH6OPT_NTP 31
+#define DH6OPT_REFRESHTIME 32
+ #define DH6OPT_REFRESHTIME_UNDEF -1
+#define DH6OPT_BCMCS_SERVER_D 33
+#define DH6OPT_BCMCS_SERVER_A 34
+#define DH6OPT_GEOCONF_CIVIC 36
+#define DH6OPT_REMOTE_ID 37
+#define DH6OPT_SUBSCRIBER_ID 38
+#define DH6OPT_CLIENT_FQDN 39
+
+/* The followings are KAME specific. */
+
+struct dhcp6opt {
+	uint16_t dh6opt_type;
+	uint16_t dh6opt_len;
+	/* type-dependent data follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 1 (DUID-LLT) */
+struct dhcp6opt_duid_type1 {
+	uint16_t dh6_duid1_type;
+	uint16_t dh6_duid1_hwtype;
+	uint32_t dh6_duid1_time;
+	/* link-layer address follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 2 (DUID-EN) */
+struct dhcp6opt_duid_type2 {
+	uint16_t dh6_duid2_type;
+	uint32_t dh6_duid2_enterprise_number;
+	/* identifier follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 3 (DUID-LL) */
+struct dhcp6opt_duid_type3 {
+	uint16_t dh6_duid3_type;
+	uint16_t dh6_duid3_hwtype;
+	/* link-layer address follows */
+} __attribute__ ((__packed__));
+
+union dhcp6opt_duid_type {
+	struct dhcp6opt_duid_type1	d1;
+	struct dhcp6opt_duid_type2	d2;
+	struct dhcp6opt_duid_type3	d3;
+};
+
+/* Status Code */
+struct dhcp6opt_stcode {
+	uint16_t dh6_stcode_type;
+	uint16_t dh6_stcode_len;
+	uint16_t dh6_stcode_code;
+} __attribute__ ((__packed__));
+
+/*
+ * General format of Identity Association.
+ * This format applies to Prefix Delegation (IA_PD) and Non-temporary Addresses
+ * (IA_NA)
+ */
+struct dhcp6opt_ia {
+	uint16_t dh6_ia_type;
+	uint16_t dh6_ia_len;
+	uint32_t dh6_ia_iaid;
+	uint32_t dh6_ia_t1;
+	uint32_t dh6_ia_t2;
+	/* sub options follow */
+} __attribute__ ((__packed__));
+
+/* IA Addr */
+struct dhcp6opt_ia_addr {
+	uint16_t dh6_ia_addr_type;
+	uint16_t dh6_ia_addr_len;
+	struct in6_addr dh6_ia_addr_addr;
+	uint32_t dh6_ia_addr_preferred_time;
+	uint32_t dh6_ia_addr_valid_time;
+} __attribute__ ((__packed__));
+
+/* IA_PD Prefix */
+struct dhcp6opt_ia_pd_prefix {
+	uint16_t dh6_iapd_prefix_type;
+	uint16_t dh6_iapd_prefix_len;
+	uint32_t dh6_iapd_prefix_preferred_time;
+	uint32_t dh6_iapd_prefix_valid_time;
+	uint8_t dh6_iapd_prefix_prefix_len;
+	struct in6_addr dh6_iapd_prefix_prefix_addr;
+} __attribute__ ((__packed__));
+
+/* Authentication */
+struct dhcp6opt_auth {
+	uint16_t dh6_auth_type;
+	uint16_t dh6_auth_len;
+	uint8_t dh6_auth_proto;
+	uint8_t dh6_auth_alg;
+	uint8_t dh6_auth_rdm;
+	uint8_t dh6_auth_rdinfo[8];
+	/* authentication information follows */
+} __attribute__ ((__packed__));
+
+enum { DHCP6_AUTHPROTO_UNDEF = -1, DHCP6_AUTHPROTO_DELAYED = 2,
+       DHCP6_AUTHPROTO_RECONFIG = 3 };
+enum { DHCP6_AUTHALG_UNDEF = -1, DHCP6_AUTHALG_HMACMD5 = 1 };
+enum { DHCP6_AUTHRDM_UNDEF = -1, DHCP6_AUTHRDM_MONOCOUNTER = 0 };
+
+#endif /*__DHCP6_H_DEFINED*/
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/dhcp6relay.c busybox/networking/udhcp/dhcp6relay.c
--- busybox.orig/networking/udhcp/dhcp6relay.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6relay.c	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,886 @@
+/*
+ * DHCPv6 relay
+ *
+ * Copyright (C) 2000 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Original code taken from wide-dhcpv6-20080615 and converted into
+ * a busybox applet by Leonid Lisovskiy <lly@sf.net>
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+#include <sys/uio.h>
+#include <sys/signal.h>
+
+#include <net/if.h>
+#ifdef __FreeBSD__
+#include <net/if_var.h>
+#endif
+
+#include <netinet/in.h>
+
+#include <netdb.h>
+#include <arpa/inet.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <stdlib.h>		/* XXX: freebsd2 needs this for opt{arg,ind} */
+#include <errno.h>
+#include <err.h>
+#include <string.h>
+
+/* Override ENABLE_FEATURE_PIDFILE */
+#define WANT_PIDFILE 1
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "dhcp6c.h"
+
+#define DHCP6RELAY_PIDFILE "/var/run/dhcp6relay.pid"
+
+
+struct ifid_list {
+	TAILQ_ENTRY(ifid_list) ilink;
+	unsigned int ifid;
+};
+
+struct prefix_t {
+	struct in6_addr addr;
+	int plen;
+};
+
+/* list of non-link-local prefixes */
+static const struct prefix_t global_prefixes[] = {
+/*{ {{{0xfe,0xc0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, 10 },    "fec0::/10" site-local unicast addresses were deprecated */
+  { {{{0x20,0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, 3  }, /* "2000::/3" */
+  { {{{0xfc,0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, 7  }, /* "FC00::/7"  Unique Local Address (RFC4193) */
+};
+
+struct globals {
+	struct sockaddr_in6 sa6_server, sa6_client;
+
+	struct msghdr rmh;
+	struct iovec rmhiov[2];
+	int mhops;
+
+	const char *relaydevice;
+	const char *boundaddr;
+	const char *serveraddr;
+	const char *scriptpath;
+	const char *pid_file;
+
+	TAILQ_HEAD(, ifid_list) ifids_list;
+	int relayifid;
+
+	int ssock;		/* socket for relaying to servers */
+	int csock;		/* socket for clients */
+	int maxfd;		/* maxi file descriptor for select(2) */
+
+	char rmsgctlbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+	u_char relaybuf[sizeof(struct dhcp6_relay) + BUFSIZ];
+	char   rdatabuf[BUFSIZ];
+};
+
+#define G (*ptr_to_globals)
+#define sa6_server	(G.sa6_server  )
+#define sa6_client	(G.sa6_client  )
+#define rmh		(G.rmh         )
+#define mhops		(G.mhops       )
+#define relayifid	(G.relayifid   )
+#define rmhiov		(G.rmhiov      )
+#define ssock		(G.ssock       )
+#define csock		(G.csock       )
+#define maxfd		(G.maxfd       )
+#define INIT_G() do { \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+	mhops = DHCP6_RELAY_MULTICAST_HOPS; \
+	G.serveraddr = DH6ADDR_ALLSERVER; \
+	G.boundaddr = "::"; \
+	G.pid_file = DHCP6RELAY_PIDFILE; \
+	G.scriptpath = NULL; \
+	G.relaydevice = NULL; \
+} while (0)
+
+
+
+static void relay6_init(int, char *[]);
+static void relay6_loop(void);
+static void relay6_recv(int, int);
+static int make_msgcontrol(struct msghdr *, void *, socklen_t,
+    struct in6_pktinfo *, int);
+static void relay_to_server(struct dhcp6 *, ssize_t,
+    struct sockaddr_in6 *, char *, unsigned int);
+static void relay_to_client(struct dhcp6_relay *, ssize_t,
+    struct sockaddr *);
+
+
+//usage:#define dhcp6relay_trivial_usage
+//usage:       "[-vf] [-b boundaddr] [-H hoplim]\n"
+//usage:       "	[-r relay-IF] [-s serveraddr] [-p pidfile] [-S script] interface"
+//usage:#define dhcp6relay_full_usage "\n"
+//usage:      "\n	-v		Print debugging messages (may be repeated)"
+//usage:      "\n	-f		Foreground mode"
+//usage:      "\n	-b boundaddr	Source address to relay packets to servers"
+//usage:      "\n	-H hoplim	Hop limit of DHCPv6 Solicit messages forwarded to servers"
+//usage:      "\n	-r relay-IF	Interface on which messages to servers are sent"
+//usage:      "\n	-s serveraddr	DHCPv6 server address to relay packets to."
+//usage:      "\n			If not specified, packets are relayed to ff05::1:3"
+//usage:      "\n	-S script	Script file to be executed when relay receives"
+//usage:      "\n			a RELAY-REPLY message from a DHCPv6 server"
+//usage:      "\n	-p pidfile	Use pid-file to dump the process ID"
+
+enum {
+	OPT_FOREGROUND = 1 << 0,
+	OPT_b = 1 << 1,
+	OPT_H = 1 << 2,
+	OPT_r = 1 << 3,
+	OPT_s = 1 << 4,
+	OPT_S = 1 << 5,
+	OPT_p = 1 << 6,
+	OPT_VERBOSE = 1 << 7,
+};
+
+int dhcp6relay_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int dhcp6relay_main(int argc, char **argv)
+{
+	const char *str_H;
+	int opt;
+
+	INIT_G();
+
+	opt_complementary = ""
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+		":vv"
+#endif
+		;
+	opt = getopt32(argv, "fb:H:r:s:S:p:v",
+			&G.boundaddr, &str_H, &G.relaydevice, &G.serveraddr,
+			&G.scriptpath, &G.pid_file
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+			,&dhcp_verbose
+#endif
+			);
+	if (opt & OPT_H) {
+		char *p = NULL;
+
+		mhops = (int)strtoul(str_H, &p, 10);
+		if (!*str_H || *p) {
+			bb_error_msg_and_die("illegal hop limit: %s", str_H);
+			/* NOTREACHED */
+		}
+		if (mhops <= 0 || mhops > 255) {
+			bb_error_msg_and_die("illegal hop limit: %d", mhops);
+			/* NOTREACHED */
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+	if (G.relaydevice == NULL) {
+		if (argc > 1) {
+			bb_error_msg("you should explicitly specify a "
+			    "relaying interface, when you are to "
+			    "listen on multiple interfaces\n");
+		}
+		if (argc != 1) {
+			bb_show_usage();
+			return(1);
+		}
+		G.relaydevice = argv[0];
+	}
+
+	if (!(option_mask32 & OPT_FOREGROUND)) {
+		bb_daemonize_or_rexec(DAEMON_CLOSE_EXTRA_FDS, argv);
+		openlog(applet_name, LOG_PID, LOG_DAEMON);
+		logmode = LOGMODE_SYSLOG;
+	}
+
+	/* dump current PID */
+	write_pidfile(G.pid_file);
+
+	relay6_init(argc, argv);
+
+	bb_info_msg("%s started", applet_name);
+	relay6_loop();
+	remove_pidfile(G.pid_file);
+
+	return (0);
+}
+
+static int socket6_init(struct addrinfo *res)
+{
+	int sock, on;
+
+	sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+	if (sock < 0) {
+		bb_error_msg_and_die("socket: %s", strerror(errno));
+	}
+	if (sock > maxfd)
+		maxfd = sock;
+
+	/*
+	 * Both a relay and a client may run on a single node.  If we need to
+	 * listen on the downstream port, we need REUSEPORT to avoid conflict.
+	 */
+	on = 1;
+	if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT,
+	    &on, sizeof(on)) < 0) {
+		bb_error_msg_and_die("setsockopt(SO_REUSEPORT): %s",
+		    strerror(errno));
+	}
+#ifdef IPV6_V6ONLY
+	if (setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY,
+	    &on, sizeof(on)) < 0) {
+		bb_error_msg_and_die("setsockopt(IPV6_V6ONLY): %s",
+		    strerror(errno));
+	}
+#endif
+	if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
+		bb_error_msg_and_die("bind: %s", strerror(errno));
+	}
+	freeaddrinfo(res);
+
+	on = 1;
+#ifdef IPV6_RECVPKTINFO
+	if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
+		       sizeof(on)) < 0) {
+		bb_error_msg_and_die("setsockopt(IPV6_RECVPKTINFO): %s",
+			strerror(errno));
+	}
+#else
+	if (setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
+		       sizeof(on)) < 0) {
+		bb_error_msg_and_die("setsockopt(IPV6_PKTINFO): %s",
+			strerror(errno));
+	}
+#endif
+	return sock;
+}
+
+static void relay6_init(int ifnum, char *iflist[])
+{
+	struct addrinfo hints;
+	struct addrinfo *res, *res2;
+	int error;
+	struct ipv6_mreq mreq6;
+
+	/* initialize special socket addresses */
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(G.serveraddr, DH6PORT_UPSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	if (res->ai_family != PF_INET6 ||
+	    res->ai_addrlen < sizeof(sa6_server)) {
+		/* this should be impossible, but check for safety */
+		bb_error_msg_and_die("getaddrinfo returned a bogus address: %s",
+		    strerror(errno));
+	}
+	/* XXX: assume only one DHCPv6 server address */
+	memcpy(&sa6_server, res->ai_addr, sizeof(sa6_server));
+	freeaddrinfo(res);
+
+	/* initialize send/receive buffer */
+	rmhiov[0].iov_base = (caddr_t)G.rdatabuf;
+	rmhiov[0].iov_len = sizeof(G.rdatabuf);
+	rmh.msg_iov = rmhiov;
+	rmh.msg_iovlen = 1;
+
+	/*
+	 * Setup a socket to communicate with clients.
+	 */
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(NULL, DH6PORT_UPSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	csock = socket6_init(res);
+
+	hints.ai_flags = 0;
+	error = getaddrinfo(DH6ADDR_ALLAGENT, 0, &hints, &res2);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	memset(&mreq6, 0, sizeof(mreq6));
+	memcpy(&mreq6.ipv6mr_multiaddr,
+	    &((struct sockaddr_in6 *)res2->ai_addr)->sin6_addr,
+	    sizeof(mreq6.ipv6mr_multiaddr));
+
+	TAILQ_INIT(&G.ifids_list);
+	while (ifnum-- > 0) {
+		char *ifp = iflist[0];
+		struct ifid_list *ifd;
+
+		ifd = (struct ifid_list *)xzalloc(sizeof(*ifd));
+		ifd->ifid = if_nametoindex(ifp);
+		if (ifd->ifid == 0) {
+			bb_error_msg_and_die("invalid interface %s", ifp);
+		}
+		mreq6.ipv6mr_interface = ifd->ifid;
+
+		if (setsockopt(csock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
+		    &mreq6, sizeof(mreq6))) {
+			bb_error_msg_and_die("setsockopt(IPV6_JOIN_GROUP): %s",
+			     strerror(errno));
+		}
+		TAILQ_INSERT_TAIL(&G.ifids_list, ifd, ilink);
+		iflist++;
+	}
+	freeaddrinfo(res2);
+
+	/*
+	 * Setup a socket to relay to servers.
+	 */
+	relayifid = if_nametoindex(G.relaydevice);
+	if (relayifid == 0)
+		bb_error_msg("invalid interface %s", G.relaydevice);
+	/*
+	 * We are not really sure if we need to listen on the downstream
+	 * port to receive packets from servers.  We'll need to clarify the
+	 * specification, but we do for now.
+	 */
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(G.boundaddr, DH6PORT_DOWNSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	memcpy(&sa6_client, res->ai_addr, sizeof(sa6_client));
+	ssock = socket6_init(res);
+
+	bb_signals(0 + (1 << SIGTERM), record_signo);
+}
+
+static void relay6_loop(void)
+{
+	fd_set readfds;
+	int e;
+
+	while (!bb_got_signal) {
+
+		/* we'd rather use FD_COPY here, but it's not POSIX friendly */
+		FD_ZERO(&readfds);
+		FD_SET(csock, &readfds);
+		FD_SET(ssock, &readfds);
+
+		e = select(maxfd + 1, &readfds, NULL, NULL, NULL);
+		switch (e) {
+		case 0:		/* impossible in our situation */
+		case -1:
+			if (errno != EINTR) {
+				bb_error_msg_and_die("select: %s", strerror(errno));
+				/* NOTREACHED */
+			}
+			continue;
+		default:
+			break;
+		}
+
+		if (FD_ISSET(csock, &readfds))
+			relay6_recv(csock, 1);
+
+		if (FD_ISSET(ssock, &readfds))
+			relay6_recv(ssock, 0);
+	}
+}
+
+static void relay6_recv(int s, int fromclient)
+{
+	ssize_t len;
+	struct sockaddr_storage from;
+	struct in6_pktinfo *pi = NULL;
+	struct cmsghdr *cm;
+	struct dhcp6 *dh6;
+	struct ifid_list *ifd;
+	char ifname[IF_NAMESIZE];
+
+	rmh.msg_control = (caddr_t)G.rmsgctlbuf;
+	rmh.msg_controllen = sizeof(G.rmsgctlbuf);
+
+	rmh.msg_name = &from;
+	rmh.msg_namelen = sizeof(from);
+
+	if ((len = recvmsg(s, &rmh, 0)) < 0) {
+		bb_error_msg("recvmsg: %s", strerror(errno));
+		return;
+	}
+
+	log1("from %s, size %d",
+	    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from), (int )len);
+
+	if (((struct sockaddr *)&from)->sa_family != AF_INET6) {
+		bb_info_msg("non-IPv6 packet is received (AF %d) ",
+		    ((struct sockaddr *)&from)->sa_family);
+		return;
+	}
+
+	/* get optional information as ancillary data (if available) */
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&rmh); cm;
+	     cm = (struct cmsghdr *)CMSG_NXTHDR(&rmh, cm)) {
+		if (cm->cmsg_level != IPPROTO_IPV6)
+			continue;
+
+		switch (cm->cmsg_type) {
+		case IPV6_PKTINFO:
+			pi = (struct in6_pktinfo *)CMSG_DATA(cm);
+			break;
+		}
+	}
+	if (pi == NULL) {
+		bb_info_msg("failed to get the arrival interface");
+		return;
+	}
+	for (ifd = TAILQ_FIRST(&G.ifids_list); ifd;
+	     ifd = TAILQ_NEXT(ifd, ilink)) {
+		if (pi->ipi6_ifindex == ifd->ifid)
+			break;
+	}
+	/*
+	 * DHCPv6 relay may receive a DHCPv6 packet from a non-listening 
+	 * interface, when a DHCPv6 server is running on that interface.
+	 * This check prevents such reception.
+	 */
+	if (ifd == NULL && pi->ipi6_ifindex != relayifid)
+		return;
+	if (if_indextoname(pi->ipi6_ifindex, ifname) == NULL) {
+		bb_info_msg("if_indextoname(id = %d): %s",
+		    pi->ipi6_ifindex, strerror(errno));
+		return;
+	}
+
+	/* packet validation */
+	if (len < sizeof(*dh6)) {
+		bb_info_msg("short packet (%d bytes)", (int )len);
+		return;
+	}
+
+	dh6 = (struct dhcp6 *)G.rdatabuf;
+	log1("received %s from %s",
+	    dhcp6msgstr(dh6->dh6_msgtype), xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from));
+
+	/*
+	 * Relay the packet according to the type.  A client message or
+	 * a relay forward message is forwarded to servers (or other relays),
+	 * and a relay reply message is forwarded to the intended client.
+	 */
+	if (fromclient) {
+		switch (dh6->dh6_msgtype) {
+		case DH6_SOLICIT:
+		case DH6_REQUEST:
+		case DH6_CONFIRM:
+		case DH6_RENEW:
+		case DH6_REBIND:
+		case DH6_RELEASE:
+		case DH6_DECLINE:
+		case DH6_INFORM_REQ:
+		case DH6_RELAY_FORW:
+			relay_to_server(dh6, len, (struct sockaddr_in6 *)&from,
+			    ifname, htonl(pi->ipi6_ifindex));
+			break;
+		case DH6_RELAY_REPLY:
+			/*
+			 * The server may send a relay reply to the client
+			 * port.
+			 * XXX: need to clarify the port issue
+			 */
+			relay_to_client((struct dhcp6_relay *)dh6, len,
+			    (struct sockaddr *)&from);
+			break;
+		default:
+			{
+			char *a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from);
+			bb_info_msg("unexpected message (%s) on the client side "
+			    "from %s", dhcp6msgstr(dh6->dh6_msgtype), a);
+			free(a);
+			break;
+			}
+		}
+	} else {
+		if (dh6->dh6_msgtype != DH6_RELAY_REPLY) {
+			char *a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from);
+			bb_info_msg("unexpected message (%s) on the server side"
+			    "from %s", dhcp6msgstr(dh6->dh6_msgtype), a);
+			free(a);
+			return;
+		}
+		relay_to_client((struct dhcp6_relay *)dh6, len,
+		    (struct sockaddr *)&from);
+	}
+}
+
+static int make_msgcontrol(struct msghdr *mh, void *ctlbuf, socklen_t buflen,
+		struct in6_pktinfo *pktinfo, int hlim)
+{
+	struct cmsghdr *cm;
+	socklen_t controllen;
+
+	controllen = 0;
+	if (pktinfo)
+		controllen += CMSG_SPACE(sizeof(*pktinfo));
+	if (hlim > 0)
+		controllen += CMSG_SPACE(sizeof(hlim));
+	if (buflen < controllen)
+		return (-1);
+
+	memset(ctlbuf, 0, buflen);
+	mh->msg_controllen = controllen;
+	mh->msg_control = ctlbuf;
+
+	cm = (struct cmsghdr *)CMSG_FIRSTHDR(mh);
+	if (pktinfo) {
+		cm->cmsg_len = CMSG_LEN(sizeof(*pktinfo));
+		cm->cmsg_level = IPPROTO_IPV6;
+		cm->cmsg_type = IPV6_PKTINFO;
+		memcpy(CMSG_DATA((struct cmsghdr *)cm), pktinfo,
+		    sizeof(*pktinfo));
+
+		cm = CMSG_NXTHDR(mh, cm);
+	}
+
+	if (hlim > 0) {
+		cm->cmsg_len = CMSG_LEN(sizeof(hlim));
+		cm->cmsg_level = IPPROTO_IPV6;
+		cm->cmsg_type = IPV6_HOPLIMIT;
+		*(int *)CMSG_DATA((struct cmsghdr *)cm) = hlim;
+
+		cm = CMSG_NXTHDR(mh, cm); /* just in case */
+	}
+
+	return (0);
+}
+
+static void relay_to_server(struct dhcp6 *dh6, ssize_t len,
+			    struct sockaddr_in6 *from,
+			    char *ifname, unsigned int ifid)
+{
+	struct dhcp6_optinfo optinfo;
+	struct dhcp6_relay *dh6relay;
+	struct in6_addr linkaddr;
+	int optlen, relaylen;
+	int i, cc;
+	struct msghdr mh;
+	struct iovec iov[2];
+	struct in6_pktinfo pktinfo;
+	char ctlbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))
+	    + CMSG_SPACE(sizeof(int))];
+
+	/*
+	 * Prepare a relay forward option.
+	 */
+	dhcp6_init_options(&optinfo);
+
+	/* Relay message */
+	optinfo.relaymsg_msg = xmalloc(len);
+	optinfo.relaymsg_len = len;
+	memcpy(optinfo.relaymsg_msg, dh6, len);
+
+	/* Interface-id.  We always use this option. */
+	optinfo.ifidopt_id = xmalloc(sizeof(ifid));
+	optinfo.ifidopt_len = sizeof(ifid);
+	memcpy(optinfo.ifidopt_id, &ifid, sizeof(ifid));
+
+	/*
+	 * Construct a relay forward message.
+	 */
+	dh6relay = (struct dhcp6_relay *)G.relaybuf;
+	memset(dh6relay, 0, sizeof(*dh6relay));
+	dh6relay->dh6relay_msgtype = DH6_RELAY_FORW;
+	memcpy(&dh6relay->dh6relay_peeraddr, &from->sin6_addr,
+	    sizeof(dh6relay->dh6relay_peeraddr));
+
+	/* find a global address to fill in the link address field */
+	memset(&linkaddr, 0, sizeof(linkaddr));
+	for (cc=0,i=0; i < ARRAY_SIZE(global_prefixes); i++) {
+		if (getifaddr(&linkaddr, ifname, &global_prefixes[i].addr,
+			      global_prefixes[i].plen, 1) == 0) {/* found */
+			cc = 1;
+			break;
+		}
+	}
+	if (cc == 0) {
+		bb_info_msg("failed to find a global address on %s", ifname);
+
+		/*
+		 * When relaying a message from a client, we need a global
+		 * link address.
+		 * XXX: this may be too strong for the stateless case, but
+		 * the DHCPv6 specification seems to require the behavior. 
+		 */
+		if (dh6->dh6_msgtype != DH6_RELAY_FORW)
+			goto out;
+	}
+
+	if (dh6->dh6_msgtype == DH6_RELAY_FORW) {
+		struct dhcp6_relay *dh6relay0 = (struct dhcp6_relay *)dh6;
+
+		/* Relaying a Message from a Relay Agent */
+
+		/*
+		 * If the hop-count in the message is greater than or equal to
+		 * HOP_COUNT_LIMIT, the relay agent discards the received
+		 * message.
+		 * [RFC3315 Section 20.1.2]
+		 */
+		if (dh6relay0->dh6relay_hcnt >= DHCP6_RELAY_HOP_COUNT_LIMIT) {
+			bb_info_msg("too many relay forwardings");
+			goto out;
+		}
+
+		dh6relay->dh6relay_hcnt = dh6relay0->dh6relay_hcnt + 1;
+
+		/*
+		 * We can keep the link-address field 0, regardless of the
+		 * scope of the source address, since we always include
+		 * interface-ID option.
+		 */
+	} else {
+		/* Relaying a Message from a Client */
+		memcpy(&dh6relay->dh6relay_linkaddr, &linkaddr,
+		    sizeof(dh6relay->dh6relay_linkaddr));
+		dh6relay->dh6relay_hcnt = 0;
+	}
+
+	relaylen = sizeof(*dh6relay);
+	if ((optlen = dhcp6_set_options(DH6_RELAY_FORW,
+	    (struct dhcp6opt *)(dh6relay + 1),
+	    (struct dhcp6opt *)(G.relaybuf + sizeof(G.relaybuf)),
+	    &optinfo)) < 0) {
+		bb_error_msg("failed to construct relay options");
+		goto out;
+	}
+	relaylen += optlen;
+
+	/*
+	 * Forward the message.
+	 */
+	memset(&mh, 0, sizeof(mh));
+	iov[0].iov_base = G.relaybuf;
+	iov[0].iov_len = relaylen;
+	mh.msg_iov = iov;
+	mh.msg_iovlen = 1;
+	mh.msg_name = &sa6_server;
+	mh.msg_namelen = sizeof(sa6_server);
+	if (IN6_IS_ADDR_MULTICAST(&sa6_server.sin6_addr)) {
+		memset(&pktinfo, 0, sizeof(pktinfo));
+		pktinfo.ipi6_ifindex = relayifid;
+		if (make_msgcontrol(&mh, ctlbuf, sizeof(ctlbuf),
+		    &pktinfo, mhops)) {
+			bb_error_msg("failed to make message control data");
+			goto out;
+		}
+	}
+
+	if ((cc = sendmsg(ssock, &mh, 0)) < 0) {
+		bb_error_msg("sendmsg %s failed: %s",
+		    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&sa6_server), strerror(errno));
+	} else if (cc != relaylen) {
+		bb_error_msg("failed to send a complete packet to %s",
+		    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&sa6_server));
+	} else {
+		log1("relay a message to a server %s",
+		    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&sa6_server));
+	}
+
+  out:
+	dhcp6_clear_options(&optinfo);
+}
+
+static void
+relay_to_client(struct dhcp6_relay *dh6relay, ssize_t len, struct sockaddr *from)
+{
+	struct dhcp6_optinfo optinfo;
+	struct sockaddr_in6 peer;
+	unsigned int ifid;
+	char ifnamebuf[IFNAMSIZ];
+	char *a = NULL;
+	int cc;
+	int relayed = 0;
+	struct dhcp6 *dh6;
+	struct msghdr mh;
+	struct in6_pktinfo pktinfo;
+	struct iovec iov[2];
+	char ctlbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+
+	log1("dhcp6 relay reply: hop=%d, linkaddr=%s, peeraddr=%s",
+	    dh6relay->dh6relay_hcnt,
+	    in6addr2str(&dh6relay->dh6relay_linkaddr, 0),
+	    in6addr2str(&dh6relay->dh6relay_peeraddr, 0));
+
+	/*
+	 * parse and validate options in the relay reply message.
+	 */
+	dhcp6_init_options(&optinfo);
+	if (dhcp6_get_options((struct dhcp6opt *)(dh6relay + 1),
+	    (struct dhcp6opt *)((char *)dh6relay + len), &optinfo) < 0) {
+		bb_info_msg("failed to parse options");
+		return;
+	}
+
+	/* A relay reply message must include a relay message option */
+	if (optinfo.relaymsg_msg == NULL) {
+		a = xmalloc_sockaddr2dotted_noport(from);
+		bb_info_msg("relay reply message from %s "
+		    "without a relay message", a);
+		goto out;
+	}
+
+	/* minimum validation for the inner message */
+	if (optinfo.relaymsg_len < sizeof(struct dhcp6)) {
+		a = xmalloc_sockaddr2dotted_noport(from);
+		bb_info_msg("short relay message from %s",
+		    a);
+		goto out;
+	}
+
+	/*
+	 * Extract interface ID which should be included in relay reply
+	 * messages to us.
+	 */
+	a = xmalloc_sockaddr2dotted_noport(from);
+	ifid = 0;
+	if (optinfo.ifidopt_id) {
+		if (optinfo.ifidopt_len != sizeof(ifid)) {
+			bb_info_msg(
+			    "unexpected length (%d) for Interface ID from %s",
+			    optinfo.ifidopt_len, a);
+			goto out;
+		} else {
+			memcpy(&ifid, optinfo.ifidopt_id, sizeof(ifid));
+			ifid = ntohl(ifid);
+
+			/* validation for ID */
+			if ((if_indextoname(ifid, ifnamebuf)) == NULL) {
+				bb_info_msg("invalid interface ID: %x", ifid);
+				goto out;
+			}
+		}
+	} else {
+		bb_info_msg("Interface ID is not included from %s", a);
+		/*
+		 * the responding server should be buggy, but we deal with it.
+		 */
+	}
+	free(a);
+
+	/*
+	 * If we fail, try to get the interface from the link address.
+	 */
+	if (ifid == 0 &&
+	    !IN6_IS_ADDR_UNSPECIFIED(&dh6relay->dh6relay_linkaddr) &&
+	    !IN6_IS_ADDR_LINKLOCAL(&dh6relay->dh6relay_linkaddr)) {
+		if (getifidfromaddr(&dh6relay->dh6relay_linkaddr, &ifid))
+			ifid = 0;
+	}
+
+	if (ifid == 0) {
+		bb_error_msg("failed to determine relay link");
+		goto out;
+	}
+
+	peer = sa6_client;
+	dh6 = (struct dhcp6 *) optinfo.relaymsg_msg;
+	if (dh6->dh6_msgtype != DH6_RELAY_REPLY) {
+		relayed++;
+	} else {
+		/* 
+		 * change dst port to server/relay port, since it's a
+		 * reply to relay, not to a client
+		 */
+		peer.sin6_port = htons(547);	/* DH6PORT_UPSTREAM */
+	}
+	memcpy(&peer.sin6_addr, &dh6relay->dh6relay_peeraddr,
+	    sizeof(peer.sin6_addr));
+	if (IN6_IS_ADDR_LINKLOCAL(&peer.sin6_addr))
+		peer.sin6_scope_id = ifid; /* XXX: we assume a 1to1 map */
+
+	/* construct a message structure specifying the outgoing interface */
+	memset(&mh, 0, sizeof(mh));
+	iov[0].iov_base = optinfo.relaymsg_msg;
+	iov[0].iov_len = optinfo.relaymsg_len;
+	mh.msg_iov = iov;
+	mh.msg_iovlen = 1;
+	mh.msg_name = &peer;
+	mh.msg_namelen = sizeof(peer);
+	memset(&pktinfo, 0, sizeof(pktinfo));
+	pktinfo.ipi6_ifindex = ifid;
+	if (make_msgcontrol(&mh, ctlbuf, sizeof(ctlbuf), &pktinfo, 0)) {
+		bb_error_msg("failed to make message control data");
+		goto out;
+	}
+
+	a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&peer);
+	/* send packet */
+	if ((cc = sendmsg(csock, &mh, 0)) < 0) {
+		bb_error_msg("sendmsg to %s failed: %s", a, strerror(errno));
+	} else if (cc != optinfo.relaymsg_len) {
+		bb_info_msg("failed to send a complete packet to %s", a);
+	} else {
+		log1("relay a message to a client %s", a);
+	}
+
+	if (relayed && G.scriptpath != NULL) {
+		struct dhcp6_optinfo optinfo1;
+		struct dhcp6opt *optend;
+
+		/* only replies are interesting */
+		if (dh6->dh6_msgtype != DH6_REPLY &&
+		    dh6->dh6_msgtype != DH6_ADVERTISE) {
+			bb_info_msg("forward msg#%d to client?", dh6->dh6_msgtype);
+			goto out;
+		}
+
+		/* parse options */
+		dhcp6_init_options(&optinfo1);
+		optend = (struct dhcp6opt *)((caddr_t) dh6 + optinfo.relaymsg_len);
+		if (dhcp6_get_options((struct dhcp6opt *)(dh6 + 1), optend,
+		    &optinfo1) < 0) {
+			bb_info_msg("failed to parse options");
+			goto out;
+		}
+
+		dhcp6_script(G.scriptpath, fill_envp_relay6(&optinfo1, a));
+		dhcp6_clear_options(&optinfo1);
+	}
+
+  out:
+	if (a)
+		free(a);
+	dhcp6_clear_options(&optinfo);
+	return;
+}
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/if6.c busybox/networking/udhcp/if6.c
--- busybox.orig/networking/udhcp/if6.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/if6.c	2011-02-07 20:24:17.000000000 +0300
@@ -0,0 +1,465 @@
+/*	$KAME: if.c,v 1.6 2005/09/16 11:30:15 suz Exp $	*/
+
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+
+#ifdef __linux__
+#include <linux/if_packet.h>
+#endif
+#include <net/if_arp.h>
+#ifdef __sun__
+#include <sys/sockio.h>
+#include <sys/dlpi.h>
+#include <stropts.h>
+#include <fcntl.h>
+#include <libdevinfo.h>
+#endif
+
+#include <syslog.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ifaddrs.h>
+#include <errno.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+
+#ifdef __linux__
+/* from /usr/include/linux/ipv6.h */
+
+struct in6_ifreq {
+	struct in6_addr ifr6_addr;
+	uint32_t ifr6_prefixlen;
+	unsigned int ifr6_ifindex;
+};
+#endif
+
+ssize_t gethwid(char *, int, const char *, uint16_t *);
+
+static struct dhcp6_if *find_ifconf_byname(char *ifname);
+
+struct dhcp6_if *if6init(char *ifname)
+{
+	struct dhcp6_if *ifp;
+
+	if ((ifp = find_ifconf_byname(ifname)) != NULL) {
+		bb_error_msg("duplicated interface: %s", ifname);
+		return (NULL);
+	}
+
+	ifp = xzalloc(sizeof(*ifp));
+	TAILQ_INIT(&ifp->event_list);
+	ifp->ifname = xstrdup(ifname);
+
+	if (ifreset(ifp))
+		goto fail;
+
+	TAILQ_INIT(&ifp->reqopt_list);
+	TAILQ_INIT(&ifp->iaconf_list);
+
+	ifp->authproto = DHCP6_AUTHPROTO_UNDEF;
+	ifp->authalgorithm = DHCP6_AUTHALG_UNDEF;
+	ifp->authrdm = DHCP6_AUTHRDM_UNDEF;
+
+	{
+		struct ifaddrs *ifa, *ifap;
+		struct sockaddr_in6 *sin6;
+
+		if (getifaddrs(&ifap) < 0) {
+			bb_error_msg("getifaddrs failed: %s",
+			    strerror(errno));
+			goto fail;
+		}
+
+		for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+			if (strcmp(ifa->ifa_name, ifname) != 0)
+				continue;
+			if (ifa->ifa_addr == NULL)
+				continue;
+			if (ifa->ifa_addr->sa_family != AF_INET6)
+				continue;
+
+			sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
+			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr))
+				continue;
+
+			ifp->addr = sin6->sin6_addr;
+		}
+
+		freeifaddrs(ifap);
+	}
+
+	ifp->next = client6_config.dhcp6c_if;
+	client6_config.dhcp6c_if = ifp;
+	return (ifp);
+
+  fail:
+	if (ifp->ifname != NULL)
+		free(ifp->ifname);
+	free(ifp);
+	return (NULL);
+}
+
+int ifreset(struct dhcp6_if *ifp)
+{
+	unsigned int ifid;
+	uint32_t linkid;
+
+	if ((ifid = if_nametoindex(ifp->ifname)) == 0) {
+		bb_error_msg("invalid interface(%s): %s",
+			ifp->ifname, strerror(errno));
+		return (-1);
+	}
+
+#ifdef HAVE_SCOPELIB
+	if (inet_zoneid(AF_INET6, 2, ifname, &linkid)) {
+		bb_error_msg("failed to get link ID for %s",
+		    ifname);
+		return (-1);
+	}
+#else
+	linkid = ifid;		/* XXX: assume 1to1 mapping IFs and links */
+#endif
+
+	ifp->ifid = ifid;
+	ifp->linkid = linkid;
+
+	return (0);
+}
+
+static struct dhcp6_if *find_ifconf_byname(char *ifname)
+{
+	struct dhcp6_if *ifp;
+
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		if (strcmp(ifp->ifname, ifname) == 0)
+			return (ifp);
+	}
+
+	return (NULL);
+}
+
+struct dhcp6_if *find_ifconf_byid(unsigned int id)
+{
+	struct dhcp6_if *ifp;
+
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		if (ifp->ifid == id)
+			return (ifp);
+	}
+
+	return (NULL);
+}
+
+#ifdef __sun__
+struct hwparms {
+	char *buf;
+	uint16_t *hwtypep;
+	ssize_t retval;
+};
+
+static ssize_t getifhwaddr(const char *ifname, char *buf, uint16_t *hwtypep,
+			int ppa)
+{
+	int fd, flags;
+	char fname[MAXPATHLEN], *cp;
+	struct strbuf putctl;
+	struct strbuf getctl;
+	long getbuf[1024];
+	dl_info_req_t dlir;
+	dl_phys_addr_req_t dlpar;
+	dl_phys_addr_ack_t *dlpaa;
+
+	log1("trying %s ppa %d", ifname, ppa);
+
+	if (ifname[0] == '\0')
+		return (-1);
+	if (ppa >= 0 && !isdigit(ifname[strlen(ifname) - 1]))
+		(void) snprintf(fname, sizeof(fname), "/dev/%s%d", ifname,
+		    ppa);
+	else
+		(void) snprintf(fname, sizeof(fname), "/dev/%s", ifname);
+	getctl.maxlen = sizeof(getbuf);
+	getctl.buf = (char *)getbuf;
+	if ((fd = open(fname, O_RDWR)) == -1) {
+		dl_attach_req_t dlar;
+
+		cp = fname + strlen(fname) - 1;
+		if (!isdigit(*cp))
+			return (-1);
+		while (cp > fname) {
+			if (!isdigit(*cp))
+				break;
+			cp--;
+		}
+		if (cp == fname)
+			return (-1);
+		cp++;
+		dlar.dl_ppa = atoi(cp);
+		*cp = '\0';
+		if ((fd = open(fname, O_RDWR)) == -1)
+			return (-1);
+		dlar.dl_primitive = DL_ATTACH_REQ;
+		putctl.len = sizeof(dlar);
+		putctl.buf = (char *)&dlar;
+		if (putmsg(fd, &putctl, NULL, 0) == -1) {
+			(void) close(fd);
+			return (-1);
+		}
+		flags = 0;
+		if (getmsg(fd, &getctl, NULL, &flags) == -1) {
+			(void) close(fd);
+			return (-1);
+		}
+		if (getbuf[0] != DL_OK_ACK) {
+			(void) close(fd);
+			return (-1);
+		}
+	}
+	dlir.dl_primitive = DL_INFO_REQ;
+	putctl.len = sizeof(dlir);
+	putctl.buf = (char *)&dlir;
+	if (putmsg(fd, &putctl, NULL, 0) == -1) {
+		(void) close(fd);
+		return (-1);
+	}
+	flags = 0;
+	if (getmsg(fd, &getctl, NULL, &flags) == -1) {
+		(void) close(fd);
+		return (-1);
+	}
+	if (getbuf[0] != DL_INFO_ACK) {
+		(void) close(fd);
+		return (-1);
+	}
+	switch (((dl_info_ack_t *)getbuf)->dl_mac_type) {
+	case DL_CSMACD:
+	case DL_ETHER:
+	case DL_100VG:
+	case DL_ETH_CSMA:
+	case DL_100BT:
+		*hwtypep = ARPHRD_ETHER;
+		break;
+	default:
+		(void) close(fd);
+		return (-1);
+	}
+	dlpar.dl_primitive = DL_PHYS_ADDR_REQ;
+	dlpar.dl_addr_type = DL_CURR_PHYS_ADDR;
+	putctl.len = sizeof(dlpar);
+	putctl.buf = (char *)&dlpar;
+	if (putmsg(fd, &putctl, NULL, 0) == -1) {
+		(void) close(fd);
+		return (-1);
+	}
+	flags = 0;
+	if (getmsg(fd, &getctl, NULL, &flags) == -1) {
+		(void) close(fd);
+		return (-1);
+	}
+	if (getbuf[0] != DL_PHYS_ADDR_ACK) {
+		(void) close(fd);
+		return (-1);
+	}
+	dlpaa = (dl_phys_addr_ack_t *)getbuf;
+	if (dlpaa->dl_addr_length != 6) {
+		(void) close(fd);
+		return (-1);
+	}
+	(void) memcpy(buf, (char *)getbuf + dlpaa->dl_addr_offset,
+	    dlpaa->dl_addr_length);
+	return (dlpaa->dl_addr_length);
+}
+
+static int devfs_handler(di_node_t node, di_minor_t minor, void *arg)
+{
+	struct hwparms *parms = arg;
+
+	parms->retval = getifhwaddr(di_minor_name(minor), parms->buf,
+	    parms->hwtypep, di_instance(node));
+	return (parms->retval == -1 ? DI_WALK_CONTINUE : DI_WALK_TERMINATE);
+}
+#endif /* __sun__ */
+
+ssize_t gethwid(char *buf, int len, const char *ifname, uint16_t *hwtypep)
+{
+	struct ifaddrs *ifa, *ifap;
+#ifdef __linux__
+	struct sockaddr_ll *sll;
+#endif
+	ssize_t l = 0;
+
+#ifdef __sun__
+	if (ifname == NULL) {
+		di_node_t root;
+		struct hwparms parms;
+
+		if ((root = di_init("/", DINFOSUBTREE | DINFOMINOR |
+		    DINFOPROP)) == DI_NODE_NIL) {
+			bb_info_msg("di_init failed");
+			return (-1);
+		}
+		parms.buf = buf;
+		parms.hwtypep = hwtypep;
+		parms.retval = -1;
+		(void) di_walk_minor(root, DDI_NT_NET, DI_CHECK_ALIAS, &parms,
+		    devfs_handler);
+		di_fini(root);
+		return (parms.retval);
+	} else {
+		return (getifhwaddr(ifname, buf, hwtypep, -1));
+	}
+#endif /* __sun__ */
+
+	if (getifaddrs(&ifap) < 0)
+		return (-1);
+
+	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+		if (ifname && strcmp(ifa->ifa_name, ifname) != 0)
+			continue;
+		if (ifa->ifa_addr == NULL)
+			continue;
+#ifdef __linux__
+		if (ifa->ifa_addr->sa_family != AF_PACKET)
+			continue;
+
+		sll = (struct sockaddr_ll *)ifa->ifa_addr;
+		if (sll->sll_hatype != ARPHRD_ETHER)
+			continue;
+		*hwtypep = ARPHRD_ETHER;
+		log1("found an interface %s for DUID", ifa->ifa_name);
+		if (sll->sll_halen > len)
+			return (-2);
+		memcpy(buf, sll->sll_addr, sll->sll_halen);
+		l = sll->sll_halen; /* sll will soon be freed */
+		break;
+#endif
+	}
+
+	freeifaddrs(ifap);
+	return (l);
+}
+
+int ifaddrconf(ifaddrconf_cmd_t cmd, char *ifname, struct sockaddr_in6 *addr,
+	   int plen,
+	   int pltime __attribute__((unused)),
+	   int vltime __attribute__((unused))
+	  )
+{
+/*
+ * TODO: Should be rewritten to Netlink calls in order to support
+ *       preferred/valid lifetimes
+ */
+#if   defined(__linux__)
+	struct in6_ifreq req;
+	struct ifreq ifr;
+#elif defined(__sun__)
+	struct lifreq req;
+#endif
+	unsigned long ioctl_cmd;
+	const char *cmdstr;
+	int s;			/* XXX overhead */
+
+	switch (cmd) {
+	case IFADDRCONF_ADD:
+		cmdstr = "add";
+#if   defined(__linux__)
+		ioctl_cmd = SIOCSIFADDR;
+#elif defined(__sun__)
+		ioctl_cmd = SIOCLIFADDIF;
+#endif
+		break;
+	case IFADDRCONF_REMOVE:
+		cmdstr = "remove";
+#if   defined(__linux__)
+		ioctl_cmd = SIOCDIFADDR;
+#elif defined(__sun__)
+		ioctl_cmd = SIOCLIFREMOVEIF;
+#endif
+		break;
+	default:
+		return (-1);
+	}
+
+	if ((s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+		bb_error_msg("can't open a temporary socket: %s",
+		    strerror(errno));
+		return (-1);
+	}
+
+	memset(&req, 0, sizeof(req));
+#if   defined(__linux__)
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
+	if (ioctl(s, SIOGIFINDEX, &ifr) < 0) {
+		bb_error_msg("failed to get the index of %s: %s",
+		    ifname, strerror(errno));
+		close(s); 
+		return (-1); 
+	}
+	memcpy(&req.ifr6_addr, &addr->sin6_addr, sizeof(struct in6_addr));
+	req.ifr6_prefixlen = plen;
+	req.ifr6_ifindex = ifr.ifr_ifindex;
+
+	if (ioctl(s, ioctl_cmd, &req)) {
+		bb_error_msg("failed to %s an address on %s: %s",
+		    cmdstr, ifname, strerror(errno));
+		close(s);
+		if (errno == EEXIST) /* Ignore address duplicate */
+			return (0);
+		return (-1);
+	}
+
+#elif defined(__sun__)
+	strncpy(req.lifr_name, ifname, sizeof(req.lifr_name));
+	memcpy(&req.lifr_addr, addr, sizeof(*addr));
+	if (ioctl(s, SIOCSLIFADDR, &req) == -1) {
+		bb_info_msg("failed to %s new address on %s: %s",
+		    cmdstr, ifname, strerror(errno));
+		close(s);
+		return (-1);
+	}
+#endif
+
+	bb_info_msg("%s an address %s/%d on %s", cmdstr,
+	    xmalloc_sockaddr2dotted_noport((struct sockaddr *)addr), plen, ifname);
+
+	close(s);
+	return (0);
+}
+
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/Kbuild.src busybox/networking/udhcp/Kbuild.src
--- busybox.orig/networking/udhcp/Kbuild.src	2011-01-16 21:19:55.000000000 +0300
+++ busybox/networking/udhcp/Kbuild.src	2011-02-07 10:51:07.000000000 +0300
@@ -17,5 +17,12 @@ lib-$(CONFIG_UDHCPD)     += dhcpd.o arpp
 lib-$(CONFIG_DUMPLEASES) += dumpleases.o
 lib-$(CONFIG_DHCPRELAY)  += dhcprelay.o
 
+lib-$(CONFIG_DHCP6C)     += common6.o common.o
+
+lib-$(CONFIG_DHCP6C)     += dhcp6c.o config6.o dhcp6c_script.o dhcp6c_ia.o if6.o timer.o
+lib-$(CONFIG_DHCP6RELAY) += dhcp6relay.o
+
+lib-$(CONFIG_FEATURE_DHCP6_AUTH)    += auth6.o base64.o
+
 lib-$(CONFIG_FEATURE_UDHCPC_ARPING) += arpping.o
 lib-$(CONFIG_FEATURE_UDHCP_RFC3397) += domain_codec.o
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/timer.c busybox/networking/udhcp/timer.c
--- busybox.orig/networking/udhcp/timer.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/timer.c	2011-02-07 22:32:32.000000000 +0300
@@ -0,0 +1,146 @@
+/*	$KAME: timer.c,v 1.6 2003/07/31 23:25:59 jinmei Exp $	*/
+
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+
+#include <netinet/in.h>
+
+#include <unistd.h>
+#include <syslog.h>
+#include <stdlib.h>
+#include <string.h>
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include <search.h>
+#endif
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "timer.h"
+
+#define MILLION 1000000
+
+static const unsigned long long t_max = 0xffffffffffffffffULL;
+
+
+void dhcp6_timer_init(void)
+{
+	LIST_INIT(&client6_config.timer_head);
+	client6_config.tm_sentinel = t_max;
+}
+
+struct dhcp6_timer *dhcp6_timer_add(struct dhcp6_timer *(*timeout)(void *),
+				    void *timeodata)
+{
+	struct dhcp6_timer *newtimer;
+
+	if (timeout == NULL) {
+		log1("timeout function unspecified");
+		return (NULL);
+	}
+
+	newtimer = xzalloc(sizeof(*newtimer));
+	newtimer->expire = timeout;
+	newtimer->expire_data = timeodata;
+	newtimer->t = t_max;
+
+	LIST_INSERT_HEAD(&client6_config.timer_head, newtimer, link);
+
+	return (newtimer);
+}
+
+void dhcp6_timer_remove(struct dhcp6_timer **timer)
+{
+	LIST_REMOVE(*timer, link);
+	free(*timer);
+	*timer = NULL;
+}
+
+void dhcp6_timer_set(unsigned long long t, struct dhcp6_timer *timer)
+{
+	timer->t = monotonic_ms() + t;
+
+	/* update the next expiration time */
+	if (timer->t < client6_config.tm_sentinel)
+		client6_config.tm_sentinel = timer->t;
+}
+
+/*
+ * Check expiration for each timer. If a timer is expired,
+ * call the expire function for the timer and update the timer.
+ * Return the next interval for select() call.
+ */
+struct timeval *dhcp6_timer_check(void)
+{
+	unsigned long long now = monotonic_ms();
+	struct dhcp6_timer *tm, *tm_next;
+
+	client6_config.tm_sentinel = t_max;
+	for (tm = LIST_FIRST(&client6_config.timer_head); tm; tm = tm_next) {
+		tm_next = LIST_NEXT(tm, link);
+
+		if (tm->t <= now) {
+			if ((*tm->expire)(tm->expire_data) == NULL)
+				continue; /* timer has been freed */
+		}
+
+		if (tm->t < client6_config.tm_sentinel)
+			client6_config.tm_sentinel = tm->t;
+	}
+
+	if (t_max == client6_config.tm_sentinel) {
+		/* no need to timeout */
+		return (NULL);
+	} else if (client6_config.tm_sentinel < now) {
+		/* this may occur when the interval is too small */
+		client6_config.tm_check.tv_sec = client6_config.tm_check.tv_usec = 0;
+	} else {
+		client6_config.tm_check.tv_sec =
+			(client6_config.tm_sentinel - now) / 1000ULL;
+		client6_config.tm_check.tv_usec =
+			((client6_config.tm_sentinel - now) % 1000ULL) * 1000ULL;
+	}
+	return (&client6_config.tm_check);
+}
+
+unsigned long long dhcp6_timer_rest(struct dhcp6_timer *timer)
+{
+	unsigned long long now = monotonic_ms();
+
+	if (timer->t <= now) {
+		log2("a timer must be expired, but not yet");
+		return 0ULL;
+	} else
+		return (timer->t - now);
+}
diff -x'.*' -x'*.o' -urNBp busybox.orig/networking/udhcp/timer.h busybox/networking/udhcp/timer.h
--- busybox.orig/networking/udhcp/timer.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/timer.h	2011-02-07 19:48:27.000000000 +0300
@@ -0,0 +1,50 @@
+/*	$KAME: timer.h,v 1.1 2002/05/16 06:04:08 jinmei Exp $	*/
+
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#ifndef __DHCP6_TIMER_H
+#define __DHCP6_TIMER_H 1
+
+struct dhcp6_timer {
+	LIST_ENTRY(dhcp6_timer) link;
+
+	unsigned long long t;
+
+	struct dhcp6_timer *(*expire)(void *);
+	void *expire_data;
+};
+
+void dhcp6_timer_init(void);
+struct dhcp6_timer *dhcp6_timer_add(struct dhcp6_timer *(*)(void *), void *);
+void dhcp6_timer_set(unsigned long long , struct dhcp6_timer *);
+void dhcp6_timer_remove(struct dhcp6_timer **);
+struct timeval *dhcp6_timer_check(void);
+unsigned long long dhcp6_timer_rest(struct dhcp6_timer *);
+
+#endif /* timer.h */
