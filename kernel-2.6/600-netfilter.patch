diff -urBwNp linux-2.6.22/include/linux/netfilter/nf_conntrack_autofw.h linux-2.6/include/linux/netfilter/nf_conntrack_autofw.h
--- linux-2.6.22/include/linux/netfilter/nf_conntrack_autofw.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter/nf_conntrack_autofw.h	2008-12-12 06:34:25.000000000 +0300
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: nf_conntrack_autofw.h,v 1.1 2008/10/02 03:41:50 Exp $
+ */
+
+#ifndef _NF_CONNTRACK_AUTOFW_H
+#define _NF_CONNTRACK_AUTOFW_H
+
+#ifdef __KERNEL__
+
+struct nf_ct_autofw_master {
+	u_int16_t dport[2];     /* Related destination port range */
+	u_int16_t to[2];        /* Port range to map related destination port range to */
+};
+
+
+#endif /* __KERNEL__ */
+
+#endif /* _NF_CONNTRACK_AUTOFW_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter/xt_time.h linux-2.6/include/linux/netfilter/xt_time.h
--- linux-2.6.22/include/linux/netfilter/xt_time.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter/xt_time.h	2009-04-09 10:54:15.000000000 +0400
@@ -0,0 +1,17 @@
+#ifndef _XT_TIME_H
+#define _XT_TIME_H 1
+
+struct xt_time_info {
+	u_int8_t  days_match;   /* 1 bit per day. -SMTWTFS                      */
+	u_int16_t time_start;   /* 0 < time_start < 23*60+59 = 1439             */
+	u_int16_t time_stop;    /* 0:0 < time_stat < 23:59                      */
+
+				/* FIXME: Keep this one for userspace iptables binary compability: */
+	u_int8_t kerneltime;   /* ignore skb time (and use kerneltime) or not. */
+
+	time_t date_start;
+	time_t date_stop;
+};
+
+
+#endif /* _XT_TIME_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_autofw.h linux-2.6/include/linux/netfilter_ipv4/ip_autofw.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_autofw.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_autofw.h	2008-12-12 06:34:26.000000000 +0300
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: ip_autofw.h,v 1.1 2008/10/02 03:42:40 Exp $
+ */
+
+#ifndef _IP_AUTOFW_H
+#define _IP_AUTOFW_H
+
+#define AUTOFW_MASTER_TIMEOUT 600	/* 600 secs */
+
+struct ip_autofw_info {
+	u_int16_t proto;	/* Related protocol */
+	u_int16_t dport[2];	/* Related destination port range */
+	u_int16_t to[2];	/* Port range to map related destination port range to */
+};
+
+struct ip_autofw_expect {
+	u_int16_t dport[2];	/* Related destination port range */
+	u_int16_t to[2];	/* Port range to map related destination port range to */
+};
+
+#endif /* _IP_AUTOFW_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_amanda.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_amanda.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_amanda.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_amanda.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,11 @@
+#ifndef _IP_CONNTRACK_AMANDA_H
+#define _IP_CONNTRACK_AMANDA_H
+/* AMANDA tracking. */
+
+struct ip_conntrack_expect;
+extern unsigned int (*ip_nat_amanda_hook)(struct sk_buff **pskb,
+					  enum ip_conntrack_info ctinfo,
+					  unsigned int matchoff,
+					  unsigned int matchlen,
+					  struct ip_conntrack_expect *exp);
+#endif /* _IP_CONNTRACK_AMANDA_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_core.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_core.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_core.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_core.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,61 @@
+#ifndef _IP_CONNTRACK_CORE_H
+#define _IP_CONNTRACK_CORE_H
+#include <linux/netfilter.h>
+
+#define MAX_IP_CT_PROTO 256
+extern struct ip_conntrack_protocol *ip_ct_protos[MAX_IP_CT_PROTO];
+
+/* This header is used to share core functionality between the
+   standalone connection tracking module, and the compatibility layer's use
+   of connection tracking. */
+extern unsigned int ip_conntrack_in(unsigned int hooknum,
+				    struct sk_buff **pskb,
+				    const struct net_device *in,
+				    const struct net_device *out,
+				    int (*okfn)(struct sk_buff *));
+
+extern int ip_conntrack_init(void);
+extern void ip_conntrack_cleanup(void);
+
+struct ip_conntrack_protocol;
+
+extern int
+ip_ct_get_tuple(const struct iphdr *iph,
+		const struct sk_buff *skb,
+		unsigned int dataoff,
+		struct ip_conntrack_tuple *tuple,
+		const struct ip_conntrack_protocol *protocol);
+
+extern int
+ip_ct_invert_tuple(struct ip_conntrack_tuple *inverse,
+		   const struct ip_conntrack_tuple *orig,
+		   const struct ip_conntrack_protocol *protocol);
+
+/* Find a connection corresponding to a tuple. */
+struct ip_conntrack_tuple_hash *
+ip_conntrack_find_get(const struct ip_conntrack_tuple *tuple,
+		      const struct ip_conntrack *ignored_conntrack);
+
+extern int __ip_conntrack_confirm(struct sk_buff **pskb);
+
+/* Confirm a connection: returns NF_DROP if packet must be dropped. */
+static inline int ip_conntrack_confirm(struct sk_buff **pskb)
+{
+	struct ip_conntrack *ct = (struct ip_conntrack *)(*pskb)->nfct;
+	int ret = NF_ACCEPT;
+
+	if (ct) {
+		if (!is_confirmed(ct) && !is_dying(ct))
+			ret = __ip_conntrack_confirm(pskb);
+		ip_ct_deliver_cached_events(ct);
+	}
+	return ret;
+}
+
+extern void ip_ct_unlink_expect(struct ip_conntrack_expect *exp);
+
+extern struct list_head *ip_conntrack_hash;
+extern struct list_head ip_conntrack_expect_list;
+extern rwlock_t ip_conntrack_lock;
+#endif /* _IP_CONNTRACK_CORE_H */
+
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_ftp.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_ftp.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_ftp.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_ftp.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,44 @@
+#ifndef _IP_CONNTRACK_FTP_H
+#define _IP_CONNTRACK_FTP_H
+/* FTP tracking. */
+
+/* This enum is exposed to userspace */
+enum ip_ct_ftp_type
+{
+	/* PORT command from client */
+	IP_CT_FTP_PORT,
+	/* PASV response from server */
+	IP_CT_FTP_PASV,
+	/* EPRT command from client */
+	IP_CT_FTP_EPRT,
+	/* EPSV response from server */
+	IP_CT_FTP_EPSV,
+};
+
+#ifdef __KERNEL__
+
+#define FTP_PORT	21
+
+#define NUM_SEQ_TO_REMEMBER 2
+/* This structure exists only once per master */
+struct ip_ct_ftp_master {
+	/* Valid seq positions for cmd matching after newline */
+	u_int32_t seq_aft_nl[IP_CT_DIR_MAX][NUM_SEQ_TO_REMEMBER];
+	/* 0 means seq_match_aft_nl not set */
+	int seq_aft_nl_num[IP_CT_DIR_MAX];
+};
+
+struct ip_conntrack_expect;
+
+/* For NAT to hook in when we find a packet which describes what other
+ * connection we should expect. */
+extern unsigned int (*ip_nat_ftp_hook)(struct sk_buff **pskb,
+				       enum ip_conntrack_info ctinfo,
+				       enum ip_ct_ftp_type type,
+				       unsigned int matchoff,
+				       unsigned int matchlen,
+				       struct ip_conntrack_expect *exp,
+				       u32 *seq);
+#endif /* __KERNEL__ */
+
+#endif /* _IP_CONNTRACK_FTP_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,402 @@
+#ifndef _IP_CONNTRACK_H
+#define _IP_CONNTRACK_H
+
+#include <linux/netfilter/nf_conntrack_common.h>
+
+#ifdef __KERNEL__
+#include <linux/netfilter_ipv4/ip_conntrack_tuple.h>
+#include <linux/bitops.h>
+#include <linux/compiler.h>
+#include <asm/atomic.h>
+
+#include <linux/timer.h>
+#include <linux/netfilter_ipv4/ip_conntrack_tcp.h>
+#include <linux/netfilter_ipv4/ip_conntrack_icmp.h>
+#include <linux/netfilter_ipv4/ip_conntrack_proto_gre.h>
+#include <linux/netfilter_ipv4/ip_conntrack_sctp.h>
+
+/* per conntrack: protocol private data */
+union ip_conntrack_proto {
+	/* insert conntrack proto private data here */
+	struct ip_ct_gre gre;
+	struct ip_ct_sctp sctp;
+	struct ip_ct_tcp tcp;
+	struct ip_ct_icmp icmp;
+};
+
+union ip_conntrack_expect_proto {
+	/* insert expect proto private data here */
+};
+
+/* Add protocol helper include file here */
+#include <linux/netfilter_ipv4/ip_conntrack_h323.h>
+#include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
+#include <linux/netfilter_ipv4/ip_conntrack_amanda.h>
+#include <linux/netfilter_ipv4/ip_conntrack_ftp.h>
+#include <linux/netfilter_ipv4/ip_conntrack_irc.h>
+
+/* per conntrack: application helper private data */
+union ip_conntrack_help {
+	/* insert conntrack helper private data (master) here */
+	struct ip_ct_h323_master ct_h323_info;
+	struct ip_ct_pptp_master ct_pptp_info;
+	struct ip_ct_ftp_master ct_ftp_info;
+	struct ip_ct_irc_master ct_irc_info;
+};
+
+#ifdef CONFIG_IP_NF_NAT_NEEDED
+#include <linux/netfilter_ipv4/ip_nat.h>
+#include <linux/netfilter_ipv4/ip_nat_pptp.h>
+
+/* per conntrack: nat application helper private data */
+union ip_conntrack_nat_help {
+	/* insert nat helper private data here */
+	struct ip_nat_pptp nat_pptp_info;
+};
+#endif
+
+#include <linux/types.h>
+#include <linux/skbuff.h>
+
+#ifdef CONFIG_NETFILTER_DEBUG
+#define IP_NF_ASSERT(x)							\
+do {									\
+	if (!(x))							\
+		/* Wooah!  I'm tripping my conntrack in a frenzy of	\
+		   netplay... */					\
+		printk("NF_IP_ASSERT: %s:%i(%s)\n",			\
+		       __FILE__, __LINE__, __FUNCTION__);		\
+} while(0)
+#else
+#define IP_NF_ASSERT(x)
+#endif
+
+struct ip_conntrack_helper;
+
+struct ip_conntrack
+{
+	/* Usage count in here is 1 for hash table/destruct timer, 1 per skb,
+           plus 1 for any connection(s) we are `master' for */
+	struct nf_conntrack ct_general;
+
+	/* Have we seen traffic both ways yet? (bitset) */
+	unsigned long status;
+
+	/* Timer function; drops refcnt when it goes off. */
+	struct timer_list timeout;
+
+#ifdef CONFIG_IP_NF_CT_ACCT
+	/* Accounting Information (same cache line as other written members) */
+	struct ip_conntrack_counter counters[IP_CT_DIR_MAX];
+#endif
+	/* If we were expected by an expectation, this will be it */
+	struct ip_conntrack *master;
+
+	/* Current number of expected connections */
+	unsigned int expecting;
+
+	/* Unique ID that identifies this conntrack*/
+	unsigned int id;
+
+	/* Helper, if any. */
+	struct ip_conntrack_helper *helper;
+
+	/* Storage reserved for other modules: */
+	union ip_conntrack_proto proto;
+
+	union ip_conntrack_help help;
+
+#ifdef CONFIG_IP_NF_NAT_NEEDED
+	struct {
+		struct ip_nat_info info;
+		union ip_conntrack_nat_help help;
+#if defined(CONFIG_IP_NF_TARGET_MASQUERADE) || \
+	defined(CONFIG_IP_NF_TARGET_MASQUERADE_MODULE)
+		int masq_index;
+#endif
+	} nat;
+#endif /* CONFIG_IP_NF_NAT_NEEDED */
+
+#if defined(CONFIG_IP_NF_CONNTRACK_MARK)
+	u_int32_t mark;
+#endif
+
+#ifdef CONFIG_IP_NF_CONNTRACK_SECMARK
+	u_int32_t secmark;
+#endif
+
+	/* Traversed often, so hopefully in different cacheline to top */
+	/* These are my tuples; original and reply */
+	struct ip_conntrack_tuple_hash tuplehash[IP_CT_DIR_MAX];
+};
+
+struct ip_conntrack_expect
+{
+	/* Internal linked list (global expectation list) */
+	struct list_head list;
+
+	/* We expect this tuple, with the following mask */
+	struct ip_conntrack_tuple tuple, mask;
+ 
+	/* Function to call after setup and insertion */
+	void (*expectfn)(struct ip_conntrack *new,
+			 struct ip_conntrack_expect *this);
+
+	/* The conntrack of the master connection */
+	struct ip_conntrack *master;
+
+	/* Timer function; deletes the expectation. */
+	struct timer_list timeout;
+
+	/* Usage count. */
+	atomic_t use;
+
+	/* Unique ID */
+	unsigned int id;
+
+	/* Flags */
+	unsigned int flags;
+
+#ifdef CONFIG_IP_NF_NAT_NEEDED
+	__be32 saved_ip;
+	/* This is the original per-proto part, used to map the
+	 * expected connection the way the recipient expects. */
+	union ip_conntrack_manip_proto saved_proto;
+	/* Direction relative to the master connection. */
+	enum ip_conntrack_dir dir;
+#endif
+};
+
+#define IP_CT_EXPECT_PERMANENT	0x1
+
+static inline struct ip_conntrack *
+tuplehash_to_ctrack(const struct ip_conntrack_tuple_hash *hash)
+{
+	return container_of(hash, struct ip_conntrack,
+			    tuplehash[hash->tuple.dst.dir]);
+}
+
+/* get master conntrack via master expectation */
+#define master_ct(conntr) (conntr->master)
+
+/* Alter reply tuple (maybe alter helper). */
+extern void
+ip_conntrack_alter_reply(struct ip_conntrack *conntrack,
+			 const struct ip_conntrack_tuple *newreply);
+
+/* Is this tuple taken? (ignoring any belonging to the given
+   conntrack). */
+extern int
+ip_conntrack_tuple_taken(const struct ip_conntrack_tuple *tuple,
+			 const struct ip_conntrack *ignored_conntrack);
+
+/* Return conntrack_info and tuple hash for given skb. */
+static inline struct ip_conntrack *
+ip_conntrack_get(const struct sk_buff *skb, enum ip_conntrack_info *ctinfo)
+{
+	*ctinfo = skb->nfctinfo;
+	return (struct ip_conntrack *)skb->nfct;
+}
+
+/* decrement reference count on a conntrack */
+static inline void
+ip_conntrack_put(struct ip_conntrack *ct)
+{
+	IP_NF_ASSERT(ct);
+	nf_conntrack_put(&ct->ct_general);
+}
+
+extern int invert_tuplepr(struct ip_conntrack_tuple *inverse,
+			  const struct ip_conntrack_tuple *orig);
+
+extern void __ip_ct_refresh_acct(struct ip_conntrack *ct,
+			         enum ip_conntrack_info ctinfo,
+			         const struct sk_buff *skb,
+			         unsigned long extra_jiffies,
+				 int do_acct);
+
+/* Refresh conntrack for this many jiffies and do accounting */
+static inline void ip_ct_refresh_acct(struct ip_conntrack *ct, 
+				      enum ip_conntrack_info ctinfo,
+				      const struct sk_buff *skb,
+				      unsigned long extra_jiffies)
+{
+	__ip_ct_refresh_acct(ct, ctinfo, skb, extra_jiffies, 1);
+}
+
+/* Refresh conntrack for this many jiffies */
+static inline void ip_ct_refresh(struct ip_conntrack *ct,
+				 const struct sk_buff *skb,
+				 unsigned long extra_jiffies)
+{
+	__ip_ct_refresh_acct(ct, 0, skb, extra_jiffies, 0);
+}
+
+/* These are for NAT.  Icky. */
+/* Update TCP window tracking data when NAT mangles the packet */
+extern void ip_conntrack_tcp_update(struct sk_buff *skb,
+				    struct ip_conntrack *conntrack,
+				    enum ip_conntrack_dir dir);
+
+/* Call me when a conntrack is destroyed. */
+extern void (*ip_conntrack_destroyed)(struct ip_conntrack *conntrack);
+
+/* Fake conntrack entry for untracked connections */
+extern struct ip_conntrack ip_conntrack_untracked;
+
+/* Returns new sk_buff, or NULL */
+struct sk_buff *
+ip_ct_gather_frags(struct sk_buff *skb, u_int32_t user);
+
+/* Iterate over all conntracks: if iter returns true, it's deleted. */
+extern void
+ip_ct_iterate_cleanup(int (*iter)(struct ip_conntrack *i, void *data),
+		      void *data);
+
+extern struct ip_conntrack_helper *
+__ip_conntrack_helper_find_byname(const char *);
+extern struct ip_conntrack_helper *
+ip_conntrack_helper_find_get(const struct ip_conntrack_tuple *tuple);
+extern void ip_conntrack_helper_put(struct ip_conntrack_helper *helper);
+
+extern struct ip_conntrack_protocol *
+__ip_conntrack_proto_find(u_int8_t protocol);
+extern struct ip_conntrack_protocol *
+ip_conntrack_proto_find_get(u_int8_t protocol);
+extern void ip_conntrack_proto_put(struct ip_conntrack_protocol *proto);
+
+extern void ip_ct_remove_expectations(struct ip_conntrack *ct);
+
+extern struct ip_conntrack *ip_conntrack_alloc(struct ip_conntrack_tuple *,
+					       struct ip_conntrack_tuple *);
+
+extern void ip_conntrack_free(struct ip_conntrack *ct);
+
+extern void ip_conntrack_hash_insert(struct ip_conntrack *ct);
+
+extern struct ip_conntrack_expect *
+__ip_conntrack_expect_find(const struct ip_conntrack_tuple *tuple);
+
+extern struct ip_conntrack_expect *
+ip_conntrack_expect_find_get(const struct ip_conntrack_tuple *tuple);
+
+extern struct ip_conntrack_tuple_hash *
+__ip_conntrack_find(const struct ip_conntrack_tuple *tuple,
+                    const struct ip_conntrack *ignored_conntrack);
+
+extern void ip_conntrack_flush(void);
+
+/* It's confirmed if it is, or has been in the hash table. */
+static inline int is_confirmed(struct ip_conntrack *ct)
+{
+	return test_bit(IPS_CONFIRMED_BIT, &ct->status);
+}
+
+static inline int is_dying(struct ip_conntrack *ct)
+{
+	return test_bit(IPS_DYING_BIT, &ct->status);
+}
+
+extern unsigned int ip_conntrack_htable_size;
+extern int ip_conntrack_checksum;
+ 
+#define CONNTRACK_STAT_INC(count) (__get_cpu_var(ip_conntrack_stat).count++)
+#define CONNTRACK_STAT_INC_ATOMIC(count)		\
+do {							\
+	local_bh_disable();				\
+	__get_cpu_var(ip_conntrack_stat).count++;	\
+	local_bh_enable();				\
+} while (0)
+
+#ifdef CONFIG_IP_NF_CONNTRACK_EVENTS
+#include <linux/notifier.h>
+#include <linux/interrupt.h>
+
+struct ip_conntrack_ecache {
+	struct ip_conntrack *ct;
+	unsigned int events;
+};
+DECLARE_PER_CPU(struct ip_conntrack_ecache, ip_conntrack_ecache);
+
+#define CONNTRACK_ECACHE(x)	(__get_cpu_var(ip_conntrack_ecache).x)
+ 
+extern struct atomic_notifier_head ip_conntrack_chain;
+extern struct atomic_notifier_head ip_conntrack_expect_chain;
+
+static inline int ip_conntrack_register_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&ip_conntrack_chain, nb);
+}
+
+static inline int ip_conntrack_unregister_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&ip_conntrack_chain, nb);
+}
+
+static inline int 
+ip_conntrack_expect_register_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&ip_conntrack_expect_chain, nb);
+}
+
+static inline int
+ip_conntrack_expect_unregister_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&ip_conntrack_expect_chain,
+			nb);
+}
+
+extern void ip_ct_deliver_cached_events(const struct ip_conntrack *ct);
+extern void __ip_ct_event_cache_init(struct ip_conntrack *ct);
+
+static inline void 
+ip_conntrack_event_cache(enum ip_conntrack_events event,
+			 const struct sk_buff *skb)
+{
+	struct ip_conntrack *ct = (struct ip_conntrack *)skb->nfct;
+	struct ip_conntrack_ecache *ecache;
+	
+	local_bh_disable();
+	ecache = &__get_cpu_var(ip_conntrack_ecache);
+	if (ct != ecache->ct)
+		__ip_ct_event_cache_init(ct);
+	ecache->events |= event;
+	local_bh_enable();
+}
+
+static inline void ip_conntrack_event(enum ip_conntrack_events event,
+				      struct ip_conntrack *ct)
+{
+	if (is_confirmed(ct) && !is_dying(ct))
+		atomic_notifier_call_chain(&ip_conntrack_chain, event, ct);
+}
+
+static inline void 
+ip_conntrack_expect_event(enum ip_conntrack_expect_events event,
+			  struct ip_conntrack_expect *exp)
+{
+	atomic_notifier_call_chain(&ip_conntrack_expect_chain, event, exp);
+}
+#else /* CONFIG_IP_NF_CONNTRACK_EVENTS */
+static inline void ip_conntrack_event_cache(enum ip_conntrack_events event, 
+					    const struct sk_buff *skb) {}
+static inline void ip_conntrack_event(enum ip_conntrack_events event, 
+				      struct ip_conntrack *ct) {}
+static inline void ip_ct_deliver_cached_events(const struct ip_conntrack *ct) {}
+static inline void 
+ip_conntrack_expect_event(enum ip_conntrack_expect_events event, 
+			  struct ip_conntrack_expect *exp) {}
+#endif /* CONFIG_IP_NF_CONNTRACK_EVENTS */
+
+#ifdef CONFIG_IP_NF_NAT_NEEDED
+static inline int ip_nat_initialized(struct ip_conntrack *conntrack,
+				     enum ip_nat_manip_type manip)
+{
+	if (manip == IP_NAT_MANIP_SRC)
+		return test_bit(IPS_SRC_NAT_DONE_BIT, &conntrack->status);
+	return test_bit(IPS_DST_NAT_DONE_BIT, &conntrack->status);
+}
+#endif /* CONFIG_IP_NF_NAT_NEEDED */
+
+#endif /* __KERNEL__ */
+#endif /* _IP_CONNTRACK_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_h323.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_h323.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_h323.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_h323.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,89 @@
+#ifndef _IP_CONNTRACK_H323_H
+#define _IP_CONNTRACK_H323_H
+
+#ifdef __KERNEL__
+
+#include <linux/netfilter/nf_conntrack_h323_asn1.h>
+
+#define RAS_PORT 1719
+#define Q931_PORT 1720
+#define H323_RTP_CHANNEL_MAX 4	/* Audio, video, FAX and other */
+
+/* This structure exists only once per master */
+struct ip_ct_h323_master {
+
+	/* Original and NATed Q.931 or H.245 signal ports */
+	u_int16_t sig_port[IP_CT_DIR_MAX];
+
+	/* Original and NATed RTP ports */
+	u_int16_t rtp_port[H323_RTP_CHANNEL_MAX][IP_CT_DIR_MAX];
+
+	union {
+		/* RAS connection timeout */
+		u_int32_t timeout;
+
+		/* Next TPKT length (for separate TPKT header and data) */
+		u_int16_t tpkt_len[IP_CT_DIR_MAX];
+	};
+};
+
+struct ip_conntrack_expect;
+
+extern int get_h225_addr(unsigned char *data, TransportAddress * addr,
+			 __be32 * ip, u_int16_t * port);
+extern void ip_conntrack_h245_expect(struct ip_conntrack *new,
+				     struct ip_conntrack_expect *this);
+extern void ip_conntrack_q931_expect(struct ip_conntrack *new,
+				     struct ip_conntrack_expect *this);
+extern int (*set_h245_addr_hook) (struct sk_buff ** pskb,
+				  unsigned char **data, int dataoff,
+				  H245_TransportAddress * addr,
+				  __be32 ip, u_int16_t port);
+extern int (*set_h225_addr_hook) (struct sk_buff ** pskb,
+				  unsigned char **data, int dataoff,
+				  TransportAddress * addr,
+				  __be32 ip, u_int16_t port);
+extern int (*set_sig_addr_hook) (struct sk_buff ** pskb,
+				 struct ip_conntrack * ct,
+				 enum ip_conntrack_info ctinfo,
+				 unsigned char **data,
+				 TransportAddress * addr, int count);
+extern int (*set_ras_addr_hook) (struct sk_buff ** pskb,
+				 struct ip_conntrack * ct,
+				 enum ip_conntrack_info ctinfo,
+				 unsigned char **data,
+				 TransportAddress * addr, int count);
+extern int (*nat_rtp_rtcp_hook) (struct sk_buff ** pskb,
+				 struct ip_conntrack * ct,
+				 enum ip_conntrack_info ctinfo,
+				 unsigned char **data, int dataoff,
+				 H245_TransportAddress * addr,
+				 u_int16_t port, u_int16_t rtp_port,
+				 struct ip_conntrack_expect * rtp_exp,
+				 struct ip_conntrack_expect * rtcp_exp);
+extern int (*nat_t120_hook) (struct sk_buff ** pskb, struct ip_conntrack * ct,
+			     enum ip_conntrack_info ctinfo,
+			     unsigned char **data, int dataoff,
+			     H245_TransportAddress * addr, u_int16_t port,
+			     struct ip_conntrack_expect * exp);
+extern int (*nat_h245_hook) (struct sk_buff ** pskb, struct ip_conntrack * ct,
+			     enum ip_conntrack_info ctinfo,
+			     unsigned char **data, int dataoff,
+			     TransportAddress * addr, u_int16_t port,
+			     struct ip_conntrack_expect * exp);
+extern int (*nat_callforwarding_hook) (struct sk_buff ** pskb,
+				       struct ip_conntrack * ct,
+				       enum ip_conntrack_info ctinfo,
+				       unsigned char **data, int dataoff,
+				       TransportAddress * addr,
+				       u_int16_t port,
+				       struct ip_conntrack_expect * exp);
+extern int (*nat_q931_hook) (struct sk_buff ** pskb, struct ip_conntrack * ct,
+			     enum ip_conntrack_info ctinfo,
+			     unsigned char **data, TransportAddress * addr,
+			     int idx, u_int16_t port,
+			     struct ip_conntrack_expect * exp);
+
+#endif
+
+#endif
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_helper.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_helper.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_helper.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_helper.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,46 @@
+/* IP connection tracking helpers. */
+#ifndef _IP_CONNTRACK_HELPER_H
+#define _IP_CONNTRACK_HELPER_H
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+
+struct module;
+
+struct ip_conntrack_helper
+{	
+	struct list_head list; 		/* Internal use. */
+
+	const char *name;		/* name of the module */
+	struct module *me;		/* pointer to self */
+	unsigned int max_expected;	/* Maximum number of concurrent 
+					 * expected connections */
+	unsigned int timeout;		/* timeout for expecteds */
+
+	/* Mask of things we will help (compared against server response) */
+	struct ip_conntrack_tuple tuple;
+	struct ip_conntrack_tuple mask;
+	
+	/* Function to call when data passes; return verdict, or -1 to
+           invalidate. */
+	int (*help)(struct sk_buff **pskb,
+		    struct ip_conntrack *ct,
+		    enum ip_conntrack_info conntrackinfo);
+
+	void (*destroy)(struct ip_conntrack *ct);
+
+	int (*to_nfattr)(struct sk_buff *skb, const struct ip_conntrack *ct);
+};
+
+extern int ip_conntrack_helper_register(struct ip_conntrack_helper *);
+extern void ip_conntrack_helper_unregister(struct ip_conntrack_helper *);
+
+/* Allocate space for an expectation: this is mandatory before calling 
+   ip_conntrack_expect_related.  You will have to call put afterwards. */
+extern struct ip_conntrack_expect *
+ip_conntrack_expect_alloc(struct ip_conntrack *master);
+extern void ip_conntrack_expect_put(struct ip_conntrack_expect *exp);
+
+/* Add an expected connection: can have more than one per connection */
+extern int ip_conntrack_expect_related(struct ip_conntrack_expect *exp);
+extern void ip_conntrack_unexpect_related(struct ip_conntrack_expect *exp);
+
+#endif /*_IP_CONNTRACK_HELPER_H*/
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_icmp.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_icmp.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_icmp.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_icmp.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,6 @@
+#ifndef _IP_CONNTRACK_ICMP_H
+#define _IP_CONNTRACK_ICMP_H
+
+#include <net/netfilter/ipv4/nf_conntrack_icmp.h>
+
+#endif /* _IP_CONNTRACK_ICMP_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_irc.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_irc.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_irc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_irc.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,32 @@
+/* IRC extension for IP connection tracking.
+ * (C) 2000 by Harald Welte <laforge@gnumonks.org>
+ * based on RR's ip_conntrack_ftp.h
+ *
+ * ip_conntrack_irc.h,v 1.6 2000/11/07 18:26:42 laforge Exp
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *
+ */
+#ifndef _IP_CONNTRACK_IRC_H
+#define _IP_CONNTRACK_IRC_H
+
+/* This structure exists only once per master */
+struct ip_ct_irc_master {
+};
+
+#ifdef __KERNEL__
+extern unsigned int (*ip_nat_irc_hook)(struct sk_buff **pskb,
+				       enum ip_conntrack_info ctinfo,
+				       unsigned int matchoff,
+				       unsigned int matchlen,
+				       struct ip_conntrack_expect *exp);
+
+#define IRC_PORT	6667
+
+#endif /* __KERNEL__ */
+
+#endif /* _IP_CONNTRACK_IRC_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_pptp.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_pptp.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_pptp.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_pptp.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,326 @@
+/* PPTP constants and structs */
+#ifndef _CONNTRACK_PPTP_H
+#define _CONNTRACK_PPTP_H
+
+/* state of the control session */
+enum pptp_ctrlsess_state {
+	PPTP_SESSION_NONE,			/* no session present */
+	PPTP_SESSION_ERROR,			/* some session error */
+	PPTP_SESSION_STOPREQ,			/* stop_sess request seen */
+	PPTP_SESSION_REQUESTED,			/* start_sess request seen */
+	PPTP_SESSION_CONFIRMED,			/* session established */
+};
+
+/* state of the call inside the control session */
+enum pptp_ctrlcall_state {
+	PPTP_CALL_NONE,
+	PPTP_CALL_ERROR,
+	PPTP_CALL_OUT_REQ,
+	PPTP_CALL_OUT_CONF,
+	PPTP_CALL_IN_REQ,
+	PPTP_CALL_IN_REP,
+	PPTP_CALL_IN_CONF,
+	PPTP_CALL_CLEAR_REQ,
+};
+
+
+/* conntrack private data */
+struct ip_ct_pptp_master {
+	enum pptp_ctrlsess_state sstate;	/* session state */
+
+	/* everything below is going to be per-expectation in newnat,
+	 * since there could be more than one call within one session */
+	enum pptp_ctrlcall_state cstate;	/* call state */
+	__be16 pac_call_id;			/* call id of PAC, host byte order */
+	__be16 pns_call_id;			/* call id of PNS, host byte order */
+
+	/* in pre-2.6.11 this used to be per-expect. Now it is per-conntrack
+	 * and therefore imposes a fixed limit on the number of maps */
+	struct ip_ct_gre_keymap *keymap_orig, *keymap_reply;
+};
+
+/* conntrack_expect private member */
+struct ip_ct_pptp_expect {
+	enum pptp_ctrlcall_state cstate; 	/* call state */
+	__be16 pac_call_id;			/* call id of PAC */
+	__be16 pns_call_id;			/* call id of PNS */
+};
+
+
+#ifdef __KERNEL__
+
+#define IP_CONNTR_PPTP		PPTP_CONTROL_PORT
+
+#define PPTP_CONTROL_PORT	1723
+
+#define PPTP_PACKET_CONTROL	1
+#define PPTP_PACKET_MGMT	2
+
+#define PPTP_MAGIC_COOKIE	0x1a2b3c4d
+
+struct pptp_pkt_hdr {
+	__u16	packetLength;
+	__be16	packetType;
+	__be32	magicCookie;
+};
+
+/* PptpControlMessageType values */
+#define PPTP_START_SESSION_REQUEST	1
+#define PPTP_START_SESSION_REPLY	2
+#define PPTP_STOP_SESSION_REQUEST	3
+#define PPTP_STOP_SESSION_REPLY		4
+#define PPTP_ECHO_REQUEST		5
+#define PPTP_ECHO_REPLY			6
+#define PPTP_OUT_CALL_REQUEST		7
+#define PPTP_OUT_CALL_REPLY		8
+#define PPTP_IN_CALL_REQUEST		9
+#define PPTP_IN_CALL_REPLY		10
+#define PPTP_IN_CALL_CONNECT		11
+#define PPTP_CALL_CLEAR_REQUEST		12
+#define PPTP_CALL_DISCONNECT_NOTIFY	13
+#define PPTP_WAN_ERROR_NOTIFY		14
+#define PPTP_SET_LINK_INFO		15
+
+#define PPTP_MSG_MAX			15
+
+/* PptpGeneralError values */
+#define PPTP_ERROR_CODE_NONE		0
+#define PPTP_NOT_CONNECTED		1
+#define PPTP_BAD_FORMAT			2
+#define PPTP_BAD_VALUE			3
+#define PPTP_NO_RESOURCE		4
+#define PPTP_BAD_CALLID			5
+#define PPTP_REMOVE_DEVICE_ERROR	6
+
+struct PptpControlHeader {
+	__be16	messageType;
+	__u16	reserved;
+};
+
+/* FramingCapability Bitmap Values */
+#define PPTP_FRAME_CAP_ASYNC		0x1
+#define PPTP_FRAME_CAP_SYNC		0x2
+
+/* BearerCapability Bitmap Values */
+#define PPTP_BEARER_CAP_ANALOG		0x1
+#define PPTP_BEARER_CAP_DIGITAL		0x2
+
+struct PptpStartSessionRequest {
+	__be16	protocolVersion;
+	__u16	reserved1;
+	__be32	framingCapability;
+	__be32	bearerCapability;
+	__be16	maxChannels;
+	__be16	firmwareRevision;
+	__u8	hostName[64];
+	__u8	vendorString[64];
+};
+
+/* PptpStartSessionResultCode Values */
+#define PPTP_START_OK			1
+#define PPTP_START_GENERAL_ERROR	2
+#define PPTP_START_ALREADY_CONNECTED	3
+#define PPTP_START_NOT_AUTHORIZED	4
+#define PPTP_START_UNKNOWN_PROTOCOL	5
+
+struct PptpStartSessionReply {
+	__be16	protocolVersion;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__be32	framingCapability;
+	__be32	bearerCapability;
+	__be16	maxChannels;
+	__be16	firmwareRevision;
+	__u8	hostName[64];
+	__u8	vendorString[64];
+};
+
+/* PptpStopReasons */
+#define PPTP_STOP_NONE			1
+#define PPTP_STOP_PROTOCOL		2
+#define PPTP_STOP_LOCAL_SHUTDOWN	3
+
+struct PptpStopSessionRequest {
+	__u8	reason;
+	__u8	reserved1;
+	__u16	reserved2;
+};
+
+/* PptpStopSessionResultCode */
+#define PPTP_STOP_OK			1
+#define PPTP_STOP_GENERAL_ERROR		2
+
+struct PptpStopSessionReply {
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__u16	reserved1;
+};
+
+struct PptpEchoRequest {
+	__be32 identNumber;
+};
+
+/* PptpEchoReplyResultCode */
+#define PPTP_ECHO_OK			1
+#define PPTP_ECHO_GENERAL_ERROR		2
+
+struct PptpEchoReply {
+	__be32	identNumber;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__u16	reserved;
+};
+
+/* PptpFramingType */
+#define PPTP_ASYNC_FRAMING		1
+#define PPTP_SYNC_FRAMING		2
+#define PPTP_DONT_CARE_FRAMING		3
+
+/* PptpCallBearerType */
+#define PPTP_ANALOG_TYPE		1
+#define PPTP_DIGITAL_TYPE		2
+#define PPTP_DONT_CARE_BEARER_TYPE	3
+
+struct PptpOutCallRequest {
+	__be16	callID;
+	__be16	callSerialNumber;
+	__be32	minBPS;
+	__be32	maxBPS;
+	__be32	bearerType;
+	__be32	framingType;
+	__be16	packetWindow;
+	__be16	packetProcDelay;
+	__be16	phoneNumberLength;
+	__u16	reserved1;
+	__u8	phoneNumber[64];
+	__u8	subAddress[64];
+};
+
+/* PptpCallResultCode */
+#define PPTP_OUTCALL_CONNECT		1
+#define PPTP_OUTCALL_GENERAL_ERROR	2
+#define PPTP_OUTCALL_NO_CARRIER		3
+#define PPTP_OUTCALL_BUSY		4
+#define PPTP_OUTCALL_NO_DIAL_TONE	5
+#define PPTP_OUTCALL_TIMEOUT		6
+#define PPTP_OUTCALL_DONT_ACCEPT	7
+
+struct PptpOutCallReply {
+	__be16	callID;
+	__be16	peersCallID;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__be16	causeCode;
+	__be32	connectSpeed;
+	__be16	packetWindow;
+	__be16	packetProcDelay;
+	__be32	physChannelID;
+};
+
+struct PptpInCallRequest {
+	__be16	callID;
+	__be16	callSerialNumber;
+	__be32	callBearerType;
+	__be32	physChannelID;
+	__be16	dialedNumberLength;
+	__be16	dialingNumberLength;
+	__u8	dialedNumber[64];
+	__u8	dialingNumber[64];
+	__u8	subAddress[64];
+};
+
+/* PptpInCallResultCode */
+#define PPTP_INCALL_ACCEPT		1
+#define PPTP_INCALL_GENERAL_ERROR	2
+#define PPTP_INCALL_DONT_ACCEPT		3
+
+struct PptpInCallReply {
+	__be16	callID;
+	__be16	peersCallID;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__be16	packetWindow;
+	__be16	packetProcDelay;
+	__u16	reserved;
+};
+
+struct PptpInCallConnected {
+	__be16	peersCallID;
+	__u16	reserved;
+	__be32	connectSpeed;
+	__be16	packetWindow;
+	__be16	packetProcDelay;
+	__be32	callFramingType;
+};
+
+struct PptpClearCallRequest {
+	__be16	callID;
+	__u16	reserved;
+};
+
+struct PptpCallDisconnectNotify {
+	__be16	callID;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__be16	causeCode;
+	__u16	reserved;
+	__u8	callStatistics[128];
+};
+
+struct PptpWanErrorNotify {
+	__be16	peersCallID;
+	__u16	reserved;
+	__be32	crcErrors;
+	__be32	framingErrors;
+	__be32	hardwareOverRuns;
+	__be32	bufferOverRuns;
+	__be32	timeoutErrors;
+	__be32	alignmentErrors;
+};
+
+struct PptpSetLinkInfo {
+	__be16	peersCallID;
+	__u16	reserved;
+	__be32	sendAccm;
+	__be32	recvAccm;
+};
+
+union pptp_ctrl_union {
+	struct PptpStartSessionRequest	sreq;
+	struct PptpStartSessionReply	srep;
+	struct PptpStopSessionRequest	streq;
+	struct PptpStopSessionReply	strep;
+	struct PptpOutCallRequest	ocreq;
+	struct PptpOutCallReply		ocack;
+	struct PptpInCallRequest	icreq;
+	struct PptpInCallReply		icack;
+	struct PptpInCallConnected	iccon;
+	struct PptpClearCallRequest	clrreq;
+	struct PptpCallDisconnectNotify disc;
+	struct PptpWanErrorNotify	wanerr;
+	struct PptpSetLinkInfo		setlink;
+};
+
+extern int
+(*ip_nat_pptp_hook_outbound)(struct sk_buff **pskb,
+			  struct ip_conntrack *ct,
+			  enum ip_conntrack_info ctinfo,
+			  struct PptpControlHeader *ctlh,
+			  union pptp_ctrl_union *pptpReq);
+
+extern int
+(*ip_nat_pptp_hook_inbound)(struct sk_buff **pskb,
+			  struct ip_conntrack *ct,
+			  enum ip_conntrack_info ctinfo,
+			  struct PptpControlHeader *ctlh,
+			  union pptp_ctrl_union *pptpReq);
+
+extern void
+(*ip_nat_pptp_hook_exp_gre)(struct ip_conntrack_expect *exp_orig,
+			    struct ip_conntrack_expect *exp_reply);
+
+extern void
+(*ip_nat_pptp_hook_expectfn)(struct ip_conntrack *ct,
+			     struct ip_conntrack_expect *exp);
+#endif /* __KERNEL__ */
+#endif /* _CONNTRACK_PPTP_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_protocol.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_protocol.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_protocol.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_protocol.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,98 @@
+/* Header for use in defining a given protocol for connection tracking. */
+#ifndef _IP_CONNTRACK_PROTOCOL_H
+#define _IP_CONNTRACK_PROTOCOL_H
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter/nfnetlink_conntrack.h>
+
+struct seq_file;
+
+struct ip_conntrack_protocol
+{
+	/* Protocol number. */
+	u_int8_t proto;
+
+	/* Protocol name */
+	const char *name;
+
+	/* Try to fill in the third arg: dataoff is offset past IP
+           hdr.  Return true if possible. */
+	int (*pkt_to_tuple)(const struct sk_buff *skb,
+			   unsigned int dataoff,
+			   struct ip_conntrack_tuple *tuple);
+
+	/* Invert the per-proto part of the tuple: ie. turn xmit into reply.
+	 * Some packets can't be inverted: return 0 in that case.
+	 */
+	int (*invert_tuple)(struct ip_conntrack_tuple *inverse,
+			    const struct ip_conntrack_tuple *orig);
+
+	/* Print out the per-protocol part of the tuple. Return like seq_* */
+	int (*print_tuple)(struct seq_file *,
+			   const struct ip_conntrack_tuple *);
+
+	/* Print out the private part of the conntrack. */
+	int (*print_conntrack)(struct seq_file *, const struct ip_conntrack *);
+
+	/* Returns verdict for packet, or -1 for invalid. */
+	int (*packet)(struct ip_conntrack *conntrack,
+		      const struct sk_buff *skb,
+		      enum ip_conntrack_info ctinfo);
+
+	/* Called when a new connection for this protocol found;
+	 * returns TRUE if it's OK.  If so, packet() called next. */
+	int (*new)(struct ip_conntrack *conntrack, const struct sk_buff *skb);
+
+	/* Called when a conntrack entry is destroyed */
+	void (*destroy)(struct ip_conntrack *conntrack);
+
+	int (*error)(struct sk_buff *skb, enum ip_conntrack_info *ctinfo,
+		     unsigned int hooknum);
+
+	/* convert protoinfo to nfnetink attributes */
+	int (*to_nfattr)(struct sk_buff *skb, struct nfattr *nfa,
+			 const struct ip_conntrack *ct);
+
+	/* convert nfnetlink attributes to protoinfo */
+	int (*from_nfattr)(struct nfattr *tb[], struct ip_conntrack *ct);
+
+	int (*tuple_to_nfattr)(struct sk_buff *skb,
+			       const struct ip_conntrack_tuple *t);
+	int (*nfattr_to_tuple)(struct nfattr *tb[],
+			       struct ip_conntrack_tuple *t);
+
+	/* Module (if any) which this is connected to. */
+	struct module *me;
+};
+
+/* Protocol registration. */
+extern int ip_conntrack_protocol_register(struct ip_conntrack_protocol *proto);
+extern void ip_conntrack_protocol_unregister(struct ip_conntrack_protocol *proto);
+/* Existing built-in protocols */
+extern struct ip_conntrack_protocol ip_conntrack_protocol_tcp;
+extern struct ip_conntrack_protocol ip_conntrack_protocol_udp;
+extern struct ip_conntrack_protocol ip_conntrack_protocol_icmp;
+extern struct ip_conntrack_protocol ip_conntrack_generic_protocol;
+extern int ip_conntrack_protocol_tcp_init(void);
+
+/* Log invalid packets */
+extern unsigned int ip_ct_log_invalid;
+
+extern int ip_ct_port_tuple_to_nfattr(struct sk_buff *,
+				      const struct ip_conntrack_tuple *);
+extern int ip_ct_port_nfattr_to_tuple(struct nfattr *tb[],
+				      struct ip_conntrack_tuple *);
+
+#ifdef CONFIG_SYSCTL
+#ifdef DEBUG_INVALID_PACKETS
+#define LOG_INVALID(proto) \
+	(ip_ct_log_invalid == (proto) || ip_ct_log_invalid == IPPROTO_RAW)
+#else
+#define LOG_INVALID(proto) \
+	((ip_ct_log_invalid == (proto) || ip_ct_log_invalid == IPPROTO_RAW) \
+	 && net_ratelimit())
+#endif
+#else
+#define LOG_INVALID(proto) 0
+#endif /* CONFIG_SYSCTL */
+
+#endif /*_IP_CONNTRACK_PROTOCOL_H*/
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,114 @@
+#ifndef _CONNTRACK_PROTO_GRE_H
+#define _CONNTRACK_PROTO_GRE_H
+#include <asm/byteorder.h>
+
+/* GRE PROTOCOL HEADER */
+
+/* GRE Version field */
+#define GRE_VERSION_1701	0x0
+#define GRE_VERSION_PPTP	0x1
+
+/* GRE Protocol field */
+#define GRE_PROTOCOL_PPTP	0x880B
+
+/* GRE Flags */
+#define GRE_FLAG_C		0x80
+#define GRE_FLAG_R		0x40
+#define GRE_FLAG_K		0x20
+#define GRE_FLAG_S		0x10
+#define GRE_FLAG_A		0x80
+
+#define GRE_IS_C(f)	((f)&GRE_FLAG_C)
+#define GRE_IS_R(f)	((f)&GRE_FLAG_R)
+#define GRE_IS_K(f)	((f)&GRE_FLAG_K)
+#define GRE_IS_S(f)	((f)&GRE_FLAG_S)
+#define GRE_IS_A(f)	((f)&GRE_FLAG_A)
+
+/* GRE is a mess: Four different standards */
+struct gre_hdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u16	rec:3,
+		srr:1,
+		seq:1,
+		key:1,
+		routing:1,
+		csum:1,
+		version:3,
+		reserved:4,
+		ack:1;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u16	csum:1,
+		routing:1,
+		key:1,
+		seq:1,
+		srr:1,
+		rec:3,
+		ack:1,
+		reserved:4,
+		version:3;
+#else
+#error "Adjust your <asm/byteorder.h> defines"
+#endif
+	__be16	protocol;
+};
+
+/* modified GRE header for PPTP */
+struct gre_hdr_pptp {
+	__u8   flags;		/* bitfield */
+	__u8   version;		/* should be GRE_VERSION_PPTP */
+	__be16 protocol;	/* should be GRE_PROTOCOL_PPTP */
+	__be16 payload_len;	/* size of ppp payload, not inc. gre header */
+	__be16 call_id;		/* peer's call_id for this session */
+	__be32 seq;		/* sequence number.  Present if S==1 */
+	__be32 ack;		/* seq number of highest packet recieved by */
+				/*  sender in this session */
+};
+
+
+/* this is part of ip_conntrack */
+struct ip_ct_gre {
+	unsigned int stream_timeout;
+	unsigned int timeout;
+};
+
+#ifdef __KERNEL__
+struct ip_conntrack_expect;
+struct ip_conntrack;
+
+/* structure for original <-> reply keymap */
+struct ip_ct_gre_keymap {
+	struct list_head list;
+
+	struct ip_conntrack_tuple tuple;
+};
+
+/* add new tuple->key_reply pair to keymap */
+int ip_ct_gre_keymap_add(struct ip_conntrack *ct,
+			 struct ip_conntrack_tuple *t,
+			 int reply);
+
+/* delete keymap entries */
+void ip_ct_gre_keymap_destroy(struct ip_conntrack *ct);
+
+
+/* get pointer to gre key, if present */
+static inline __be32 *gre_key(struct gre_hdr *greh)
+{
+	if (!greh->key)
+		return NULL;
+	if (greh->csum || greh->routing)
+		return (__be32 *) (greh+sizeof(*greh)+4);
+	return (__be32 *) (greh+sizeof(*greh));
+}
+
+/* get pointer ot gre csum, if present */
+static inline __sum16 *gre_csum(struct gre_hdr *greh)
+{
+	if (!greh->csum)
+		return NULL;
+	return (__sum16 *) (greh+sizeof(*greh));
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _CONNTRACK_PROTO_GRE_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_sctp.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_sctp.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_sctp.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_sctp.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,6 @@
+#ifndef _IP_CONNTRACK_SCTP_H
+#define _IP_CONNTRACK_SCTP_H
+
+#include <linux/netfilter/nf_conntrack_sctp.h>
+
+#endif /* _IP_CONNTRACK_SCTP_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_sip.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_sip.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_sip.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_sip.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,40 @@
+#ifndef __IP_CONNTRACK_SIP_H__
+#define __IP_CONNTRACK_SIP_H__
+#ifdef __KERNEL__
+
+#define SIP_PORT	5060
+#define SIP_TIMEOUT	3600
+
+enum sip_header_pos {
+	POS_REG_REQ_URI,
+	POS_REQ_URI,
+	POS_FROM,
+	POS_TO,
+	POS_VIA,
+	POS_CONTACT,
+	POS_CONTENT,
+	POS_MEDIA,
+	POS_OWNER,
+	POS_CONNECTION,
+	POS_SDP_HEADER,
+};
+
+extern unsigned int (*ip_nat_sip_hook)(struct sk_buff **pskb,
+				       enum ip_conntrack_info ctinfo,
+				       struct ip_conntrack *ct,
+				       const char **dptr);
+extern unsigned int (*ip_nat_sdp_hook)(struct sk_buff **pskb,
+				       enum ip_conntrack_info ctinfo,
+				       struct ip_conntrack_expect *exp,
+				       const char *dptr);
+
+extern int ct_sip_get_info(const char *dptr, size_t dlen,
+			   unsigned int *matchoff,
+			   unsigned int *matchlen,
+			   enum sip_header_pos pos);
+extern int ct_sip_lnlen(const char *line, const char *limit);
+extern const char *ct_sip_search(const char *needle, const char *haystack,
+				 size_t needle_len, size_t haystack_len,
+				 int case_sensitive);
+#endif /* __KERNEL__ */
+#endif /* __IP_CONNTRACK_SIP_H__ */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_tcp.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_tcp.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_tcp.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_tcp.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,6 @@
+#ifndef _IP_CONNTRACK_TCP_H
+#define _IP_CONNTRACK_TCP_H
+
+#include <linux/netfilter/nf_conntrack_tcp.h>
+
+#endif /* _IP_CONNTRACK_TCP_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_tftp.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_tftp.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_tftp.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_tftp.h	2009-06-19 18:07:57.000000000 +0400
@@ -0,0 +1,20 @@
+#ifndef _IP_CT_TFTP
+#define _IP_CT_TFTP
+
+#define TFTP_PORT 69
+
+struct tftphdr {
+	__be16 opcode;
+};
+
+#define TFTP_OPCODE_READ	1
+#define TFTP_OPCODE_WRITE	2
+#define TFTP_OPCODE_DATA	3
+#define TFTP_OPCODE_ACK		4
+#define TFTP_OPCODE_ERROR	5
+
+extern unsigned int (*ip_nat_tftp_hook)(struct sk_buff **pskb,
+				 enum ip_conntrack_info ctinfo,
+				 struct ip_conntrack_expect *exp);
+
+#endif /* _IP_CT_TFTP */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_tuple.h linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_tuple.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_tuple.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_tuple.h	2009-06-19 17:53:44.000000000 +0400
@@ -0,0 +1,171 @@
+#ifndef _IP_CONNTRACK_TUPLE_H
+#define _IP_CONNTRACK_TUPLE_H
+
+#include <linux/types.h>
+#include <linux/netfilter/nf_conntrack_tuple_common.h>
+
+#define ASUS_QOS 1
+
+/* A `tuple' is a structure containing the information to uniquely
+  identify a connection.  ie. if two packets have the same tuple, they
+  are in the same connection; if not, they are not.
+
+  We divide the structure along "manipulatable" and
+  "non-manipulatable" lines, for the benefit of the NAT code.
+*/
+
+/* The protocol-specific manipulable parts of the tuple: always in
+   network order! */
+union ip_conntrack_manip_proto
+{
+	/* Add other protocols here. */
+	u_int16_t all;
+
+	struct {
+		__be16 port;
+	} tcp;
+	struct {
+		__be16 port;
+	} udp;
+	struct {
+		__be16 id;
+	} icmp;
+	struct {
+		__be16 port;
+	} sctp;
+	struct {
+		__be16 key;	/* key is 32bit, pptp only uses 16 */
+	} gre;
+};
+
+/* The manipulable part of the tuple. */
+struct ip_conntrack_manip
+{
+	__be32 ip;
+	union ip_conntrack_manip_proto u;
+};
+
+/* This contains the information to distinguish a connection. */
+struct ip_conntrack_tuple
+{
+	struct ip_conntrack_manip src;
+
+	/* These are the parts of the tuple which are fixed. */
+	struct {
+		__be32 ip;
+		union {
+			/* Add other protocols here. */
+			u_int16_t all;
+
+			struct {
+				__be16 port;
+			} tcp;
+			struct {
+				__be16 port;
+			} udp;
+			struct {
+				u_int8_t type, code;
+			} icmp;
+			struct {
+				__be16 port;
+			} sctp;
+			struct {
+				__be16 key;	/* key is 32bit, 
+						 * pptp only uses 16 */
+			} gre;
+		} u;
+
+		/* The protocol. */
+		u_int8_t protonum;
+
+		/* The direction (for tuplehash) */
+		u_int8_t dir;
+	} dst;
+};
+
+/* This is optimized opposed to a memset of the whole structure.  Everything we
+ * really care about is the  source/destination unions */
+#define IP_CT_TUPLE_U_BLANK(tuple) 				\
+	do {							\
+		(tuple)->src.u.all = 0;				\
+		(tuple)->dst.u.all = 0;				\
+	} while (0)
+
+#ifdef __KERNEL__
+
+#define DUMP_TUPLE(tp)						\
+DEBUGP("tuple %p: %u %u.%u.%u.%u:%hu -> %u.%u.%u.%u:%hu\n",	\
+       (tp), (tp)->dst.protonum,				\
+       NIPQUAD((tp)->src.ip), ntohs((tp)->src.u.all),		\
+       NIPQUAD((tp)->dst.ip), ntohs((tp)->dst.u.all))
+
+/* If we're the first tuple, it's the original dir. */
+#define DIRECTION(h) ((enum ip_conntrack_dir)(h)->tuple.dst.dir)
+
+#ifdef ASUS QOS
+#define IP_TRACK_MAX              10
+#define IP_TRACK_COMPARE          40
+
+#define IP_TRACK_FULL           0x01
+#define IP_TRACK_PORT           0x02
+#define IP_TRACK_DATA           0x04
+#define IP_TRACK_PD             0x08
+#define IP_TRACK_DOWN           0x10
+#define IP_TRACK_TIME           0x20
+
+struct ip_track
+{
+        int flag;
+        u_int8_t number;
+        int length[IP_TRACK_MAX];
+};
+#endif
+
+/* Connections have two entries in the hash table: one for each way */
+struct ip_conntrack_tuple_hash
+{
+	struct list_head list;
+
+	struct ip_conntrack_tuple tuple;
+
+#ifdef ASUS_QOS
+	struct ip_track track;
+#endif
+};
+
+#endif /* __KERNEL__ */
+
+static inline int ip_ct_tuple_src_equal(const struct ip_conntrack_tuple *t1,
+				        const struct ip_conntrack_tuple *t2)
+{
+	return t1->src.ip == t2->src.ip
+		&& t1->src.u.all == t2->src.u.all;
+}
+
+static inline int ip_ct_tuple_dst_equal(const struct ip_conntrack_tuple *t1,
+				        const struct ip_conntrack_tuple *t2)
+{
+	return t1->dst.ip == t2->dst.ip
+		&& t1->dst.u.all == t2->dst.u.all
+		&& t1->dst.protonum == t2->dst.protonum;
+}
+
+static inline int ip_ct_tuple_equal(const struct ip_conntrack_tuple *t1,
+				    const struct ip_conntrack_tuple *t2)
+{
+	return ip_ct_tuple_src_equal(t1, t2) && ip_ct_tuple_dst_equal(t1, t2);
+}
+
+static inline int ip_ct_tuple_mask_cmp(const struct ip_conntrack_tuple *t,
+				       const struct ip_conntrack_tuple *tuple,
+				       const struct ip_conntrack_tuple *mask)
+{
+	return !(((t->src.ip ^ tuple->src.ip) & mask->src.ip)
+		 || ((t->dst.ip ^ tuple->dst.ip) & mask->dst.ip)
+		 || ((t->src.u.all ^ tuple->src.u.all) & mask->src.u.all)
+		 || ((t->dst.u.all ^ tuple->dst.u.all) & mask->dst.u.all)
+		 || ((t->dst.protonum ^ tuple->dst.protonum)
+		     & mask->dst.protonum));
+}
+
+#endif /* _IP_CONNTRACK_TUPLE_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_tuple.h.3200 linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_tuple.h.3200
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_conntrack_tuple.h.3200	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_conntrack_tuple.h.3200	2009-06-19 18:07:58.000000000 +0400
@@ -0,0 +1,146 @@
+#ifndef _IP_CONNTRACK_TUPLE_H
+#define _IP_CONNTRACK_TUPLE_H
+
+#include <linux/types.h>
+#include <linux/netfilter/nf_conntrack_tuple_common.h>
+
+/* A `tuple' is a structure containing the information to uniquely
+  identify a connection.  ie. if two packets have the same tuple, they
+  are in the same connection; if not, they are not.
+
+  We divide the structure along "manipulatable" and
+  "non-manipulatable" lines, for the benefit of the NAT code.
+*/
+
+/* The protocol-specific manipulable parts of the tuple: always in
+   network order! */
+union ip_conntrack_manip_proto
+{
+	/* Add other protocols here. */
+	u_int16_t all;
+
+	struct {
+		__be16 port;
+	} tcp;
+	struct {
+		__be16 port;
+	} udp;
+	struct {
+		__be16 id;
+	} icmp;
+	struct {
+		__be16 port;
+	} sctp;
+	struct {
+		__be16 key;	/* key is 32bit, pptp only uses 16 */
+	} gre;
+};
+
+/* The manipulable part of the tuple. */
+struct ip_conntrack_manip
+{
+	__be32 ip;
+	union ip_conntrack_manip_proto u;
+};
+
+/* This contains the information to distinguish a connection. */
+struct ip_conntrack_tuple
+{
+	struct ip_conntrack_manip src;
+
+	/* These are the parts of the tuple which are fixed. */
+	struct {
+		__be32 ip;
+		union {
+			/* Add other protocols here. */
+			u_int16_t all;
+
+			struct {
+				__be16 port;
+			} tcp;
+			struct {
+				__be16 port;
+			} udp;
+			struct {
+				u_int8_t type, code;
+			} icmp;
+			struct {
+				__be16 port;
+			} sctp;
+			struct {
+				__be16 key;	/* key is 32bit, 
+						 * pptp only uses 16 */
+			} gre;
+		} u;
+
+		/* The protocol. */
+		u_int8_t protonum;
+
+		/* The direction (for tuplehash) */
+		u_int8_t dir;
+	} dst;
+};
+
+/* This is optimized opposed to a memset of the whole structure.  Everything we
+ * really care about is the  source/destination unions */
+#define IP_CT_TUPLE_U_BLANK(tuple) 				\
+	do {							\
+		(tuple)->src.u.all = 0;				\
+		(tuple)->dst.u.all = 0;				\
+	} while (0)
+
+#ifdef __KERNEL__
+
+#define DUMP_TUPLE(tp)						\
+DEBUGP("tuple %p: %u %u.%u.%u.%u:%hu -> %u.%u.%u.%u:%hu\n",	\
+       (tp), (tp)->dst.protonum,				\
+       NIPQUAD((tp)->src.ip), ntohs((tp)->src.u.all),		\
+       NIPQUAD((tp)->dst.ip), ntohs((tp)->dst.u.all))
+
+/* If we're the first tuple, it's the original dir. */
+#define DIRECTION(h) ((enum ip_conntrack_dir)(h)->tuple.dst.dir)
+
+/* Connections have two entries in the hash table: one for each way */
+struct ip_conntrack_tuple_hash
+{
+	struct list_head list;
+
+	struct ip_conntrack_tuple tuple;
+};
+
+#endif /* __KERNEL__ */
+
+static inline int ip_ct_tuple_src_equal(const struct ip_conntrack_tuple *t1,
+				        const struct ip_conntrack_tuple *t2)
+{
+	return t1->src.ip == t2->src.ip
+		&& t1->src.u.all == t2->src.u.all;
+}
+
+static inline int ip_ct_tuple_dst_equal(const struct ip_conntrack_tuple *t1,
+				        const struct ip_conntrack_tuple *t2)
+{
+	return t1->dst.ip == t2->dst.ip
+		&& t1->dst.u.all == t2->dst.u.all
+		&& t1->dst.protonum == t2->dst.protonum;
+}
+
+static inline int ip_ct_tuple_equal(const struct ip_conntrack_tuple *t1,
+				    const struct ip_conntrack_tuple *t2)
+{
+	return ip_ct_tuple_src_equal(t1, t2) && ip_ct_tuple_dst_equal(t1, t2);
+}
+
+static inline int ip_ct_tuple_mask_cmp(const struct ip_conntrack_tuple *t,
+				       const struct ip_conntrack_tuple *tuple,
+				       const struct ip_conntrack_tuple *mask)
+{
+	return !(((t->src.ip ^ tuple->src.ip) & mask->src.ip)
+		 || ((t->dst.ip ^ tuple->dst.ip) & mask->dst.ip)
+		 || ((t->src.u.all ^ tuple->src.u.all) & mask->src.u.all)
+		 || ((t->dst.u.all ^ tuple->dst.u.all) & mask->dst.u.all)
+		 || ((t->dst.protonum ^ tuple->dst.protonum)
+		     & mask->dst.protonum));
+}
+
+#endif /* _IP_CONNTRACK_TUPLE_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_core.h linux-2.6/include/linux/netfilter_ipv4/ip_nat_core.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_core.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_nat_core.h	2009-06-19 18:07:58.000000000 +0400
@@ -0,0 +1,18 @@
+#ifndef _IP_NAT_CORE_H
+#define _IP_NAT_CORE_H
+#include <linux/list.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+
+/* This header used to share core functionality between the standalone
+   NAT module, and the compatibility layer's use of NAT for masquerading. */
+
+extern unsigned int ip_nat_packet(struct ip_conntrack *ct,
+			       enum ip_conntrack_info conntrackinfo,
+			       unsigned int hooknum,
+			       struct sk_buff **pskb);
+
+extern int ip_nat_icmp_reply_translation(struct ip_conntrack *ct,
+					 enum ip_conntrack_info ctinfo,
+					 unsigned int hooknum,
+					 struct sk_buff **pskb);
+#endif /* _IP_NAT_CORE_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_nat.h linux-2.6/include/linux/netfilter_ipv4/ip_nat.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_nat.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_nat.h	2009-06-19 17:53:39.000000000 +0400
@@ -0,0 +1,79 @@
+#ifndef _IP_NAT_H
+#define _IP_NAT_H
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv4/ip_conntrack_tuple.h>
+
+#define IP_NAT_MAPPING_TYPE_MAX_NAMELEN 16
+
+enum ip_nat_manip_type
+{
+	IP_NAT_MANIP_SRC,
+	IP_NAT_MANIP_DST
+};
+
+/* SRC manip occurs POST_ROUTING or LOCAL_IN */
+#define HOOK2MANIP(hooknum) ((hooknum) != NF_IP_POST_ROUTING && (hooknum) != NF_IP_LOCAL_IN)
+
+#define IP_NAT_RANGE_MAP_IPS 1
+#define IP_NAT_RANGE_PROTO_SPECIFIED 2
+#define IP_NAT_RANGE_PROTO_RANDOM 4 /* add randomness to "port" selection */
+
+/* NAT sequence number modifications */
+struct ip_nat_seq {
+	/* position of the last TCP sequence number 
+	 * modification (if any) */
+	u_int32_t correction_pos;
+	/* sequence number offset before and after last modification */
+	int16_t offset_before, offset_after;
+};
+
+/* Single range specification. */
+struct ip_nat_range
+{
+	/* Set to OR of flags above. */
+	unsigned int flags;
+
+	/* Inclusive: network order. */
+	__be32 min_ip, max_ip;
+
+	/* Inclusive: network order */
+	union ip_conntrack_manip_proto min, max;
+};
+
+/* For backwards compat: don't use in modern code. */
+struct ip_nat_multi_range_compat
+{
+	unsigned int rangesize; /* Must be 1. */
+
+	/* hangs off end. */
+	struct ip_nat_range range[1];
+};
+
+#ifdef __KERNEL__
+#include <linux/list.h>
+
+/* Protects NAT hash tables, and NAT-private part of conntracks. */
+extern rwlock_t ip_nat_lock;
+
+/* The structure embedded in the conntrack structure. */
+struct ip_nat_info
+{
+	struct list_head bysource;
+	struct ip_nat_seq seq[IP_CT_DIR_MAX];
+};
+
+struct ip_conntrack;
+
+/* Set up the info structure to map into this range. */
+extern unsigned int ip_nat_setup_info(struct ip_conntrack *conntrack,
+				      const struct ip_nat_range *range,
+				      unsigned int hooknum);
+
+/* Is this tuple already taken? (not by us)*/
+extern int ip_nat_used_tuple(const struct ip_conntrack_tuple *tuple,
+			     const struct ip_conntrack *ignored_conntrack);
+
+#else  /* !__KERNEL__: iptables wants this to compile. */
+#define ip_nat_multi_range ip_nat_multi_range_compat
+#endif /*__KERNEL__*/
+#endif
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_helper.h linux-2.6/include/linux/netfilter_ipv4/ip_nat_helper.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_helper.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_nat_helper.h	2009-06-19 18:08:01.000000000 +0400
@@ -0,0 +1,33 @@
+#ifndef _IP_NAT_HELPER_H
+#define _IP_NAT_HELPER_H
+/* NAT protocol helper routines. */
+
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/module.h>
+
+struct sk_buff;
+
+/* These return true or false. */
+extern int ip_nat_mangle_tcp_packet(struct sk_buff **skb,
+				struct ip_conntrack *ct,
+				enum ip_conntrack_info ctinfo,
+				unsigned int match_offset,
+				unsigned int match_len,
+				const char *rep_buffer,
+				unsigned int rep_len);
+extern int ip_nat_mangle_udp_packet(struct sk_buff **skb,
+				struct ip_conntrack *ct,
+				enum ip_conntrack_info ctinfo,
+				unsigned int match_offset,
+				unsigned int match_len,
+				const char *rep_buffer,
+				unsigned int rep_len);
+extern int ip_nat_seq_adjust(struct sk_buff **pskb, 
+			     struct ip_conntrack *ct, 
+			     enum ip_conntrack_info ctinfo);
+
+/* Setup NAT on this expected conntrack so it follows master, but goes
+ * to port ct->master->saved_proto. */
+extern void ip_nat_follow_master(struct ip_conntrack *ct,
+				 struct ip_conntrack_expect *this);
+#endif
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_pptp.h linux-2.6/include/linux/netfilter_ipv4/ip_nat_pptp.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_pptp.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_nat_pptp.h	2009-06-19 18:08:01.000000000 +0400
@@ -0,0 +1,11 @@
+/* PPTP constants and structs */
+#ifndef _NAT_PPTP_H
+#define _NAT_PPTP_H
+
+/* conntrack private data */
+struct ip_nat_pptp {
+	__be16 pns_call_id;		/* NAT'ed PNS call id */
+	__be16 pac_call_id;		/* NAT'ed PAC call id */
+};
+
+#endif /* _NAT_PPTP_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_protocol.h linux-2.6/include/linux/netfilter_ipv4/ip_nat_protocol.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_protocol.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_nat_protocol.h	2009-06-19 18:08:01.000000000 +0400
@@ -0,0 +1,74 @@
+/* Header for use in defining a given protocol. */
+#ifndef _IP_NAT_PROTOCOL_H
+#define _IP_NAT_PROTOCOL_H
+#include <linux/init.h>
+#include <linux/list.h>
+
+#include <linux/netfilter_ipv4/ip_nat.h>
+#include <linux/netfilter/nfnetlink_conntrack.h>
+
+struct iphdr;
+struct ip_nat_range;
+
+struct ip_nat_protocol
+{
+	/* Protocol name */
+	const char *name;
+
+	/* Protocol number. */
+	unsigned int protonum;
+
+	struct module *me;
+
+	/* Translate a packet to the target according to manip type.
+	   Return true if succeeded. */
+	int (*manip_pkt)(struct sk_buff **pskb,
+			 unsigned int iphdroff,
+			 const struct ip_conntrack_tuple *tuple,
+			 enum ip_nat_manip_type maniptype);
+
+	/* Is the manipable part of the tuple between min and max incl? */
+	int (*in_range)(const struct ip_conntrack_tuple *tuple,
+			enum ip_nat_manip_type maniptype,
+			const union ip_conntrack_manip_proto *min,
+			const union ip_conntrack_manip_proto *max);
+
+	/* Alter the per-proto part of the tuple (depending on
+	   maniptype), to give a unique tuple in the given range if
+	   possible; return false if not.  Per-protocol part of tuple
+	   is initialized to the incoming packet. */
+	int (*unique_tuple)(struct ip_conntrack_tuple *tuple,
+			    const struct ip_nat_range *range,
+			    enum ip_nat_manip_type maniptype,
+			    const struct ip_conntrack *conntrack);
+
+	int (*range_to_nfattr)(struct sk_buff *skb,
+			       const struct ip_nat_range *range);
+
+	int (*nfattr_to_range)(struct nfattr *tb[],
+			       struct ip_nat_range *range);
+};
+
+/* Protocol registration. */
+extern int ip_nat_protocol_register(struct ip_nat_protocol *proto);
+extern void ip_nat_protocol_unregister(struct ip_nat_protocol *proto);
+
+extern struct ip_nat_protocol *ip_nat_proto_find_get(u_int8_t protocol);
+extern void ip_nat_proto_put(struct ip_nat_protocol *proto);
+
+/* Built-in protocols. */
+extern struct ip_nat_protocol ip_nat_protocol_tcp;
+extern struct ip_nat_protocol ip_nat_protocol_udp;
+extern struct ip_nat_protocol ip_nat_protocol_icmp;
+extern struct ip_nat_protocol ip_nat_unknown_protocol;
+
+extern int init_protocols(void) __init;
+extern void cleanup_protocols(void);
+extern struct ip_nat_protocol *find_nat_proto(u_int16_t protonum);
+
+extern int ip_nat_port_range_to_nfattr(struct sk_buff *skb,
+				       const struct ip_nat_range *range);
+extern int ip_nat_port_nfattr_to_range(struct nfattr *tb[],
+				       struct ip_nat_range *range);
+
+#endif /*_IP_NAT_PROTO_H*/
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_rule.h linux-2.6/include/linux/netfilter_ipv4/ip_nat_rule.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ip_nat_rule.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ip_nat_rule.h	2009-06-19 18:08:22.000000000 +0400
@@ -0,0 +1,18 @@
+#ifndef _IP_NAT_RULE_H
+#define _IP_NAT_RULE_H
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_nat.h>
+
+#ifdef __KERNEL__
+
+extern int ip_nat_rule_init(void) __init;
+extern void ip_nat_rule_cleanup(void);
+extern int ip_nat_rule_find(struct sk_buff **pskb,
+			    unsigned int hooknum,
+			    const struct net_device *in,
+			    const struct net_device *out,
+			    struct ip_conntrack *ct,
+			    struct ip_nat_info *info);
+#endif
+#endif /* _IP_NAT_RULE_H */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ipt_time.h linux-2.6/include/linux/netfilter_ipv4/ipt_time.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ipt_time.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ipt_time.h	2009-04-13 16:01:04.000000000 +0400
@@ -0,0 +1,15 @@
+#ifndef __ipt_time_h_included__
+#define __ipt_time_h_included__
+
+
+struct ipt_time_info {
+	u_int8_t days_match;	/* 1 bit per day (bit 0 = Sunday) */
+	u_int32_t time_start;	/* 0 < time_start < 24*60*60-1 = 86399 */
+	u_int32_t time_stop;		/* 0 < time_end < 24*60*60-1 = 86399 */
+	u_int8_t kerneltime;			/* ignore skb time (and use kerneltime) or not. */
+	time_t date_start;
+	time_t date_stop;
+};
+
+
+#endif /* __ipt_time_h_included__ */
diff -urBwNp linux-2.6.22/include/linux/netfilter_ipv4/ipt_webstr.h linux-2.6/include/linux/netfilter_ipv4/ipt_webstr.h
--- linux-2.6.22/include/linux/netfilter_ipv4/ipt_webstr.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/include/linux/netfilter_ipv4/ipt_webstr.h	2009-05-26 13:24:24.000000000 +0400
@@ -0,0 +1,28 @@
+#ifndef _IPT_WEBSTR_H
+#define _IPT_WEBSTR_H
+
+#define BM_MAX_NLEN 256
+#define BM_MAX_HLEN 1024
+
+#define BLK_JAVA		0x01
+#define BLK_ACTIVE		0x02
+#define BLK_COOKIE		0x04
+#define BLK_PROXY		0x08
+
+typedef char *(*proc_ipt_search) (char *, char *, int, int);
+
+struct ipt_webstr_info {
+    char string[BM_MAX_NLEN];
+    u_int16_t invert;
+    u_int16_t len;
+    u_int8_t type;
+};
+
+enum ipt_webstr_type
+{
+    IPT_WEBSTR_HOST,
+    IPT_WEBSTR_URL,
+    IPT_WEBSTR_CONTENT
+};
+
+#endif /* _IPT_WEBSTR_H */
diff -urBwNp linux-2.6.22/include/net/netfilter/nf_conntrack.h linux-2.6/include/net/netfilter/nf_conntrack.h
--- linux-2.6.22/include/net/netfilter/nf_conntrack.h	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/include/net/netfilter/nf_conntrack.h	2008-12-12 06:34:34.000000000 +0300
@@ -46,6 +46,7 @@ union nf_conntrack_expect_proto {
 #include <linux/netfilter/nf_conntrack_pptp.h>
 #include <linux/netfilter/nf_conntrack_h323.h>
 #include <linux/netfilter/nf_conntrack_sane.h>
+#include <linux/netfilter/nf_conntrack_autofw.h>
 
 /* per conntrack: application helper private data */
 union nf_conntrack_help {
@@ -54,6 +55,7 @@ union nf_conntrack_help {
 	struct nf_ct_pptp_master ct_pptp_info;
 	struct nf_ct_h323_master ct_h323_info;
 	struct nf_ct_sane_master ct_sane_info;
+	struct nf_ct_autofw_master ct_autofw_info;
 };
 
 #include <linux/types.h>
diff -urBwNp linux-2.6.22/include/net/netfilter/nf_conntrack_tuple.h linux-2.6/include/net/netfilter/nf_conntrack_tuple.h
--- linux-2.6.22/include/net/netfilter/nf_conntrack_tuple.h	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/include/net/netfilter/nf_conntrack_tuple.h	2009-03-30 07:05:24.000000000 +0400
@@ -122,12 +122,23 @@ DEBUGP("tuple %p: %u %u " NIP6_FMT " %hu
 #define NF_CT_DIRECTION(h)						\
 	((enum ip_conntrack_dir)(h)->tuple.dst.dir)
 
+//--SZ Angela 09.03 Add for QOS {
+struct ip_track 
+{
+	u_int8_t number;
+	u_int8_t large_packet;
+	u_int8_t flag;
+};
+//--SZ angela 09.03 Add for QOS }
+
 /* Connections have two entries in the hash table: one for each way */
 struct nf_conntrack_tuple_hash
 {
 	struct list_head list;
 
 	struct nf_conntrack_tuple tuple;
+
+	struct ip_track track; //--SZ angela 09.03
 };
 
 #endif /* __KERNEL__ */
diff -urBwNp linux-2.6.22/net/ipv4/netfilter/ipt_time.c linux-2.6/net/ipv4/netfilter/ipt_time.c
--- linux-2.6.22/net/ipv4/netfilter/ipt_time.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/net/ipv4/netfilter/ipt_time.c	2009-04-13 17:03:03.000000000 +0400
@@ -0,0 +1,181 @@
+/*
+  This is a module which is used for time matching
+  It is using some modified code from dietlibc (localtime() function)
+  that you can find at http://www.fefe.de/dietlibc/
+  This file is distributed under the terms of the GNU General Public
+  License (GPL). Copies of the GPL can be obtained from: ftp://prep.ai.mit.edu/pub/gnu/GPL
+  2001-05-04 Fabrice MARIE <fabrice@netfilter.org> : initial development.
+  2001-21-05 Fabrice MARIE <fabrice@netfilter.org> : bug fix in the match code,
+     thanks to "Zeng Yu" <zengy@capitel.com.cn> for bug report.
+  2001-26-09 Fabrice MARIE <fabrice@netfilter.org> : force the match to be in LOCAL_IN or PRE_ROUTING only.
+  2001-30-11 Fabrice : added the possibility to use the match in FORWARD/OUTPUT with a little hack,
+     added Nguyen Dang Phuoc Dong <dongnd@tlnet.com.vn> patch to support timezones.
+  2004-05-02 Fabrice : added support for date matching, from an idea of Fabien COELHO.
+*/
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_time.h>
+#include <linux/time.h>
+
+MODULE_AUTHOR("Fabrice MARIE <fabrice@netfilter.org>");
+MODULE_DESCRIPTION("Match arrival timestamp/date");
+MODULE_LICENSE("GPL");
+
+struct tm
+{
+	int tm_sec;                   /* Seconds.     [0-60] (1 leap second) */
+	int tm_min;                   /* Minutes.     [0-59] */
+	int tm_hour;                  /* Hours.       [0-23] */
+	int tm_mday;                  /* Day.         [1-31] */
+	int tm_mon;                   /* Month.       [0-11] */
+	int tm_year;                  /* Year - 1900.  */
+	int tm_wday;                  /* Day of week. [0-6] */
+	int tm_yday;                  /* Days in year.[0-365] */
+	int tm_isdst;                 /* DST.         [-1/0/1]*/
+
+	long int tm_gmtoff;           /* we don't care, we count from GMT */
+	const char *tm_zone;          /* we don't care, we count from GMT */
+};
+
+void
+localtime(const u32 time, struct tm *r);
+
+static int
+match(const struct sk_buff *skb,
+      const struct net_device *in,
+      const struct net_device *out,
+      const struct xt_match *match,
+      const void *matchinfo,
+      int offset,
+      unsigned int protoff,
+      int *hotdrop)
+{
+	const struct ipt_time_info *info = matchinfo;   /* match info for rule */
+	struct timeval tv;
+	struct tm currenttime;                          /* time human readable */
+	u_int8_t days_of_week[7] = {64, 32, 16, 8, 4, 2, 1};
+	u_int16_t packet_time;
+
+	/* We might not have a timestamp, get one */
+	if (skb->tstamp.tv64 == 0)
+		__net_timestamp((struct sk_buff *)skb);
+
+	skb_get_timestamp(skb, &tv);
+
+	/* First we make sure we are in the date start-stop boundaries */
+	if ((tv.tv_sec < info->date_start) || (tv.tv_sec > info->date_stop))
+		return 0; /* We are outside the date boundaries */
+
+	/* Transform the timestamp of the packet, in a human readable form */
+	localtime(tv.tv_sec, &currenttime);
+
+	/* check if we match this timestamp, we start by the days... */
+	if ((days_of_week[currenttime.tm_wday] & info->days_match) != days_of_week[currenttime.tm_wday])
+		return 0; /* the day doesn't match */
+
+	/* ... check the time now */
+	packet_time = (currenttime.tm_hour * 60) + currenttime.tm_min;
+	if ((packet_time < info->time_start) || (packet_time > info->time_stop))
+		return 0;
+
+	/* here we match ! */
+	return 1;
+}
+
+static int
+checkentry(const char *tablename,
+           const void *ip,
+	   const struct xt_match *match,
+           void *matchinfo,
+           unsigned int hook_mask)
+{
+	struct ipt_time_info *info = matchinfo;   /* match info for rule */
+
+	/* First, check that we are in the correct hooks */
+	if (hook_mask
+            & ~((1 << NF_IP_PRE_ROUTING) | (1 << NF_IP_LOCAL_IN) | (1 << NF_IP_FORWARD) | (1 << NF_IP_LOCAL_OUT)))
+	{
+		printk("ipt_time: error, only valid for PRE_ROUTING, LOCAL_IN, FORWARD and OUTPUT)\n");
+		return 0;
+	}
+
+	/* Now check the coherence of the data ... */
+	if ((info->time_start > 1439) ||        /* 23*60+59 = 1439*/
+	    (info->time_stop  > 1439))
+	{
+		printk(KERN_WARNING "ipt_time: invalid argument\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static struct ipt_match time_match = {
+	.name = "time",
+	.match = &match,
+	.matchsize = sizeof(struct ipt_time_info),
+	.checkentry = &checkentry,
+	.me = THIS_MODULE
+};
+
+static int __init init(void)
+{
+	printk("ipt_time loading\n");
+	return xt_register_match(&time_match);
+}
+
+static void __exit fini(void)
+{
+	xt_unregister_match(&time_match);
+	printk("ipt_time unloaded\n");
+}
+
+module_init(init);
+module_exit(fini);
+
+
+/* The part below is borowed and modified from dietlibc */
+
+/* seconds per day */
+#define SPD 24*60*60
+
+void
+localtime(const u32 time, struct tm *r) {
+	u32 i, timep;
+	extern struct timezone sys_tz;
+	const unsigned int __spm[12] =
+		{ 0,
+		  (31),
+		  (31+28),
+		  (31+28+31),
+		  (31+28+31+30),
+		  (31+28+31+30+31),
+		  (31+28+31+30+31+30),
+		  (31+28+31+30+31+30+31),
+		  (31+28+31+30+31+30+31+31),
+		  (31+28+31+30+31+30+31+31+30),
+		  (31+28+31+30+31+30+31+31+30+31),
+		  (31+28+31+30+31+30+31+31+30+31+30),
+		};
+	register u32 work;
+
+	timep = time - (sys_tz.tz_minuteswest * 60);
+	work=timep%(SPD);
+	r->tm_sec=work%60; work/=60;
+	r->tm_min=work%60; r->tm_hour=work/60;
+	work=timep/(SPD);
+	r->tm_wday=(4+work)%7;
+	for (i=1970; ; ++i) {
+		register time_t k= (!(i%4) && ((i%100) || !(i%400)))?366:365;
+		if (work>k)
+			work-=k;
+		else
+			break;
+	}
+	r->tm_year=i-1900;
+	for (i=11; i && __spm[i]>work; --i) ;
+	r->tm_mon=i;
+	r->tm_mday=work-__spm[i]+1;
+}
diff -urBwNp linux-2.6.22/net/ipv4/netfilter/Kconfig linux-2.6/net/ipv4/netfilter/Kconfig
--- linux-2.6.22/net/ipv4/netfilter/Kconfig	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/net/ipv4/netfilter/Kconfig	2009-04-13 16:46:54.000000000 +0400
@@ -72,6 +72,21 @@ config IP_NF_MATCH_TOS
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_MATCH_TIME
+        tristate  'TIME match support'
+        depends on IP_NF_IPTABLES
+        help
+          This option adds a `time' match, which allows you
+          to match based on the packet arrival time/date
+          (arrival time/date at the machine which netfilter is running on) or
+          departure time/date (for locally generated packets).
+
+          If you say Y here, try iptables -m time --help for more information.
+          If you want to compile it as a module, say M here and read
+
+          Documentation/modules.txt.  If unsure, say `N'.
+
+
 config IP_NF_MATCH_RECENT
 	tristate "recent match support"
 	depends on IP_NF_IPTABLES
@@ -295,6 +310,11 @@ config NF_NAT_H323
 	depends on IP_NF_IPTABLES && NF_CONNTRACK && NF_NAT
 	default NF_NAT && NF_CONNTRACK_H323
 
+config NF_NAT_AUTOFW
+	tristate
+	depends on IP_NF_IPTABLES && NF_CONNTRACK && NF_NAT
+	default NF_NAT
+
 config NF_NAT_SIP
 	tristate
 	depends on IP_NF_IPTABLES && NF_CONNTRACK && NF_NAT
diff -urBwNp linux-2.6.22/net/ipv4/netfilter/Makefile linux-2.6/net/ipv4/netfilter/Makefile
--- linux-2.6.22/net/ipv4/netfilter/Makefile	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/net/ipv4/netfilter/Makefile	2009-04-13 16:47:19.000000000 +0400
@@ -27,6 +27,7 @@ obj-$(CONFIG_NF_NAT_PPTP) += nf_nat_pptp
 obj-$(CONFIG_NF_NAT_SIP) += nf_nat_sip.o
 obj-$(CONFIG_NF_NAT_SNMP_BASIC) += nf_nat_snmp_basic.o
 obj-$(CONFIG_NF_NAT_TFTP) += nf_nat_tftp.o
+obj-$(CONFIG_NF_NAT_AUTOFW) += nf_nat_autofw.o
 
 # NAT protocols (nf_nat)
 obj-$(CONFIG_NF_NAT_PROTO_GRE) += nf_nat_proto_gre.o
@@ -44,6 +45,7 @@ obj-$(CONFIG_IP_NF_RAW) += iptable_raw.o
 obj-$(CONFIG_IP_NF_MATCH_IPRANGE) += ipt_iprange.o
 obj-$(CONFIG_IP_NF_MATCH_OWNER) += ipt_owner.o
 obj-$(CONFIG_IP_NF_MATCH_TOS) += ipt_tos.o
+obj-$(CONFIG_IP_NF_MATCH_TIME) += ipt_time.o
 obj-$(CONFIG_IP_NF_MATCH_RECENT) += ipt_recent.o
 obj-$(CONFIG_IP_NF_MATCH_ECN) += ipt_ecn.o
 obj-$(CONFIG_IP_NF_MATCH_AH) += ipt_ah.o
diff -urBwNp linux-2.6.22/net/ipv4/netfilter/nf_nat_autofw.c linux-2.6/net/ipv4/netfilter/nf_nat_autofw.c
--- linux-2.6.22/net/ipv4/netfilter/nf_nat_autofw.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/net/ipv4/netfilter/nf_nat_autofw.c	2008-12-12 06:35:04.000000000 +0300
@@ -0,0 +1,260 @@
+/*
+ * Automatic port forwarding target. When this target is entered, a
+ * related connection to a port in the reply direction will be
+ * expected. This connection may be mapped to a different port.
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: nf_nat_autofw.c,v 1.1 2008/10/02 03:40:29 Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/timer.h>
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <net/protocol.h>
+#include <net/checksum.h>
+#include <net/tcp.h>
+
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <net/netfilter/nf_nat_rule.h>
+#include <linux/netfilter/x_tables.h>
+
+#include <net/netfilter/nf_conntrack_expect.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <linux/netfilter_ipv4/ip_autofw.h>
+
+DEFINE_RWLOCK(nf_nat_autofw_lock);
+
+#define DEBUGP(format, args...)
+
+static int
+autofw_help(struct sk_buff **pskb,
+	unsigned int protoff,
+	struct nf_conn *ct,
+	enum ip_conntrack_info ctinfo)
+{
+	return 1;
+}
+
+static void
+autofw_expect(struct nf_conn *ct, struct nf_conntrack_expect *exp)
+{
+	struct nf_nat_range pre_range;
+	u_int32_t newdstip, newsrcip;
+	u_int16_t port;
+	int ret;
+	struct nf_conn_help *help;
+	struct nf_conn *exp_ct = exp->master;
+	struct nf_conntrack_expect *newexp;
+	int count;
+
+	/* expect has been removed from expect list, but expect isn't free yet. */
+	help = nfct_help(exp_ct);
+	DEBUGP("autofw_nat_expected: got ");
+	NF_CT_DUMP_TUPLE(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
+
+	spin_lock_bh(&nf_nat_autofw_lock);
+
+	port = ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.all);
+	newdstip = exp->tuple.dst.u3.ip;
+	newsrcip = exp->tuple.src.u3.ip;
+	if (port < ntohs(help->help.ct_autofw_info.dport[0]) ||
+		port > ntohs(help->help.ct_autofw_info.dport[1])) {
+		spin_unlock_bh(&nf_nat_autofw_lock);
+			return;
+	}
+
+	/* Only need to do PRE_ROUTING */
+	port -= ntohs(help->help.ct_autofw_info.dport[0]);
+	port += ntohs(help->help.ct_autofw_info.to[0]);
+	pre_range.flags = IP_NAT_RANGE_MAP_IPS | IP_NAT_RANGE_PROTO_SPECIFIED;
+	pre_range.min_ip = pre_range.max_ip = newdstip;
+	pre_range.min.all = pre_range.max.all = htons(port);
+	nf_nat_setup_info(ct, &pre_range, NF_IP_PRE_ROUTING);
+
+	spin_unlock_bh(&nf_nat_autofw_lock);
+
+	/* Add expect again */
+
+	/* alloc will set exp->master = exp_ct */
+	newexp = nf_conntrack_expect_alloc(exp_ct);
+	if (!newexp)
+		return;
+
+	newexp->tuple.src.u3.ip = exp->tuple.src.u3.ip;
+	newexp->tuple.dst.protonum = exp->tuple.dst.protonum;
+	newexp->mask.src.u3.ip = 0xFFFFFFFF;
+	newexp->mask.dst.protonum = 0xFF;
+
+	newexp->tuple.dst.u3.ip = exp->tuple.dst.u3.ip;
+	newexp->mask.dst.u3.ip = 0x0;
+
+	for (count = 1; count < NF_CT_TUPLE_L3SIZE; count++) {
+		newexp->tuple.src.u3.all[count] = 0x0;
+		newexp->tuple.dst.u3.all[count] = 0x0;
+	}
+
+	newexp->mask.dst.u.all = 0x0;
+	newexp->mask.src.u.all = 0x0;
+	newexp->mask.src.l3num = 0x0;
+
+	newexp->expectfn = autofw_expect;
+	newexp->helper = NULL;
+	newexp->flags = 0;
+
+	/*
+	 * exp->timeout.expires will set as
+	 * (jiffies + helper->timeout * HZ), when insert exp.
+	*/
+	ret = nf_conntrack_expect_related(newexp);
+	if (ret == 0)
+		nf_conntrack_expect_put(newexp);
+}
+
+
+static struct nf_conntrack_helper autofw_helper;
+
+static unsigned int
+autofw_target(struct sk_buff **pskb,
+	const struct net_device *in,
+	const struct net_device *out,
+	unsigned int hooknum,
+	const struct xt_target *target,
+	const void *targinfo)
+{
+	const struct ip_autofw_info *info = targinfo;
+	const struct iphdr *iph = ip_hdr(*pskb);
+	int ret;
+	struct nf_conntrack_helper *helper;
+	struct nf_conntrack_expect *exp;
+	struct nf_conn *ct;
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn_help *help;
+	int count;
+
+	ct = nf_ct_get(*pskb, &ctinfo);
+	if (!ct)
+		goto out;
+
+	helper = __nf_conntrack_helper_find_byname("autofw");
+	if (!helper)
+		goto out;
+
+	help = nfct_help(ct);
+	help->helper = helper;
+
+	/* alloc will set exp->master = ct */
+	exp = nf_conntrack_expect_alloc(ct);
+	if (!exp)
+		goto out;
+
+	helper->me = THIS_MODULE;
+	helper->timeout = 5 * 60;
+
+	exp->tuple.src.u3.ip = iph->daddr;
+	exp->tuple.dst.protonum = info->proto;
+	exp->mask.src.u3.ip = 0xFFFFFFFF;
+	exp->mask.dst.protonum = 0xFF;
+
+	exp->tuple.dst.u3.ip = iph->saddr;
+	exp->mask.dst.u3.ip = 0x0;
+
+	for (count = 1; count < NF_CT_TUPLE_L3SIZE; count++) {
+		exp->tuple.src.u3.all[count] = 0x0;
+		exp->tuple.dst.u3.all[count] = 0x0;
+	}
+
+	exp->mask.dst.u.all = 0x0;
+	exp->mask.src.u.all = 0x0;
+	exp->mask.src.l3num = 0x0;
+
+	exp->expectfn = autofw_expect;
+	exp->helper = NULL;
+	exp->flags = 0;
+
+	/*
+	 * exp->timeout.expires will set as
+	 * (jiffies + helper->timeout * HZ), when insert exp.
+	*/
+	ret = nf_conntrack_expect_related(exp);
+	if (ret != 0)
+		goto out;
+
+	nf_conntrack_expect_put(exp);
+
+	help->help.ct_autofw_info.dport[0] = info->dport[0];
+	help->help.ct_autofw_info.dport[1] = info->dport[1];
+	help->help.ct_autofw_info.to[0] = info->to[0];
+	help->help.ct_autofw_info.to[1] = info->to[1];
+
+out:
+	return IPT_CONTINUE;
+}
+
+static int
+autofw_check(const char *tablename,
+	const void *e,
+	const struct xt_target *target,
+	void *targinfo,
+	unsigned int hook_mask)
+{
+
+	const struct ip_autofw_info *info = targinfo;
+
+	if (info->proto != IPPROTO_TCP && info->proto != IPPROTO_UDP) {
+		DEBUGP("autofw_check: bad proto %d.\n", info->proto);
+		return 0;
+	}
+
+	return 1;
+}
+
+static struct xt_target autofw = {
+	.name		= "autofw",
+	.family		= AF_INET,
+	.target		= autofw_target,
+	.targetsize	= sizeof(struct ip_autofw_info),
+	.table		= "nat",
+	.hooks		= 1 << NF_IP_PRE_ROUTING,
+	.checkentry	= autofw_check,
+	.me		= THIS_MODULE
+};
+
+static int __init ip_autofw_init(void)
+{
+	int ret;
+
+	autofw_helper.name = "autofw";
+	autofw_helper.tuple.dst.u3.ip = 0xFFFFFFFF;
+	autofw_helper.tuple.dst.protonum = 0xFF;
+	autofw_helper.mask.dst.u3.ip = 0xFFFFFFFF;
+	autofw_helper.mask.dst.protonum = 0xFF;
+	autofw_helper.tuple.src.u3.ip = 0xFFFFFFFF;
+	autofw_helper.me = THIS_MODULE;
+	autofw_helper.timeout = 5 * 60;
+	autofw_helper.help = autofw_help;
+
+	ret = nf_conntrack_helper_register(&autofw_helper);
+	if (ret)
+		nf_conntrack_helper_unregister(&autofw_helper);
+
+	return xt_register_target(&autofw);
+}
+
+static void __exit ip_autofw_fini(void)
+{
+	xt_unregister_target(&autofw);
+}
+
+module_init(ip_autofw_init);
+module_exit(ip_autofw_fini);
diff -urBwNp linux-2.6.22/net/netfilter/Kconfig linux-2.6/net/netfilter/Kconfig
--- linux-2.6.22/net/netfilter/Kconfig	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/net/netfilter/Kconfig	2009-05-26 13:51:21.000000000 +0400
@@ -612,6 +612,14 @@ config NETFILTER_XT_MATCH_STATISTIC
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_TIME
+        tristate '"time" match support'
+        depends on NETFILTER_XTABLES
+        help
+          time match support.
+
+          To compile it as a module, choose M here.  If unsure, say N.
+
 config NETFILTER_XT_MATCH_STRING
 	tristate  '"string" match support'
 	depends on NETFILTER_XTABLES
@@ -625,6 +633,16 @@ config NETFILTER_XT_MATCH_STRING
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_WEBSTR
+        tristate  '"webstr" match support'
+        depends on NETFILTER_XTABLES
+        help
+          This option adds a `webstr' match, which allows you to look for
+          pattern matchings in http stream.
+
+          To compile it as a module, choose M here.  If unsure, say N.
+
+
 config NETFILTER_XT_MATCH_TCPMSS
 	tristate '"tcpmss" match support'
 	depends on NETFILTER_XTABLES
diff -urBwNp linux-2.6.22/net/netfilter/Makefile linux-2.6/net/netfilter/Makefile
--- linux-2.6.22/net/netfilter/Makefile	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/net/netfilter/Makefile	2009-05-26 13:51:12.000000000 +0400
@@ -70,6 +70,8 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_SCTP) +=
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATE) += xt_state.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATISTIC) += xt_statistic.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STRING) += xt_string.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_WEBSTR) += xt_webstr.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_TIME) += xt_time.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_PHYSDEV) += xt_physdev.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_HASHLIMIT) += xt_hashlimit.o
diff -urBwNp linux-2.6.22/net/netfilter/nf_conntrack_core.c linux-2.6/net/netfilter/nf_conntrack_core.c
--- linux-2.6.22/net/netfilter/nf_conntrack_core.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/net/netfilter/nf_conntrack_core.c	2009-03-30 07:02:15.000000000 +0400
@@ -29,6 +29,7 @@
 #include <linux/netdevice.h>
 #include <linux/socket.h>
 #include <linux/mm.h>
+#include <linux/ip.h>
 
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_l3proto.h>
@@ -106,6 +103,17 @@ static DEFINE_MUTEX(nf_ct_cache_mutex);
 static int nf_conntrack_hash_rnd_initted;
 static unsigned int nf_conntrack_hash_rnd;
 
+//--SZ angela 09.03 {
+#define IP_TRACK_SMALL		0x01
+#define IP_TRACK_PORT		0x02
+#define IP_TRACK_DATA		0x04
+#define	IP_TRACK_UDP		0x08
+
+extern int track_flag;
+extern ulong ipaddr;
+u_int8_t port_num_udp[65536];
+//--SZ angela 09.03 }
+
 static u_int32_t __hash_conntrack(const struct nf_conntrack_tuple *tuple,
 				  unsigned int size, unsigned int rnd)
 {
@@ -696,6 +702,21 @@ init_conntrack(const struct nf_conntrack
 	}
 
 	write_lock_bh(&nf_conntrack_lock);
+	//--SZ angela 09.03 {
+	/* if the qos enable and the layer 3 protocol is ipv4 */
+	if((track_flag == 1) && (strcmp(l3proto->name, "ipv4") == 0)) {
+		conntrack->tuplehash[IP_CT_DIR_ORIGINAL].track.flag = 0;
+		conntrack->tuplehash[IP_CT_DIR_ORIGINAL].track.number =1;
+
+		if(strcmp(l4proto->name, "udp") == 0) {		
+			if(conntrack->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip == ipaddr)
+			 	port_num_udp[conntrack->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.all]++;
+			else
+				port_num_udp[conntrack->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all]++;
+		}	
+	}
+	//--SZ angela 09.03 }
+	
 	exp = find_expectation(tuple);
 
 	help = nfct_help(conntrack);
@@ -738,6 +759,100 @@ init_conntrack(const struct nf_conntrack
 	return &conntrack->tuplehash[IP_CT_DIR_ORIGINAL];
 }
 
+//--SZ angela 09.03 {
+//On success, returns h->track.flags & IP_TRACK_MARK 
+inline int deal_track(struct nf_conntrack_tuple_hash *h, int len)
+{
+	struct nf_conntrack_tuple_hash *rep_h;
+	unsigned int port=0, dport=0;
+	struct nf_conn *ct = NULL;
+
+	// Add the packet number of this connect track and record the length of the packet 
+	h->track.number ++;
+//	if((h->track.flag & IP_TRACK_FULL) != IP_TRACK_FULL)
+//	{
+		if(len > 512)
+			h->track.large_packet++;
+//	}
+	
+	// The download packet set the IP_TRACK_DOWN flag 
+	if(ntohl(h->tuple.dst.u3.ip) == ipaddr)
+	{	
+	       port = h->tuple.dst.u.all;
+	       dport = h->tuple.src.u.all;
+	}
+	else
+	{
+		port = h->tuple.src.u.all;
+		dport = h->tuple.dst.u.all;
+	}
+		
+	// if the connect track is data connect ,we return IP_TRACK_DATA 
+	if((h->track.flag & IP_TRACK_DATA) == IP_TRACK_DATA)	
+		return IP_TRACK_DATA;
+	
+	// if the destination port of this connect track is one of 80,8080,443.We return IP_TRACK_PORT
+	if((h->track.flag & IP_TRACK_PORT) == IP_TRACK_PORT)
+		return IP_TRACK_PORT;
+
+	if((h->track.flag & IP_TRACK_SMALL) == IP_TRACK_SMALL)
+		return IP_TRACK_SMALL;
+
+	if((h->track.flag & IP_TRACK_UDP) == IP_TRACK_UDP)
+		return IP_TRACK_UDP;
+	
+	ct = nf_ct_tuplehash_to_ctrack(h);
+
+	//start compare 
+	if(NF_CT_DIRECTION(h) == IP_CT_DIR_REPLY)
+		rep_h = &ct->tuplehash[IP_CT_DIR_ORIGINAL];
+	else
+		rep_h = &ct->tuplehash[IP_CT_DIR_REPLY];
+	if(!rep_h)
+		return 0;
+
+	if(ntohs(dport) == 80 || ntohs(dport) == 8080 || ntohs(dport) == 443)
+       	{
+  		h->track.flag |= IP_TRACK_PORT;
+		rep_h->track.flag |= IP_TRACK_PORT;
+		return IP_TRACK_PORT;
+	}
+
+	// if the port has connections more than 30, we mark it and return IP_TRACK_UDP
+	// h->tuple.dst.protonum == 17 &&
+	if((port_num_udp[port] > 30 || port_num_udp[dport] >30)) 
+	{
+		h->track.flag |= IP_TRACK_UDP;		
+		rep_h->track.flag |= IP_TRACK_UDP;
+		return IP_TRACK_UDP;
+	}
+
+	if(h->track.number == 250)
+	{
+		if(h->track.large_packet<70)
+		{
+			if((rep_h->track.flag & IP_TRACK_DATA) == IP_TRACK_DATA)
+			{
+				h->track.flag |= IP_TRACK_DATA;
+				return IP_TRACK_DATA;
+			}
+			h->track.flag |= IP_TRACK_SMALL;
+			return IP_TRACK_SMALL;
+		}
+		
+		if((rep_h->track.flag & IP_TRACK_SMALL) == IP_TRACK_SMALL)
+		{
+			rep_h->track.flag |= IP_TRACK_DATA;
+			rep_h->track.flag &= ~IP_TRACK_SMALL;
+		}
+		h->track.flag |= IP_TRACK_DATA;
+		return IP_TRACK_DATA;
+	}
+	
+	return 0;
+}	
+//--SZ angela 09.03 }
+
 /* On success, returns conntrack ptr, sets skb->nfct and ctinfo */
 static inline struct nf_conn *
 resolve_normal_ct(struct sk_buff *skb,
@@ -768,7 +883,45 @@ resolve_normal_ct(struct sk_buff *skb,
 			return NULL;
 		if (IS_ERR(h))
 			return (void *)h;
+	}//--SZ angela 09.03 {
+	else if((track_flag == 1) && (strcmp(l3proto->name, "ipv4") == 0)) { 
+		write_lock_bh(&nf_conntrack_lock);
+	      
+		switch(deal_track(h, ntohs(ip_hdr(skb)->tot_len))) {
+			case IP_TRACK_UDP:
+				if(ntohl(h->tuple.dst.u3.ip) == ipaddr)
+					skb->mark = 91;
+				else 
+					skb->mark = 51;
+				break;
+			case IP_TRACK_DATA:
+				if(ntohl(h->tuple.dst.u3.ip) == ipaddr)
+					skb->mark = 90;
+				else 
+					skb->mark = 50;
+				break;
+			case IP_TRACK_PORT:
+				if(ntohl(h->tuple.dst.u3.ip) == ipaddr)
+					skb->mark = 80;
+				else
+					skb->mark = 20;
+				break;
+			case IP_TRACK_SMALL:
+				if(ntohl(h->tuple.dst.u3.ip) == ipaddr)
+					skb->mark = 70;
+				else
+					skb->mark = 10;
+				break;
+			default:
+				if(ntohl(h->tuple.dst.u3.ip) == ipaddr)
+					skb->mark = 90;
+				else
+					skb->mark = 50;
+				break;
 	}
+		write_unlock_bh(&nf_conntrack_lock);			
+	} //--SZ angela 09.03 }
+
 	ct = nf_ct_tuplehash_to_ctrack(h);
 
 	/* It exists; we have (non-exclusive) reference. */
@@ -1238,6 +1391,9 @@ int __init nf_conntrack_init(void)
 	}
 	nf_conntrack_max = 8 * nf_conntrack_htable_size;
 
+	for(ret=0; ret<65535; ret++)		//--SZ Angela 09.03 QOS Initialization
+		port_num_udp[ret]=0;
+
 	printk("nf_conntrack version %s (%u buckets, %d max)\n",
 	       NF_CONNTRACK_VERSION, nf_conntrack_htable_size,
 	       nf_conntrack_max);
diff -urBwNp linux-2.6.22/net/netfilter/nf_conntrack_proto_tcp.c linux-2.6/net/netfilter/nf_conntrack_proto_tcp.c
--- linux-2.6.22/net/netfilter/nf_conntrack_proto_tcp.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/net/netfilter/nf_conntrack_proto_tcp.c	2009-04-20 06:42:13.000000000 +0400
@@ -30,6 +30,8 @@
 #define DEBUGP printk
 #define DEBUGP_VARS
 #else
+extern int clean_flag; // 2009.04 James. wanduck.
+
 #define DEBUGP(format, args...)
 #endif
 
@@ -315,6 +310,11 @@ static int tcp_print_conntrack(struct se
 {
 	enum tcp_conntrack state;
 
+// 2009.04 James. wanduck. {
+	if(clean_flag == 101)
+		nf_ct_refresh(conntrack, NULL, 0);
+// 2009.04 James. wanduck. }
+
 	read_lock_bh(&tcp_lock);
 	state = conntrack->proto.tcp.state;
 	read_unlock_bh(&tcp_lock);
diff -urBwNp linux-2.6.22/net/netfilter/nf_conntrack_proto_udp.c linux-2.6/net/netfilter/nf_conntrack_proto_udp.c
--- linux-2.6.22/net/netfilter/nf_conntrack_proto_udp.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/net/netfilter/nf_conntrack_proto_udp.c	2009-04-20 06:42:56.000000000 +0400
@@ -23,6 +23,8 @@
 #include <net/netfilter/nf_conntrack_l4proto.h>
 #include <net/netfilter/nf_conntrack_ecache.h>
 
+extern int clean_flag; // 2009.04 James. wanduck.
+
 static unsigned int nf_ct_udp_timeout __read_mostly = 30*HZ;
 static unsigned int nf_ct_udp_timeout_stream __read_mostly = 180*HZ;
 
@@ -64,6 +66,11 @@ static int udp_print_tuple(struct seq_fi
 static int udp_print_conntrack(struct seq_file *s,
 			       const struct nf_conn *conntrack)
 {
+// 2009.04 James. wanduck. {
+	if(clean_flag == 101)
+		nf_ct_refresh(conntrack, NULL, 0);
+// 2009.04 James. wanduck. }
+
 	return 0;
 }
 
diff -urBwNp linux-2.6.22/net/netfilter/nf_conntrack_standalone.c linux-2.6/net/netfilter/nf_conntrack_standalone.c
--- linux-2.6.22/net/netfilter/nf_conntrack_standalone.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/net/netfilter/nf_conntrack_standalone.c	2009-03-30 07:03:32.000000000 +0400
@@ -190,6 +186,125 @@ static int ct_seq_show(struct seq_file *
 	return 0;
 }
 
+//--SZ Angela 09.03 for QOS {
+/* return 0 on success, 1 in case of error */
+static int ct_seq_show_track(struct seq_file *s, void *v)
+{
+	const struct nf_conntrack_tuple_hash *hash = v;
+	const struct nf_conn *conntrack = nf_ct_tuplehash_to_ctrack(hash);
+	struct nf_conntrack_l3proto *l3proto;
+	struct nf_conntrack_l4proto *l4proto;
+
+	NF_CT_ASSERT(conntrack);
+
+	/* we only want to print DIR_ORIGINAL */
+	if (NF_CT_DIRECTION(hash))
+		return 0;
+
+	l3proto = __nf_ct_l3proto_find(conntrack->tuplehash[IP_CT_DIR_ORIGINAL]
+				       .tuple.src.l3num);
+
+	NF_CT_ASSERT(l3proto);
+	l4proto = __nf_ct_l4proto_find(conntrack->tuplehash[IP_CT_DIR_ORIGINAL]
+				   .tuple.src.l3num,
+				   conntrack->tuplehash[IP_CT_DIR_ORIGINAL]
+				   .tuple.dst.protonum);
+	NF_CT_ASSERT(l4proto);
+
+	if (seq_printf(s, "%-8s %u %-8s %u %ld ",
+		       l3proto->name,
+		       conntrack->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.l3num,
+		       l4proto->name,
+		       conntrack->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum,
+		       timer_pending(&conntrack->timeout)
+		       ? (long)(conntrack->timeout.expires - jiffies)/HZ : 0) != 0)
+		return -ENOSPC;
+
+	if (l3proto->print_conntrack(s, conntrack))
+		return -ENOSPC;
+
+	if (l4proto->print_conntrack(s, conntrack))
+		return -ENOSPC;
+
+	if (print_tuple(s, &conntrack->tuplehash[IP_CT_DIR_ORIGINAL].tuple,
+			l3proto, l4proto))
+		return -ENOSPC;
+
+	if (seq_print_counters(s, &conntrack->counters[IP_CT_DIR_ORIGINAL]))
+		return -ENOSPC;
+
+	if(seq_printf(s, " flag=%d number=%d large_packet=%d \n\t\t",
+			conntrack->tuplehash[IP_CT_DIR_ORIGINAL].track.flag,
+			conntrack->tuplehash[IP_CT_DIR_ORIGINAL].track.number,
+			conntrack->tuplehash[IP_CT_DIR_ORIGINAL].track.large_packet))
+		return -ENOSPC;
+
+	if (print_tuple(s, &conntrack->tuplehash[IP_CT_DIR_REPLY].tuple,
+			l3proto, l4proto))
+		return -ENOSPC;
+
+	if (seq_print_counters(s, &conntrack->counters[IP_CT_DIR_REPLY]))
+		return -ENOSPC;
+
+	if(seq_printf(s, " flag=%d number=%d large_packet=%d ",
+			conntrack->tuplehash[IP_CT_DIR_REPLY].track.flag,
+			conntrack->tuplehash[IP_CT_DIR_REPLY].track.number,
+			conntrack->tuplehash[IP_CT_DIR_REPLY].track.large_packet))
+		return -ENOSPC;
+
+#if defined(CONFIG_NF_CONNTRACK_MARK)
+	if (seq_printf(s, "mark=%u ", conntrack->mark))
+		return -ENOSPC;
+#endif
+
+#ifdef CONFIG_NF_CONNTRACK_SECMARK
+	if (seq_printf(s, "secmark=%u ", conntrack->secmark))
+		return -ENOSPC;
+#endif
+
+	if (seq_printf(s, "use=%u\n", atomic_read(&conntrack->ct_general.use)))
+		return -ENOSPC;
+	
+	return 0;
+}
+
+static struct seq_operations ct_seq_ops_track = {
+	.start = ct_seq_start,
+	.next  = ct_seq_next,
+	.stop  = ct_seq_stop,
+	.show  = ct_seq_show_track
+};
+
+static int ct_open_track(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq;
+	struct ct_iter_state *st;
+	int ret;
+
+	st = kmalloc(sizeof(struct ct_iter_state), GFP_KERNEL);
+	if (st == NULL)
+		return -ENOMEM;
+	ret = seq_open(file, &ct_seq_ops_track);
+	if (ret)
+		goto out_free;
+	seq          = file->private_data;
+	seq->private = st;
+	memset(st, 0, sizeof(struct ct_iter_state));
+	return ret;
+out_free:
+	kfree(st);
+	return ret;
+}
+
+static const struct file_operations ct_file_ops_track = {
+	.owner   = THIS_MODULE,
+	.open    = ct_open_track,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release_private,
+};
+//--SZ Angela 09.03 }
+
 static struct seq_operations ct_seq_ops = {
 	.start = ct_seq_start,
 	.next  = ct_seq_next,
@@ -410,7 +525,7 @@ EXPORT_SYMBOL_GPL(nf_ct_log_invalid);
 static int __init nf_conntrack_standalone_init(void)
 {
 #ifdef CONFIG_PROC_FS
-	struct proc_dir_entry *proc, *proc_exp, *proc_stat;
+	struct proc_dir_entry *proc, *proc_track, *proc_exp, *proc_stat;
 #endif
 	int ret = 0;
 
@@ -422,6 +537,9 @@ static int __init nf_conntrack_standalon
 	proc = proc_net_fops_create("nf_conntrack", 0440, &ct_file_ops);
 	if (!proc) goto cleanup_init;
 
+	proc_track = proc_net_fops_create("ip_track", 0440, &ct_file_ops_track);	//--SZ Angela 09.03 QOS
+	if (!proc_track) goto cleanup_init_track;
+
 	proc_exp = proc_net_fops_create("nf_conntrack_expect", 0440,
 					&exp_file_ops);
 	if (!proc_exp) goto cleanup_proc;
@@ -452,6 +570,8 @@ static int __init nf_conntrack_standalon
 	proc_net_remove("nf_conntrack_expect");
  cleanup_proc:
 	proc_net_remove("nf_conntrack");
+cleanup_init_track:			//--SZ Angela 09.03 QOS
+	proc_net_remove("ip_track");
  cleanup_init:
 #endif /* CNFIG_PROC_FS */
 	nf_conntrack_cleanup();
diff -urBwNp linux-2.6.22/net/netfilter/xt_time.c linux-2.6/net/netfilter/xt_time.c
--- linux-2.6.22/net/netfilter/xt_time.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/net/netfilter/xt_time.c	2009-06-08 17:55:51.000000000 +0400
@@ -0,0 +1,233 @@
+/*
+  This is a module which is used for time matching
+  It is using some modified code from dietlibc (localtime() function)
+  that you can find at http://www.fefe.de/dietlibc/
+  This file is distributed under the terms of the GNU General Public
+  License (GPL). Copies of the GPL can be obtained from: ftp://prep.ai.mit.edu/pub/gnu/GPL
+  2001-05-04 Fabrice MARIE <fabrice@netfilter.org> : initial development.
+  2001-21-05 Fabrice MARIE <fabrice@netfilter.org> : bug fix in the match code,
+     thanks to "Zeng Yu" <zengy@capitel.com.cn> for bug report.
+  2001-26-09 Fabrice MARIE <fabrice@netfilter.org> : force the match to be in LOCAL_IN or PRE_ROUTING only.
+  2001-30-11 Fabrice : added the possibility to use the match in FORWARD/OUTPUT with a little hack,
+     added Nguyen Dang Phuoc Dong <dongnd@tlnet.com.vn> patch to support timezones.
+*/
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_time.h>
+#include <linux/time.h>
+
+MODULE_AUTHOR("Fabrice MARIE <fabrice@netfilter.org>");
+MODULE_DESCRIPTION("Match arrival timestamp");
+MODULE_LICENSE("GPL");
+
+struct tm
+{
+	int tm_sec;                   /* Seconds.     [0-60] (1 leap second) */
+	int tm_min;                   /* Minutes.     [0-59] */
+	int tm_hour;                  /* Hours.       [0-23] */
+	int tm_mday;                  /* Day.         [1-31] */
+	int tm_mon;                   /* Month.       [0-11] */
+	int tm_year;                  /* Year - 1900.  */
+	int tm_wday;                  /* Day of week. [0-6] */
+	int tm_yday;                  /* Days in year.[0-365] */
+	int tm_isdst;                 /* DST.         [-1/0/1]*/
+
+	long int tm_gmtoff;           /* we don't care, we count from GMT */
+	const char *tm_zone;          /* we don't care, we count from GMT */
+};
+
+void
+localtime(const time_t *timepr, struct tm *r);
+
+static int
+/*
+match(const struct sk_buff *skb,
+      const struct net_device *in,
+      const struct net_device *out,
+      const void *matchinfo,
+      int offset,
+      const void *hdr,
+      u_int16_t datalen,
+      int *hotdrop)
+*/
+ipt_time_match(const struct sk_buff *skb,
+                 const struct net_device *in, const struct net_device *out,
+                 const struct xt_match *match, const void *matchinfo,
+                 int offset, unsigned int protoff, int *hotdrop)
+{
+	const struct ipt_time_info *info = matchinfo;   /* match info for rule */
+	struct tm currenttime;                          /* time human readable */
+	unsigned int packet_time;
+	struct timeval kerneltimeval;
+	time_t packet_local_time;
+
+
+	/* if kerneltime=1, we don't read the skb->timestamp but kernel time instead */
+	if (info->kerneltime)
+	{
+		do_gettimeofday(&kerneltimeval);
+		packet_local_time = kerneltimeval.tv_sec;
+	}
+	else {
+		packet_local_time = skb->tstamp.tv64;
+		//packet_local_time = skb->tstamp.off_sec;
+	}
+
+	/* Transform the timestamp of the packet, in a human readable form */
+	localtime(&packet_local_time, &currenttime);
+
+	//printk("dbg: Date = yy/mm/dd = %d/%d/%d, week=%d\n", currenttime.tm_year, currenttime.tm_mon, currenttime.tm_mday, currenttime.tm_wday);
+	/* check if we match this timestamp, we start by the days... */
+	if (!((1 << currenttime.tm_wday) & info->days_match)) {
+		//printk("dbg: the day doesn't match: currect.tm_wday = 0x%x, info->days_match = 0x%x\n", currenttime.tm_wday, info->days_match);
+		return 0; /* the day doesn't match */
+	}
+
+	/* ... check the time now */
+//	packet_time = (currenttime.tm_hour * 60 * 60) + (currenttime.tm_min * 60) + currenttime.tm_sec;
+	packet_time = (currenttime.tm_hour * 60) + currenttime.tm_min;
+
+	if (info->time_start < info->time_stop) {
+		if ((packet_time < info->time_start) || (packet_time > info->time_stop)) {
+			return 0;
+		}
+	} else {
+		if ((packet_time < info->time_start) && (packet_time > info->time_stop)) {
+			return 0;
+		}
+	}
+
+	/* here we match ! */
+	return 1;
+}
+
+static int
+/*
+checkentry(const char *tablename,
+           const struct ipt_ip *ip,
+           void *matchinfo,
+           unsigned int matchsize,
+           unsigned int hook_mask)
+*/
+ipt_time_checkentry(const char *tablename, const void *ip,
+                      const struct xt_match *match, void *matchinfo,
+                      unsigned int hook_mask)
+{
+	struct ipt_time_info *info = matchinfo;   /* match info for rule */
+
+	/* First, check that we are in the correct hook */
+	/* PRE_ROUTING, LOCAL_IN or FROWARD */
+	if (hook_mask
+            & ~((1 << NF_IP_PRE_ROUTING) | (1 << NF_IP_LOCAL_IN) | (1 << NF_IP_FORWARD) | (1 << NF_IP_LOCAL_OUT)))
+	{
+		printk("ipt_time: error, only valid for PRE_ROUTING, LOCAL_IN, FORWARD and OUTPUT)\n");
+		return 0;
+	}
+
+	/* always use kerneltime */
+	info->kerneltime = 1;
+
+	/* Check the size */
+	//if (matchsize < IPT_ALIGN(sizeof(struct ipt_time_info)))
+	//	return 0;
+
+	/* Now check the coherence of the data ... */
+	if ((info->time_start > 86399) ||        /* 24*60*60-1 = 86399*/
+	    (info->time_stop  > 86399))
+	{
+		printk(KERN_WARNING "ipt_time: invalid argument\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+static struct ipt_match time_match
+= { { NULL, NULL }, "time", &match, &checkentry, NULL, THIS_MODULE };
+*/
+
+static struct xt_match time_match[] = {
+        {
+        .name           = "time",
+        .family         = AF_INET,
+        .match          = ipt_time_match,
+        .matchsize      = sizeof(struct ipt_time_info),
+        .checkentry     = ipt_time_checkentry,
+        .me             = THIS_MODULE
+        },
+        {
+        .name           = "time",
+        .family         = AF_INET6,
+        .match          = ipt_time_match,
+        .matchsize      = sizeof(struct ipt_time_info),
+        .checkentry     = ipt_time_checkentry,
+        .me             = THIS_MODULE
+        },
+};
+
+static int __init init(void)
+{
+	printk("ipt_time loading\n");
+	//return ipt_register_match(&time_match);
+	return xt_register_matches(time_match, ARRAY_SIZE(time_match));
+}
+
+static void __exit fini(void)
+{
+	//ipt_unregister_match(&time_match);
+	xt_unregister_matches(time_match, ARRAY_SIZE(time_match));
+	printk("ipt_time unloaded\n");
+}
+
+module_init(init);
+module_exit(fini);
+
+
+/* The part below is borowed and modified from dietlibc */
+
+/* seconds per day */
+#define SPD 24*60*60
+
+void
+localtime(const time_t *timepr, struct tm *r) {
+	time_t i;
+	time_t timep;
+	extern struct timezone sys_tz;
+	const unsigned int __spm[12] =
+		{ 0,
+		  (31),
+		  (31+28),
+		  (31+28+31),
+		  (31+28+31+30),
+		  (31+28+31+30+31),
+		  (31+28+31+30+31+30),
+		  (31+28+31+30+31+30+31),
+		  (31+28+31+30+31+30+31+31),
+		  (31+28+31+30+31+30+31+31+30),
+		  (31+28+31+30+31+30+31+31+30+31),
+		  (31+28+31+30+31+30+31+31+30+31+30),
+		};
+	register time_t work;
+
+	timep = (*timepr) - (sys_tz.tz_minuteswest * 60);
+
+	work=timep%(SPD);
+	r->tm_sec=work%60; work/=60;
+	r->tm_min=work%60; r->tm_hour=work/60;
+	work=timep/(SPD);
+	r->tm_wday=(4+work)%7;
+	for (i=1970; ; ++i) {
+		register time_t k= (!(i%4) && ((i%100) || !(i%400)))?366:365;
+		if (work>k)
+			work-=k;
+		else
+			break;
+	}
+	r->tm_year=i-1900;
+	for (i=11; i && __spm[i]>work; --i) ;
+	r->tm_mon=i;
+	r->tm_mday=work-__spm[i]+1;
+}
diff -urBwNp linux-2.6.22/net/netfilter/xt_webstr.c linux-2.6/net/netfilter/xt_webstr.c
--- linux-2.6.22/net/netfilter/xt_webstr.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/net/netfilter/xt_webstr.c	2009-05-26 13:23:54.000000000 +0400
@@ -0,0 +1,484 @@
+/* Kernel module to match a string into a packet.
+ *
+ * Copyright (C) 2000 Emmanuel Roger  <winfield@freegates.be>
+ * 
+ * ChangeLog
+ *	19.02.2002: Gianni Tedesco <gianni@ecsc.co.uk>
+ *		Fixed SMP re-entrancy problem using per-cpu data areas
+ *		for the skip/shift tables.
+ *	02.05.2001: Gianni Tedesco <gianni@ecsc.co.uk>
+ *		Fixed kernel panic, due to overrunning boyer moore string
+ *		tables. Also slightly tweaked heuristic for deciding what
+ * 		search algo to use.
+ * 	27.01.2001: Gianni Tedesco <gianni@ecsc.co.uk>
+ * 		Implemented Boyer Moore Sublinear search algorithm
+ * 		alongside the existing linear search based on memcmp().
+ * 		Also a quick check to decide which method to use on a per
+ * 		packet basis.
+ */
+
+/* Kernel module to match a http header string into a packet.
+ *
+ * Copyright (C) 2003, CyberTAN Corporation
+ * All Rights Reserved.
+ *
+ * Description:
+ *   This is kernel module for web content inspection. It was derived from 
+ *   'string' match module, declared as above.
+ *
+ *   The module follows the Netfilter framework, called extended packet 
+ *   matching modules. 
+ */
+
+/* Linux Kernel 2.6 Port ( 2.4 ipt-> 2.6 xt)
+ * Copyright (C) 2008, Ralink Technology Corporation. 
+ * All Rights Reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <net/sock.h>
+
+#define BM_MAX_NLEN 256
+#define BM_MAX_HLEN 1024
+
+#define BLK_JAVA        0x01
+#define BLK_ACTIVE      0x02
+#define BLK_COOKIE      0x04
+#define BLK_PROXY       0x08
+
+typedef char *(*proc_ipt_search) (char *, char *, int, int);
+
+struct ipt_webstr_info {
+    char string[BM_MAX_NLEN];
+    u_int16_t invert;
+    u_int16_t len;
+    u_int8_t type;
+};
+
+enum xt_webstr_type
+{
+    IPT_WEBSTR_HOST,
+    IPT_WEBSTR_URL,
+    IPT_WEBSTR_CONTENT
+};
+
+
+#define	isdigit(x) ((x) >= '0' && (x) <= '9')
+#define	isupper(x) (((unsigned)(x) >= 'A') && ((unsigned)(x) <= 'Z'))
+#define	islower(x) (((unsigned)(x) >= 'a') && ((unsigned)(x) <= 'z'))
+#define	isalpha(x) (isupper(x) || islower(x))
+#define	toupper(x) (isupper(x) ? (x) : (x) - 'a' + 'A')
+#define tolower(x) (isupper(x) ? ((x) - 'A' + 'a') : (x))
+
+#define split(word, wordlist, next, delim) \
+    for (next = wordlist, \
+	strncpy(word, next, sizeof(word)), \
+	word[(next=strstr(next, delim)) ? strstr(word, delim) - word : sizeof(word) - 1] = '\0', \
+	next = next ? next + sizeof(delim) - 1 : NULL ; \
+	strlen(word); \
+	next = next ? : "", \
+	strncpy(word, next, sizeof(word)), \
+	word[(next=strstr(next, delim)) ? strstr(word, delim) - word : sizeof(word) - 1] = '\0', \
+	next = next ? next + sizeof(delim) - 1 : NULL)
+
+#define BUFSIZE 	1024
+
+/* Flags for get_http_info() */
+#define HTTP_HOST	0x01
+#define HTTP_URL	0x02
+/* Flags for mangle_http_header() */
+#define HTTP_COOKIE	0x04
+
+#if 0
+#define SPARQ_LOG       printk
+#else
+#define SPARQ_LOG(format, args...)
+#endif
+
+typedef struct httpinfo {
+    char host[BUFSIZE + 1];
+    int hostlen;
+    char url[BUFSIZE + 1];
+    int urllen;
+} httpinfo_t;
+
+/* Return 1 for match, 0 for accept, -1 for partial. */
+static int find_pattern2(const char *data, size_t dlen,
+	const char *pattern, size_t plen,
+	char term,
+	unsigned int *numoff,
+	unsigned int *numlen)
+{
+    size_t i, j, k;
+    int state = 0;
+    *numoff = *numlen = 0;
+
+    SPARQ_LOG("%s: pattern = '%s', dlen = %u\n",__FUNCTION__, pattern, dlen);
+    if (dlen == 0)
+	return 0;
+
+    if (dlen <= plen) {	/* Short packet: try for partial? */
+	if (strnicmp(data, pattern, dlen) == 0)
+	    return -1;
+	else 
+	    return 0;
+    }
+    for (i = 0; i <= (dlen - plen); i++) {
+	/* DFA : \r\n\r\n :: 1234 */
+	if (*(data + i) == '\r') {
+	    if (!(state % 2)) state++;	/* forwarding move */
+	    else state = 0;		/* reset */
+	}
+	else if (*(data + i) == '\n') {
+	    if (state % 2) state++;
+	    else state = 0;
+	}
+	else state = 0;
+
+	if (state >= 4)
+	    break;
+
+	/* pattern compare */
+	if (memcmp(data + i, pattern, plen ) != 0)
+	    continue;
+
+	/* Here, it means patten match!! */
+	*numoff=i + plen;
+	for (j = *numoff, k = 0; data[j] != term; j++, k++)
+	    if (j > dlen) return -1 ;	/* no terminal char */
+
+	*numlen = k;
+	return 1;
+    }
+    return 0;
+}
+
+#if 0
+static int mangle_http_header(const struct sk_buff *skb, int flags)
+{
+    struct iphdr *iph = (skb)->nh.iph;
+    struct tcphdr *tcph = (void *)iph + iph->ihl*4;
+    unsigned char *data = (void *)tcph + tcph->doff*4;
+    unsigned int datalen = (skb)->len - (iph->ihl*4) - (tcph->doff*4);
+
+    int found, offset, len;
+    int ret = 0;
+
+
+    SPARQ_LOG("%s: seq=%u\n", __FUNCTION__, ntohl(tcph->seq));
+
+    /* Basic checking, is it HTTP packet? */
+    if (datalen < 10)
+	return ret;	/* Not enough length, ignore it */
+    if (memcmp(data, "GET ", sizeof("GET ") - 1) != 0 &&
+        memcmp(data, "POST ", sizeof("POST ") - 1) != 0 &&
+        memcmp(data, "HEAD ", sizeof("HEAD ") - 1) != 0) //zg add 2006.09.28 for cdrouter3.3 item 186(cdrouter_urlfilter_15)
+	return ret;	/* Pass it */
+
+    /* COOKIE modification */
+    if (flags & HTTP_COOKIE) {
+	found = find_pattern2(data, datalen, "Cookie: ", 
+		sizeof("Cookie: ")-1, '\r', &offset, &len);
+	if (found) {
+	    char c;
+	    offset -= (sizeof("Cookie: ") - 1);
+	    /* Swap the 2rd and 4th bit */
+	    c = *(data + offset + 2) ;
+	    *(data + offset + 2) = *(data + offset + 4) ;
+	    *(data + offset + 4) = c ;
+	    ret++;
+	}
+    }
+
+    return ret;
+}
+#endif
+
+static int get_http_info(const struct sk_buff *skb, int flags, httpinfo_t *info)
+{
+//    struct iphdr *iph = (skb)->nh.iph;
+    struct iphdr *iph = ip_hdr(skb);
+    struct tcphdr *tcph = (void *)iph + iph->ihl*4;
+    unsigned char *data = (void *)tcph + tcph->doff*4;
+//    unsigned int datalen = (skb)->len - (iph->ihl*4) - (tcph->doff*4);
+    unsigned int datalen = ntohs(ip_hdr(skb)->tot_len);
+   
+
+    int found, offset;
+    int hostlen, pathlen;
+    int ret = 0;
+
+
+    SPARQ_LOG("%s: seq=%u\n", __FUNCTION__, ntohl(tcph->seq));
+
+    /* Basic checking, is it HTTP packet? */
+    if (datalen < 10) {
+	SPARQ_LOG("%s: Not enough length, ignore it!\n", __FUNCTION__);
+	return ret;	/* Not enough length, ignore it */
+	}
+    if (memcmp(data, "GET ", sizeof("GET ") - 1) != 0 &&
+        memcmp(data, "POST ", sizeof("POST ") - 1) != 0 &&
+        memcmp(data, "HEAD ", sizeof("HEAD ") - 1) != 0) { //zg add 2006.09.28 for cdrouter3.3 item 186(cdrouter_urlfilter_15)
+	SPARQ_LOG("%s: Pass it\n", __FUNCTION__);
+	return ret;	/* Pass it */
+	}
+
+    if (!(flags & (HTTP_HOST | HTTP_URL))) {
+	SPARQ_LOG("%s: Non-flag\n", __FUNCTION__);
+	return ret;
+	}
+
+    /* find the 'Host: ' value */
+    found = find_pattern2(data, datalen, "Host: ", 
+	    sizeof("Host: ") - 1, '\r', &offset, &hostlen);
+    SPARQ_LOG("Host found=%d\n", found);
+
+    if (!found || !hostlen)
+	return ret;
+
+    ret++;	/* Host found, increase the return value */
+    hostlen = (hostlen < BUFSIZE) ? hostlen : BUFSIZE;
+    strncpy(info->host, data + offset, hostlen);
+    *(info->host + hostlen) = 0;		/* null-terminated */
+    info->hostlen = hostlen;
+    SPARQ_LOG("HOST=%s, hostlen=%d\n", info->host, info->hostlen);
+
+    if (!(flags & HTTP_URL))
+	return ret;
+
+    /* find the 'GET ' or 'POST ' or 'HEAD ' value */
+    found = find_pattern2(data, datalen, "GET ",
+	    sizeof("GET ") - 1, '\r', &offset, &pathlen);
+    if (!found)
+	found = find_pattern2(data, datalen, "POST ",
+		sizeof("POST ") - 1, '\r', &offset, &pathlen);
+    /******* zg add 2006.09.28 for cdrouter3.3 item 186(cdrouter_urlfilter_15) ******/
+    if (!found)
+        found = find_pattern2(data, datalen, "HEAD ",
+                sizeof("HEAD ") - 1, '\r', &offset, &pathlen);
+    /************************* zg end 2006.09.28 ****************************/
+    SPARQ_LOG("GET/POST found=%d\n", found);
+
+    if (!found || (pathlen -= (sizeof(" HTTP/x.x") - 1)) <= 0)/* ignor this field */
+	return ret;
+
+    ret++;	/* GET/POST/HEAD found, increase the return value */
+    pathlen = ((pathlen + hostlen) < BUFSIZE) ? pathlen : BUFSIZE - hostlen;
+    strncpy(info->url, info->host, hostlen);
+    strncpy(info->url + hostlen, data + offset, pathlen);
+    *(info->url + hostlen + pathlen) = 0;	/* null-terminated */
+    info->urllen = hostlen + pathlen;
+    SPARQ_LOG("URL=%s, urllen=%d\n", info->url, info->urllen);
+
+    return ret;
+}
+
+/* Linear string search based on memcmp() */
+static char *search_linear (char *needle, char *haystack, int needle_len, int haystack_len) 
+{
+	char *k = haystack + (haystack_len-needle_len);
+	char *t = haystack;
+	
+	SPARQ_LOG("%s: haystack=%s, needle=%s\n", __FUNCTION__, t, needle);
+	for(; t <= k; t++) {
+		//SPARQ_LOG("%s: haystack=%s, needle=%s\n", __FUNCTION__, t, needle);
+		if (strnicmp(t, needle, needle_len) == 0) return t;
+		//if ( memcmp(t, needle, needle_len) == 0 ) return t;
+	}
+
+	return NULL;
+}
+
+
+static int
+match(const struct sk_buff *skb,
+      const struct net_device *in,
+      const struct net_device *out,
+      const struct xt_match *match,
+      const void *matchinfo,
+      int offset,
+      unsigned int protoff,
+      int *hotdrop)
+{
+	const struct ipt_webstr_info *info = matchinfo;
+//	struct iphdr *ip = skb->nh.iph;
+	struct iphdr *ip = ip_hdr(skb);
+	proc_ipt_search search=search_linear;
+
+	char token[] = "<&nbsp;>";
+	char *wordlist = (char *)&info->string;
+	httpinfo_t htinfo;
+	int flags = 0;
+	int found = 0;
+	long int opt = 0;
+
+
+	if (!ip || info->len < 1) {
+		if (!ip)
+		    SPARQ_LOG("non-IP\n");
+		else
+		    SPARQ_LOG("info->len < 1\n");
+	    return 0;
+	}
+
+	SPARQ_LOG("\n************************************************\n"
+		"%s: type=%s\n", __FUNCTION__, (info->type == IPT_WEBSTR_URL) 
+		? "IPT_WEBSTR_URL"  : (info->type == IPT_WEBSTR_HOST) 
+		? "IPT_WEBSTR_HOST" : "IPT_WEBSTR_CONTENT" );
+	
+	/* Determine the flags value for get_http_info(), and mangle packet 
+	 * if needed. */
+	switch(info->type)
+	{
+	    case IPT_WEBSTR_URL:	/* fall through */
+		flags |= HTTP_URL;
+
+	    case IPT_WEBSTR_HOST:
+		flags |= HTTP_HOST;
+		break;
+
+	    case IPT_WEBSTR_CONTENT:
+		opt = simple_strtol(wordlist, (char **)NULL, 10);
+		SPARQ_LOG("%s: string=%s, opt=%#lx\n", __FUNCTION__, wordlist, opt);
+
+		if (opt & (BLK_JAVA | BLK_ACTIVE | BLK_PROXY))
+		    flags |= HTTP_URL;
+		if (opt & BLK_PROXY)
+		    flags |= HTTP_HOST;
+#if 0
+		// Could we modify the packet payload in a "match" module?  --YY@Ralink
+		if (opt & BLK_COOKIE)
+		    mangle_http_header(skb, HTTP_COOKIE);
+#endif
+		break;
+
+	    default:
+		printk("%s: Sorry! Cannot find this match option.\n", __FILE__);
+		return 0;
+	}
+
+	/* Get the http header info */
+	if (get_http_info(skb, flags, &htinfo) < 1)
+	    return 0;
+
+	/* Check if the http header content contains the forbidden keyword */
+	if (info->type == IPT_WEBSTR_HOST || info->type == IPT_WEBSTR_URL) {
+	    int nlen = 0, hlen = 0;
+	    char needle[BUFSIZE], *haystack = NULL;
+	    char *next;
+
+	    if (info->type == IPT_WEBSTR_HOST) {
+		haystack = htinfo.host;
+		hlen = htinfo.hostlen;
+	    }
+	    else {
+		haystack = htinfo.url;
+		hlen = htinfo.urllen;
+	    }
+	    split(needle, wordlist, next, token) {
+		nlen = strlen(needle);
+		SPARQ_LOG("keyword=%s, nlen=%d, hlen=%d\n", needle, nlen, hlen);
+		if (!nlen || !hlen || nlen > hlen) continue;
+		if (search(needle, haystack, nlen, hlen) != NULL) {
+		    found = 1;
+		    break;
+		}
+	    }
+	}
+	else {		/* IPT_WEBSTR_CONTENT */
+	    int vicelen;
+
+	    if (opt & BLK_JAVA) {
+		vicelen = sizeof(".js") - 1;
+		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".js", vicelen) == 0) {
+		    SPARQ_LOG("%s: MATCH....java\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+		vicelen = sizeof(".class") - 1;
+		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".class", vicelen) == 0) {
+		    SPARQ_LOG("%s: MATCH....java\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+	    }
+	    if (opt & BLK_ACTIVE){
+		vicelen = sizeof(".ocx") - 1;
+		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".ocx", vicelen) == 0) {
+		    SPARQ_LOG("%s: MATCH....activex\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+		vicelen = sizeof(".cab") - 1;
+		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".cab", vicelen) == 0) {
+		    SPARQ_LOG("%s: MATCH....activex\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+	    }
+	    if (opt & BLK_PROXY){
+		if (strnicmp(htinfo.url + htinfo.hostlen, "http://", sizeof("http://") - 1) == 0) {
+		    SPARQ_LOG("%s: MATCH....proxy\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+	    }
+	}
+
+match_ret:
+	SPARQ_LOG("%s: Verdict =======> %s \n",__FUNCTION__
+		, found ? "DROP" : "ACCEPT");
+
+	return (found ^ info->invert);
+}
+
+static int
+checkentry(const char *tablename,
+	   const void *entry,
+	   const struct xt_match *match,
+           void *matchinfo,
+           unsigned int hook_mask)
+{
+#if 0
+       if (matchsize != IPT_ALIGN(sizeof(struct ipt_webstr_info)))
+               return 0;
+#endif
+       return 1;
+}
+
+static struct xt_match xt_webstr_match[] = {
+	{
+	.name		= "webstr",
+	.family		= AF_INET,
+	.match		= match,
+	.checkentry	= checkentry,
+	.matchsize	= sizeof(struct ipt_webstr_info),
+	.me		= THIS_MODULE
+	},
+	{
+	.name		= "webstr",
+	.family		= AF_INET6,
+	.match		= match,
+	.checkentry	= checkentry,
+	.matchsize	= sizeof(struct ipt_webstr_info),
+	.me		= THIS_MODULE
+	},
+
+};
+
+static int __init init(void)
+{
+	return xt_register_matches(xt_webstr_match, ARRAY_SIZE(xt_webstr_match));
+}
+
+static void __exit fini(void)
+{
+	xt_unregister_matches(xt_webstr_match, ARRAY_SIZE(xt_webstr_match));
+}
+
+module_init(init);
+module_exit(fini);
