diff -urBbwp '-x.*' '-x*.o' linux-N16/include/linux/skbuff.h linux-N12/include/linux/skbuff.h
--- linux-N16/include/linux/skbuff.h	2009-04-09 10:34:52.000000000 +0400
+++ linux-N12/include/linux/skbuff.h	2009-08-27 07:53:25.000000000 +0400
@@ -318,6 +318,7 @@ struct sk_buff {
 				*data;
 	unsigned int		truesize;
 	atomic_t		users;
+	unsigned char		wl_idx;		/* Jiahao: index of wireless interface */
 };
 
 #ifdef __KERNEL__
diff -urBbwp '-x.*' '-x*.o' linux-N16/kernel/sys.c linux-N12/kernel/sys.c
--- linux-N16/kernel/sys.c	2009-04-20 06:40:06.000000000 +0400
+++ linux-N12/kernel/sys.c	2009-08-27 07:54:04.000000000 +0400
@@ -2307,3 +2307,141 @@ EXPORT_SYMBOL(track_flag);
 EXPORT_SYMBOL(ipaddr);
 EXPORT_SYMBOL(clean_flag); // wanduck.
 //--SZ Angela 09.03 QOS }
+
+#define MBSS_NOLAN_SSID_MAIN	0x0001			// Jiahao
+#define MBSS_NOLAN_SSID_1	0x0002			// Jiahao
+#define MBSS_NOLAN_SSID_2	0x0004			// Jiahao
+#define MBSS_NOLAN_SSID_3	0x0008			// Jiahao
+unsigned char mbss_nolan_g = 0;				// Jiahao
+unsigned char mbss_nolan_M_1 = 0;			// Jiahao
+unsigned char mbss_nolan_M_2 = 0;			// Jiahao
+unsigned char mbss_nolan_M_3 = 0;			// Jiahao
+unsigned char mbss_nolan_1_2 = 0;			// Jiahao
+unsigned char mbss_nolan_1_3 = 0;			// Jiahao
+unsigned char mbss_nolan_2_3 = 0;			// Jiahao
+unsigned char mbss_nolan_1 = 0;				// Jiahao
+unsigned char mbss_nolan_2 = 0;				// Jiahao
+unsigned char mbss_nolan_3 = 0;				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_g);				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_M_1);				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_M_2);				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_M_3);				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_1_2);				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_1_3);				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_2_3);				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_1);				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_2);				// Jiahao
+EXPORT_SYMBOL(mbss_nolan_3);				// Jiahao
+
+asmlinkage long sys_set_mbss_nolan(unsigned char flag)	// Jiahao
+{
+	printk("sys_set_mbss_nolan: %d\n", flag);
+
+	if (!flag)
+		return 0;
+	else
+		mbss_nolan_g = 1;
+
+	if ( (flag & MBSS_NOLAN_SSID_MAIN) || (flag & MBSS_NOLAN_SSID_1) )
+		mbss_nolan_M_1 = 1;
+
+	if ( (flag & MBSS_NOLAN_SSID_MAIN) || (flag & MBSS_NOLAN_SSID_2) )
+		mbss_nolan_M_2 = 1;
+
+	if ( (flag & MBSS_NOLAN_SSID_MAIN) || (flag & MBSS_NOLAN_SSID_3) )
+		mbss_nolan_M_3 = 1;
+
+	if ( (flag & MBSS_NOLAN_SSID_1) || (flag & MBSS_NOLAN_SSID_2) )
+		mbss_nolan_1_2 = 1;
+
+	if ( (flag & MBSS_NOLAN_SSID_1) || (flag & MBSS_NOLAN_SSID_3) )
+		mbss_nolan_1_3 = 1;
+
+	if ( (flag & MBSS_NOLAN_SSID_2) || (flag & MBSS_NOLAN_SSID_3) )
+		mbss_nolan_2_3 = 1;
+
+	if (flag & MBSS_NOLAN_SSID_1)
+		mbss_nolan_1 = 1;
+
+	if (flag & MBSS_NOLAN_SSID_2)
+		mbss_nolan_2 = 1;
+
+	if (flag & MBSS_NOLAN_SSID_3)
+		mbss_nolan_3 = 1;
+
+	return 0;
+}
+
+#define MBSS_NOWAN_SSID_MAIN	0x0001			// Jiahao
+#define MBSS_NOWAN_SSID_1	0x0002			// Jiahao
+#define MBSS_NOWAN_SSID_2	0x0004			// Jiahao
+#define MBSS_NOWAN_SSID_3	0x0008			// Jiahao
+unsigned char mbss_nowan_g = 0;				// Jiahao
+unsigned char mbss_nowan_1 = 0;				// Jiahao
+unsigned char mbss_nowan_2 = 0;				// Jiahao
+unsigned char mbss_nowan_3 = 0;				// Jiahao
+EXPORT_SYMBOL(mbss_nowan_g);				// Jiahao
+EXPORT_SYMBOL(mbss_nowan_1);				// Jiahao
+EXPORT_SYMBOL(mbss_nowan_2);				// Jiahao
+EXPORT_SYMBOL(mbss_nowan_3);				// Jiahao
+
+asmlinkage long sys_set_mbss_nowan(unsigned char flag)	// Jiahao
+{
+	printk("sys_set_mbss_nowan: %d\n", flag);
+
+	if (!flag)
+		return 0;
+	else
+		mbss_nowan_g = 1;
+
+	if (flag & MBSS_NOWAN_SSID_1)
+		mbss_nowan_1 = 1;
+
+	if (flag & MBSS_NOWAN_SSID_2)
+		mbss_nowan_2 = 1;
+
+	if (flag & MBSS_NOWAN_SSID_3)
+		mbss_nowan_3 = 1;
+
+	return 0;
+}
+
+#define MBSS_PRIO_SSID_MAIN_LOW		0x0001		// Jiahao
+#define MBSS_PRIO_SSID_MAIN_NORMAL	0x0002		// Jiahao
+#define MBSS_PRIO_SSID_1_LOW		0x0004		// Jiahao
+#define MBSS_PRIO_SSID_1_NORMAL		0x0008		// Jiahao
+#define MBSS_PRIO_SSID_2_LOW		0x0010		// Jiahao
+#define MBSS_PRIO_SSID_2_NORMAL		0x0020		// Jiahao
+#define MBSS_PRIO_SSID_3_LOW		0x0040		// Jiahao
+#define MBSS_PRIO_SSID_3_NORMAL		0x0080		// Jiahao
+unsigned char mbss_prio_1 = 1;				// Jiahao
+unsigned char mbss_prio_2 = 1;				// Jiahao
+unsigned char mbss_prio_3 = 1;				// Jiahao
+EXPORT_SYMBOL(mbss_prio_1);				// Jiahao
+EXPORT_SYMBOL(mbss_prio_2);				// Jiahao
+EXPORT_SYMBOL(mbss_prio_3);				// Jiahao
+
+asmlinkage long sys_set_mbss_prio(unsigned char flag)	// Jiahao
+{
+	printk("sys_set_mbss_prio: %d\n", flag);
+
+	if (!flag)
+		return 0;
+
+	if (flag & MBSS_PRIO_SSID_1_LOW)
+		mbss_prio_1 = 0;
+	else if (flag & MBSS_PRIO_SSID_1_NORMAL)
+		mbss_prio_1 = 1;
+
+	if (flag & MBSS_PRIO_SSID_2_LOW)
+		mbss_prio_2 = 0;
+	else if (flag & MBSS_PRIO_SSID_2_NORMAL)
+		mbss_prio_2 = 1;
+
+	if (flag & MBSS_PRIO_SSID_3_LOW)
+		mbss_prio_3 = 0;
+	else if (flag & MBSS_PRIO_SSID_3_NORMAL)
+		mbss_prio_3 = 1;
+
+	return 0;
+}
diff -urBbwp '-x.*' '-x*.o' linux-N16/net/bridge/br_forward.c linux-N12/net/bridge/br_forward.c
--- linux-N16/net/bridge/br_forward.c	2008-12-12 06:34:55.000000000 +0300
+++ linux-N12/net/bridge/br_forward.c	2009-08-27 07:54:49.000000000 +0400
@@ -20,11 +20,101 @@
 #include <linux/netfilter_bridge.h>
 #include "br_private.h"
 
+extern unsigned char mbss_nolan_g;				// Jiahao
+extern unsigned char mbss_nolan_M_1;				// Jiahao
+extern unsigned char mbss_nolan_M_2;				// Jiahao
+extern unsigned char mbss_nolan_M_3;				// Jiahao
+extern unsigned char mbss_nolan_1_2;				// Jiahao
+extern unsigned char mbss_nolan_1_3;				// Jiahao
+extern unsigned char mbss_nolan_2_3;				// Jiahao
+extern unsigned char mbss_nolan_1;				// Jiahao
+extern unsigned char mbss_nolan_2;				// Jiahao
+extern unsigned char mbss_nolan_3;				// Jiahao
+
+int SSID1_to_SSID2(unsigned char *deva, unsigned char *devb)	// Jiahao
+{
+	if (!mbss_nolan_g)
+		return 0;
+
+	if ( mbss_nolan_M_1 && !strncmp(deva + 3, "1", 1) && !strncmp(devb + 3, ".1", 2) )
+		return 1;
+	else if ( mbss_nolan_M_2 && !strncmp(deva + 3, "1", 1) && !strncmp(devb + 3, ".2", 2) )
+		return 1;
+	else if ( mbss_nolan_M_3 && !strncmp(deva + 3, "1", 1) && !strncmp(devb + 3, ".3", 2) )
+		return 1;
+
+	else if ( mbss_nolan_M_1 && !strncmp(deva + 3, ".1", 2) && !strncmp(devb + 3, "1", 1) )
+		return 1;
+	else if ( mbss_nolan_1_2 && !strncmp(deva + 3, ".1", 2) && !strncmp(devb + 3, ".2", 2) )
+		return 1;
+	else if ( mbss_nolan_1_3 && !strncmp(deva + 3, ".1", 2) && !strncmp(devb + 3, ".3", 2) )
+		return 1;
+	else if ( mbss_nolan_1 && !strncmp(deva + 3, ".1", 2) && !strncmp(devb, "v", 1) )
+		return 1;
+
+	else if ( mbss_nolan_M_2 && !strncmp(deva + 3, ".2", 2) && !strncmp(devb + 3, "1", 1) )
+		return 1;
+	else if ( mbss_nolan_1_2 && !strncmp(deva + 3, ".2", 2) && !strncmp(devb + 3, ".1", 2) )
+		return 1;
+	else if ( mbss_nolan_2_3 && !strncmp(deva + 3, ".2", 2) && !strncmp(devb + 3, ".3", 2) )
+		return 1;
+	else if ( mbss_nolan_2 && !strncmp(deva + 3, ".2", 2) && !strncmp(devb, "v", 1) )
+		return 1;
+
+	else if ( mbss_nolan_M_3 && !strncmp(deva + 3, ".3", 2) && !strncmp(devb + 3, "1", 1) )
+		return 1;
+	else if ( mbss_nolan_1_3 && !strncmp(deva + 3, ".3", 2) && !strncmp(devb + 3, ".1", 2) )
+		return 1;
+	else if ( mbss_nolan_2_3 && !strncmp(deva + 3, ".3", 2) && !strncmp(devb + 3, ".2", 2) )
+		return 1;
+	else if ( mbss_nolan_3 && !strncmp(deva + 3, ".3", 2) && !strncmp(devb, "v", 1) )
+		return 1;
+
+/*
+	if ( mbss_nolan_M_1 && !strncmp(deva, "eth1", 4) && !strncmp(devb, "wl0.1", 5) )
+		return 1;
+	else if ( mbss_nolan_M_2 && !strncmp(deva, "eth1", 4) && !strncmp(devb, "wl0.2", 5) )
+		return 1;
+	else if ( mbss_nolan_M_3 && !strncmp(deva, "eth1", 4) && !strncmp(devb, "wl0.3", 5) )
+		return 1;
+
+	else if ( mbss_nolan_M_1 && !strncmp(deva, "wl0.1", 5) && !strncmp(devb, "eth1", 4) )
+		return 1;
+	else if ( mbss_nolan_1_2 && !strncmp(deva, "wl0.1", 5) && !strncmp(devb, "wl0.2", 5) )
+		return 1;
+	else if ( mbss_nolan_1_3 && !strncmp(deva, "wl0.1", 5) && !strncmp(devb, "wl0.3", 5) )
+		return 1;
+	else if ( mbss_nolan_1 && !strncmp(deva, "wl0.1", 5) && !strncmp(devb, "vlan1", 5) )
+		return 1;
+
+	else if ( mbss_nolan_M_2 && !strncmp(deva, "wl0.2", 5) && !strncmp(devb, "eth1", 4) )
+		return 1;
+	else if ( mbss_nolan_1_2 && !strncmp(deva, "wl0.2", 5) && !strncmp(devb, "wl0.1", 5) )
+		return 1;
+	else if ( mbss_nolan_2_3 && !strncmp(deva, "wl0.2", 5) && !strncmp(devb, "wl0.3", 5) )
+		return 1;
+	else if ( mbss_nolan_2 && !strncmp(deva, "wl0.2", 5) && !strncmp(devb, "vlan1", 5) )
+		return 1;
+
+	else if ( mbss_nolan_M_3 && !strncmp(deva, "wl0.3", 5) && !strncmp(devb, "eth1", 4) )
+		return 1;
+	else if ( mbss_nolan_1_3 && !strncmp(deva, "wl0.3", 5) && !strncmp(devb, "wl0.1", 5) )
+		return 1;
+	else if ( mbss_nolan_2_3 && !strncmp(deva, "wl0.3", 5) && !strncmp(devb, "wl0.2", 5) )
+		return 1;
+	else if ( mbss_nolan_3 && !strncmp(deva, "wl0.3", 5) && !strncmp(devb, "vlan1", 5) )
+		return 1;
+*/
+
+	return 0;
+}
+
 /* Don't forward packets to originating port or forwarding diasabled */
 static inline int should_deliver(const struct net_bridge_port *p,
 				 const struct sk_buff *skb)
 {
-	return (skb->dev != p->dev && p->state == BR_STATE_FORWARDING);
+//	return (skb->dev != p->dev && p->state == BR_STATE_FORWARDING);	// Jiahao
+	return ((skb->dev != p->dev && p->state == BR_STATE_FORWARDING) && !SSID1_to_SSID2(skb->dev->name, p->dev->name));
 }
 
 static inline unsigned packet_length(const struct sk_buff *skb)
diff -urBbwp '-x.*' '-x*.o' linux-N16/net/bridge/br_private.h linux-N12/net/bridge/br_private.h
--- linux-N16/net/bridge/br_private.h	2008-12-12 06:34:55.000000000 +0300
+++ linux-N12/net/bridge/br_private.h	2009-08-27 07:54:48.000000000 +0400
@@ -176,6 +176,7 @@ extern void br_flood_deliver(struct net_
 extern void br_flood_forward(struct net_bridge *br,
 		      struct sk_buff *skb,
 		      int clone);
+extern int SSID1_to_SSID2(unsigned char *deva, unsigned char *devb);	// Jiahao
 
 /* br_if.c */
 extern void br_port_carrier_check(struct net_bridge_port *p);
diff -urBbwp '-x.*' '-x*.o' linux-N16/net/core/dev.c linux-N12/net/core/dev.c
--- linux-N16/net/core/dev.c	2008-12-12 06:34:56.000000000 +0300
+++ linux-N12/net/core/dev.c	2009-08-27 07:54:57.000000000 +0400
@@ -1647,6 +1647,15 @@ int netif_rx(struct sk_buff *skb)
 	if (!skb->tstamp.tv64)
 		net_timestamp(skb);
 
+	if (!strncmp(skb->dev->name + 3, ".1", 2))	/* Jiahao: match wl0.1 */
+		skb->wl_idx = 0x2;
+	else if (!strncmp(skb->dev->name + 3, ".2", 2))	/* Jiahao: match wl0.2 */
+		skb->wl_idx = 0x4;
+	else if (!strncmp(skb->dev->name + 3, ".3", 2))	/* Jiahao: match wl0.3 */
+		skb->wl_idx = 0x8;
+	else						/* Angela: for priority ssid and lan */
+		skb->wl_idx = 0x0;
+
 	/*
 	 * The code is rearranged so that the path is the most
 	 * short when CPU is congested, but is still operating.
@@ -2992,6 +3001,46 @@ int dev_ioctl(unsigned int cmd, void __u
 			     cmd <= SIOCDEVPRIVATE + 15)) {
 				dev_load(ifr.ifr_name);
 				rtnl_lock();
+
+#ifdef REMOVE
+				if (strcmp(ifr.ifr_name, "eth1") == 0 && cmd >= SIOCDEVPRIVATE)
+				{
+					typedef struct wl_ioctl
+					{
+						unsigned int cmd;
+						void *buf;
+						unsigned int len;
+						char set;
+						unsigned int used;
+						unsigned int needed;
+					} wl_ioctl_t;
+
+					wl_ioctl_t *ioc;
+					int i;
+					unsigned char *dd;
+
+					ioc = (wl_ioctl_t *) ifr.ifr_data;
+
+//					if (ioc->cmd == 50)
+//					{
+						dd = (unsigned char *) ioc->buf;
+						printk("\ncmd = %d\n", ioc->cmd);
+
+						if(ioc && dd)
+						{
+							for(i=0; i < ioc->len; i++)
+							{
+								printk("%x ", dd[i]);
+								if (i%16 == 0)
+									printk("\n");
+							}
+							printk("\n");
+						}
+//					}
+				}
+#endif
+
+
 				ret = dev_ifsioc(&ifr, cmd);
 				rtnl_unlock();
 				if (!ret && copy_to_user(arg, &ifr,
diff -urBbwp '-x.*' '-x*.o' linux-N16/net/ipv4/ip_forward.c linux-N12/net/ipv4/ip_forward.c
--- linux-N16/net/ipv4/ip_forward.c	2008-12-12 06:35:00.000000000 +0300
+++ linux-N12/net/ipv4/ip_forward.c	2009-08-27 07:54:41.000000000 +0400
@@ -52,12 +52,32 @@ static inline int ip_forward_finish(stru
 	return dst_output(skb);
 }
 
+extern unsigned char mbss_nowan_g;				// Jiahao
+extern unsigned char mbss_nowan_1;				// Jiahao
+extern unsigned char mbss_nowan_2;				// Jiahao
+extern unsigned char mbss_nowan_3;				// Jiahao
+
+#define MBSS_NOWAN_SSID_MAIN	0x0001				// Jiahao
+#define MBSS_NOWAN_SSID_1	0x0002				// Jiahao
+#define MBSS_NOWAN_SSID_2	0x0004				// Jiahao
+#define MBSS_NOWAN_SSID_3	0x0008				// Jiahao
+
 int ip_forward(struct sk_buff *skb)
 {
 	struct iphdr *iph;	/* Our header */
 	struct rtable *rt;	/* Route we use */
 	struct ip_options * opt	= &(IPCB(skb)->opt);
 
+	if (mbss_nowan_g)					// Jiahao
+	{
+		if (mbss_nowan_1 && (skb->wl_idx & MBSS_NOWAN_SSID_1))
+			goto drop;
+		else if (mbss_nowan_2 && (skb->wl_idx & MBSS_NOWAN_SSID_2))
+			goto drop;
+		else if (mbss_nowan_3 && (skb->wl_idx & MBSS_NOWAN_SSID_3))
+			goto drop;
+	}
+
 	if (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))
 		goto drop;
 
diff -urBbwp '-x.*' '-x*.o' linux-N16/net/netfilter/nf_conntrack_core.c linux-N12/net/netfilter/nf_conntrack_core.c
--- linux-N16/net/netfilter/nf_conntrack_core.c	2009-03-30 07:02:15.000000000 +0400
+++ linux-N12/net/netfilter/nf_conntrack_core.c	2009-08-27 07:54:33.000000000 +0400
@@ -112,6 +112,11 @@ static unsigned int nf_conntrack_hash_rn
 extern int track_flag;
 extern ulong ipaddr;
 u_int8_t port_num_udp[65536];
+
+extern unsigned char mbss_prio_1;	//SZ-Angela Add for Multiple SSID
+extern unsigned char mbss_prio_2;
+extern unsigned char mbss_prio_3;
+
 //--SZ angela 09.03 }
 
 static u_int32_t __hash_conntrack(const struct nf_conntrack_tuple *tuple,
@@ -919,6 +924,25 @@ resolve_normal_ct(struct sk_buff *skb,
 					skb->mark = 50;
 				break;
 	}
+
+		switch(skb->wl_idx)	//SZ-Angela Add for Multiple SSID
+		{
+			case 2:
+				if(mbss_prio_1 == 0)
+					skb->mark = 60;
+				break;
+			case 4:
+				if(mbss_prio_2 == 0)
+					skb->mark = 60;
+				break;
+			case 8:
+				if(mbss_prio_3 == 0)
+					skb->mark = 60;
+				break;
+			default:
+				break;
+		}
+
 		write_unlock_bh(&nf_conntrack_lock);			
 	} //--SZ angela 09.03 }
 
